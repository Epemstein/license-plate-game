<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>License Plate Game ‚Äì Time Trial</title>
    <style>

        @font-face {
            font-family: "RoadgeekUS";
            src: url("fonts/Roadgeek.woff2") format("woff2");
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            max-width: 1100px;
            margin: 40px auto;
            padding: 0 16px 40px;
            line-height: 1.5;
        }

        h1 {
            margin-top: 0;
            margin-bottom: 0.5rem;
        }

        .layout {
            display: flex;
            align-items: flex-start;
            gap: 32px;
        }

        .left-panel { flex: 0 0 55%; }
        .right-panel { flex: 1; }

        .car-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
            max-width: 360px;
            height: 380px;
            overflow: hidden;
        }

        .car-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .plate-text {
            position: absolute;
            left: 52%;
            bottom: 26%;
            transform: translateX(-50%);
            font-family: "RoadgeekUS", sans-serif;
            font-size: 3rem;
            letter-spacing: 0.33em;
            color: #222;
            font-weight: 400;
            text-transform: uppercase;
            text-shadow: 0 1px 2px rgba(0,0,0,0.35);
            pointer-events: none;
        }

        .difficulty {
            margin-top: 8px;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .diff-easy { color: #16a34a; }
        .diff-med  { color: #d97706; }
        .diff-hard { color: #dc2626; }

        .controls {
            margin: 24px 0 12px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }

        .controls input[type="text"] {
            flex: 1;
            min-width: 180px;
            padding: 8px;
            font-size: 1rem;
        }

        button {
            padding: 8px 14px;
            font-size: 0.95rem;
            cursor: pointer;
        }

        button:disabled {
            opacity: 0.6;
            cursor: default;
        }

        #startButton {
            display: none;
        }

        #chartButton {
            margin-top: 8px;
            padding: 6px 12px;
            font-size: 0.85rem;
            display: none;
        }

        #result {
            margin-top: 10px;
            font-weight: 600;
        }

        #debug {
            margin-top: 6px;
            font-size: 0.85rem;
            color: #6b7280;
        }

        #timerRow {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin-bottom: 8px;
            font-weight: 600;
            font-size: 0.95rem;
        }

        #timerDisplay { color: #111827; }
        #progressDisplay { color: #374151; }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-size: 0.95rem;
        }

        th, td {
            border-bottom: 1px solid #e5e7eb;
            padding: 6px 8px;
            text-align: left;
        }

        th {
            background-color: #f3f4f6;
            font-weight: 600;
        }

        tr:nth-child(even) td {
            background-color: #f9fafb;
        }

        .history-empty {
            font-size: 0.85rem;
            color: #6b7280;
            margin-top: 4px;
        }

        .plate-letter-highlight {
            color: #16a34a;
            font-weight: 700;
        }

        .clickable-plate {
            cursor: pointer;
            text-decoration: underline;
            text-decoration-style: dotted;
        }

        .clickable-plate:hover {
            text-decoration-style: solid;
        }

        /* Floating labels */
        .float-label {
            position: fixed;
            transform: translate(-50%, -50%);
            z-index: 999;
            pointer-events: none;
            background: rgba(255,255,255,0.95);
            padding: 3px 6px;
            border-radius: 4px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.25);
            opacity: 1;
            transition:
                top 0.4s ease-out,
                left 0.4s ease-out,
                opacity 0.4s ease-out;
            white-space: nowrap;
            font-size: 0.9rem;
        }

        .float-label-plate {
            font-size: 1.1rem;
            letter-spacing: 0.3em;
            font-weight: 600;
        }

        .float-label-word {
            font-weight: 600;
        }

        .float-label-diff {
            font-size: 0.8rem;
            font-weight: 700;
        }

        /* Modal base styles */
        .modal-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.45);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 900;
        }

        /* Explicit stacking order so words > chart > game */
        #gameModalBackdrop {
            z-index: 900;
        }
        #chartModalBackdrop {
            z-index: 950;
        }
        #wordsModalBackdrop {
            z-index: 1000;
        }

        .modal-backdrop.show {
            display: flex;
        }

        .modal {
            background: #ffffff;
            border-radius: 8px;
            max-width: 700px;
            width: 100%;
            max-height: 80vh;
            box-shadow: 0 10px 30px rgba(0,0,0,0.25);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .modal-header {
            padding: 10px 14px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #f3f4f6;
        }

        .modal-title {
            font-weight: 600;
            font-size: 1rem;
        }

        .modal-body {
            padding: 10px 14px;
            overflow-y: auto;
            font-size: 0.95rem;
        }

        .modal-footer {
            padding: 8px 14px;
            border-top: 1px solid #e5e7eb;
            text-align: right;
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }

        .modal-close-btn {
            border: none;
            background: transparent;
            font-size: 1.1rem;
            cursor: pointer;
        }

        .words-list {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            white-space: normal;
        }

        .words-list-item {
            display: block;
            margin-bottom: 2px;
        }

        .words-sort-controls {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 6px;
            font-size: 0.85rem;
        }

        .words-sort-label {
            color: #6b7280;
        }

        .words-sort-button {
            padding: 2px 8px;
            font-size: 0.8rem;
            border-radius: 9999px;
            border: 1px solid #d1d5db;
            background: #f9fafb;
            cursor: pointer;
        }

        .words-sort-button.active {
            background: #111827;
            color: #ffffff;
            border-color: #111827;
        }

        #resultsChart {
            width: 100%;
            min-height: 320px;
        }

        @media (max-width: 800px) {
            .layout {
                flex-direction: column;
            }
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
</head>
<body>

<h1>The License Plate Game v4</h1>
<div style="margin-bottom:20px;display:flex;gap:10px;flex-wrap:wrap;">
    <button id="dailyChallengeBtn" style="padding:10px 20px;background:#fbbf24;border:2px solid #f59e0b;font-weight:bold;cursor:pointer;">üèÜ Daily Challenge</button>
    <button id="practiceBtn" style="padding:10px 20px;cursor:pointer;">üéÆ Practice Mode</button>

    <div id="authSection" style="margin-left:auto;">
        <button id="signInBtn" onclick="signInWithGoogle()" style="display:none;padding:8px 16px;cursor:pointer;background:#4285f4;color:white;border:none;border-radius:4px;font-weight:600;">Sign In with Google</button>
        <div id="userInfo" style="display:none;padding:10px;background:#f3f4f6;border-radius:4px;">
            Signed in: <strong id="userName"></strong>
            <button id="signOutBtn" onclick="firebase.auth().signOut()" style="margin-left:10px;padding:4px 8px;cursor:pointer;">Sign Out</button>
        </div>
    </div>
</div>
<div id="modeIndicator" style="padding:8px;background:#f3f4f6;border:2px dashed #d1d5db;border-radius:4px;margin-bottom:10px;font-weight:600;text-align:left;color:#000000;">üëÜ Select a game mode above to begin</div>


<div class="layout">
    <!-- LEFT PANEL -->
    <div class="left-panel">
        <p>
            Solve <strong>10 plates</strong> as fast as you can.<br>
            The plate letters must appear in your word in order (not necessarily consecutively).
        </p>

        <div class="car-wrapper">
            <img src="car.png" alt="Car with license plate" class="car-image">
            <div id="plate" class="plate-text">---</div>
        </div>

        <div id="difficultyLabel" class="difficulty diff-med">
            Difficulty: ‚Äî
        </div>
        <div id="viableCountLabel" style="color:#6b7280; font-size:0.9rem; margin-top:2px;">
        </div>

        <div class="controls">
            <button id="startButton">Play again</button>
            <input id="wordInput" type="text" placeholder="Type a word" autocomplete="off">
            <button id="checkButton">Check</button>
            <button id="skipButton">Skip +5s</button>
        </div>

        <div id="result"></div>
        <button id="chartButton">View run chart</button>

        <div id="debug"></div>
    </div>

    <!-- RIGHT PANEL -->
    <div class="right-panel">
        <div id="timerRow">
            <span id="timerDisplay">Time: 0.0 s</span>
            <span id="progressDisplay">Solved: 0 / 10</span>
        </div>

        <h2>Solved Plates</h2>
        <table>
            <thead>
            <tr>
                <th>Plate</th>
                <th>Word / Penalty</th>
                <th>Time</th>
                <th>Difficulty</th>
            </tr>
            </thead>
            <tbody id="historyBody"></tbody>
        </table>
        <div id="historyEmpty" class="history-empty">
            No solved plates yet.
        </div>
    </div>
</div>

<!-- GAME START / END MODAL -->
<div id="gameModalBackdrop" class="modal-backdrop">
    <div class="modal">
        <div class="modal-header">
            <div class="modal-title" id="gameModalTitle">License Plate Game</div>
            <button class="modal-close-btn" id="gameModalCloseBtn" aria-label="Close">&times;</button>
        </div>
        <div class="modal-body" id="gameModalBody">
            <!-- Filled dynamically -->
        </div>
        <div class="modal-footer">
            <button id="gameModalSecondaryBtn" style="display:none;">View chart</button>
            <button id="gameModalPrimaryBtn">Start Game</button>
        </div>
    </div>
</div>

<!-- MODAL: Viable words for a plate -->
<div id="wordsModalBackdrop" class="modal-backdrop">
    <div class="modal">
        <div class="modal-header">
            <div class="modal-title" id="wordsModalTitle">Plate: ---</div>
            <button class="modal-close-btn" id="wordsModalCloseBtn" aria-label="Close">&times;</button>
        </div>
        <div class="modal-body">
            <div id="wordsModalStatus" style="margin-bottom:6px; color:#6b7280; font-size:0.9rem;">
                Loading...
            </div>
            <div id="wordsModalSortControls" class="words-sort-controls">
                <span class="words-sort-label">Sort:</span>
                <button id="wordsSortAlphaBtn" class="words-sort-button active">A‚ÄìZ</button>
                <button id="wordsSortLengthBtn" class="words-sort-button">Shortest ‚Üí longest</button>
            </div>
            <div id="wordsModalList" class="words-list"></div>
        </div>
        <div class="modal-footer">
            <button id="wordsModalCloseBtnBottom">Close</button>
        </div>
    </div>
</div>

<!-- MODAL: End-of-game chart -->
<div id="chartModalBackdrop" class="modal-backdrop">
    <div class="modal">
        <div class="modal-header">
            <div class="modal-title">Run breakdown</div>
            <button class="modal-close-btn" id="chartModalCloseBtn" aria-label="Close">&times;</button>
        </div>
        <div class="modal-body">
            <canvas id="resultsChart"></canvas>
            <div style="margin-top:8px; font-size:0.85rem; color:#6b7280;">
                Blue = thinking time, red = skip penalty. Click a bar or point to see all viable words for that plate.
            </div>
        </div>
        <div class="modal-footer">
            <button id="chartModalCloseBtnBottom">Close</button>
        </div>
    </div>
</div>

<script>

    // === FIREBASE ===
    const firebaseConfig = {
        apiKey: "AIzaSyBEa4aJf-cB25uzvEXdpNf1bG5kOOL5PXs",
        authDomain: "license-plate-game-2ea96.firebaseapp.com",
        databaseURL: "https://license-plate-game-2ea96-default-rtdb.firebaseio.com",
        projectId: "license-plate-game-2ea96",
        storageBucket: "license-plate-game-2ea96.firebasestorage.app",
        messagingSenderId: "247985429580",
        appId: "1:247985429580:web:4927cee2ca3581b569a8e9"
    };
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const database = firebase.database();
    let gameMode = 'practice';
    let currentUser = null;
    let dailyPlateSequence = null;
    let currentViewingDate = null; // Track which date we're viewing

    auth.onAuthStateChanged((user) => {
        currentUser = user;
        const signInBtn = document.getElementById('signInBtn');
        const userInfo = document.getElementById('userInfo');
        if (user) {
            signInBtn.style.display = 'none';
            userInfo.style.display = 'block';
            document.getElementById('userName').textContent = user.displayName || user.email;
        } else {
            signInBtn.style.display = 'inline-block';
            userInfo.style.display = 'none';
        }
    });

    function getTodayString() {
        const d = new Date();
        return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
    }

    function seededRandom(seed) {
        let v = seed;
        return () => { v = (v*9301+49297)%233280; return v/233280; };
    }

    function generateDailyPlates(dateStr) {
        const seed = dateStr.split('-').reduce((a,v)=>a+parseInt(v),0);
        const rng = seededRandom(seed);
        if (!platesReady || !ALL_PLATES.length) return [];
        
        // Use weighted difficulty selection like the original game
        const dailyPlates = [];
        const usedPlates = new Set();
        
        while (dailyPlates.length < 200 && usedPlates.size < ALL_PLATES.length) {
            // Pick a difficulty band using the same probabilities as the game
            const r = rng();
            let band;
            if (r < 0.40) band = "very_easy";
            else if (r < 0.60) band = "easy";
            else if (r < 0.75) band = "medium";
            else if (r < 0.90) band = "difficult";
            else if (r < 0.95) band = "hard";
            else if (r < 0.98) band = "very_hard";
            else band = "impossible";
            
            // Get all plates in this band that haven't been used
            const bandPlates = ALL_PLATES.filter(plate => {
                if (usedPlates.has(plate)) return false;
                const diff = PLATE_DIFFICULTY && PLATE_DIFFICULTY[plate] ? PLATE_DIFFICULTY[plate].difficulty : null;
                if (!diff) return false;
                
                if (band === "very_easy" && diff >= 0 && diff <= 10) return true;
                if (band === "easy" && diff >= 11 && diff <= 34) return true;
                if (band === "medium" && diff >= 35 && diff <= 49) return true;
                if (band === "difficult" && diff >= 50 && diff <= 79) return true;
                if (band === "hard" && diff >= 80 && diff <= 88) return true;
                if (band === "very_hard" && diff >= 89 && diff <= 96) return true;
                if (band === "impossible" && diff >= 97 && diff <= 100) return true;
                return false;
            });
            
            // Pick a random plate from this band
            if (bandPlates.length > 0) {
                const idx = Math.floor(rng() * bandPlates.length);
                const chosen = bandPlates[idx];
                dailyPlates.push(chosen);
                usedPlates.add(chosen);
            }
        }
        
        return dailyPlates;
    }

    async function signInWithGoogle() {
        try {
            await auth.signInWithPopup(new firebase.auth.GoogleAuthProvider());
            return true;
        } catch(e) {
            alert('Sign in failed: '+e.message);
            return false;
        }
    }

    async function checkIfPlayedToday() {
        if (!currentUser) return false;
        const t = getTodayString();
        const s1 = await database.ref(`scores/${t}/${currentUser.uid}`).once('value');
        if (s1.exists()) return true;
        const s2 = await database.ref(`started/${t}/${currentUser.uid}`).once('value');
        return s2.exists();
    }

    async function saveScore(time,solved,skipped) {
        if (!currentUser || gameMode!=='daily') return;
        const today = getTodayString();
        
        // Prepare game history for saving
        const historyData = gameHistory.map(entry => ({
            plate: entry.plate,
            word: entry.word,
            skipped: entry.skipped || false,
            thinkingSeconds: Math.floor(entry.thinkingSeconds * 10) / 10,
            penaltySeconds: entry.penaltySeconds || 0
        }));
        
        await database.ref(`scores/${today}/${currentUser.uid}`).set({
            userId: currentUser.uid,
            userName: currentUser.displayName || currentUser.email,
            totalTime: Math.floor(time*10)/10,
            solved: solved,
            skipped: skipped,
            timestamp: Date.now(),
            history: historyData
        });
    }

    async function loadLeaderboard(dateStr) {
        console.log('Loading scores for:', dateStr);
        const snap = await database.ref(`scores/${dateStr}`).once('value');
        console.log('Firebase snapshot exists:', snap.exists());
        console.log('Raw snapshot value:', snap.val());
        const scores = [];
        snap.forEach(c => {
            console.log('Processing score:', c.val());
            scores.push(c.val());
        });
        console.log('Total scores loaded:', scores.length);
        const sorted = scores.sort((a,b)=>a.totalTime-b.totalTime);
        console.log('Sorted scores:', sorted);
        return sorted;
    }


    // Toggle comparison table
    function toggleCompareTable() {
        const btn = document.getElementById('compareRunsBtn');
        
        // Don't do anything if button is disabled (locked)
        if (btn.disabled) {
            return;
        }
        
        const container = document.getElementById('comparisonTableContainer');
        if (container.style.display === 'none') {
            container.style.display = 'block';
            btn.textContent = 'Hide Comparison';
            buildComparisonTable();
        } else {
            container.style.display = 'none';
            btn.textContent = 'Compare All Runs';
        }
    }
    window.toggleCompareTable = toggleCompareTable;
    
    // Get color based on time (gradient)
    function getTimeColor(seconds) {
        if (seconds <= 1.5) return '#22c55e'; // green (under 1.5s)
        if (seconds >= 30) return '#ef4444'; // dark red (30s+)
        
        if (seconds <= 6) {
            // Green to white (1.5s ‚Üí 6s)
            const ratio = (seconds - 1.5) / 4.5;
            const r = Math.round(34 + (255 - 34) * ratio);
            const g = Math.round(197 + (255 - 197) * ratio);
            const b = Math.round(94 + (255 - 94) * ratio);
            return `rgb(${r},${g},${b})`;
        } else {
            // White to red (6s ‚Üí 30s)
            const ratio = (seconds - 6) / 24;
            const r = 255;
            const g = Math.round(255 - (255 - 68) * ratio);
            const b = Math.round(255 - (255 - 68) * ratio);
            return `rgb(${r},${g},${b})`;
        }
    }
    
    // Build comparison table
    async function buildComparisonTable() {
        const contentEl = document.getElementById('comparisonTable');
        contentEl.innerHTML = 'Loading comparison...';
        
        try {
            // Use the date currently being viewed, not always today
            const dateStr = currentViewingDate || getTodayString();
            console.log('Building comparison for date:', dateStr);
            const scores = await loadLeaderboard(dateStr);
            
            if (scores.length === 0) {
                contentEl.innerHTML = '<p style="text-align:center;color:#6b7280;">No data available</p>';
                return;
            }
            
            // Find the longest history (most plates encountered)
            let maxPlates = 0;
            const playersData = [];
            
            for (const score of scores) {
                if (score.history && score.history.length > 0) {
                    maxPlates = Math.max(maxPlates, score.history.length);
                    playersData.push({
                        name: score.userName,
                        time: score.totalTime,
                        history: score.history
                    });
                }
            }
            
            if (maxPlates === 0) {
                contentEl.innerHTML = '<p style="text-align:center;color:#6b7280;">No detailed history available</p>';
                return;
            }
            
            // Collect all plate names in order
            const plateNames = [];
            for (let i = 0; i < maxPlates; i++) {
                let plateName = '‚Äî';
                for (const player of playersData) {
                    if (i < player.history.length && player.history[i].plate) {
                        plateName = player.history[i].plate;
                        break;
                    }
                }
                plateNames.push(plateName);
            }
            
            // Build table
            let html = '<table style="width:100%;border-collapse:collapse;font-size:0.9rem;">';
            
            // Calculate statistics for each plate first
            const plateStats = [];
            for (let i = 0; i < maxPlates; i++) {
                let totalTime = 0;
                let count = 0;
                let skipCount = 0;
                
                playersData.forEach(player => {
                    if (i < player.history.length) {
                        count++;
                        const entry = player.history[i];
                        const time = entry.skipped 
                            ? (entry.thinkingSeconds || 0) + entry.penaltySeconds 
                            : entry.thinkingSeconds;
                        totalTime += time;
                        if (entry.skipped) skipCount++;
                    }
                });
                
                const avgTime = count > 0 ? (totalTime / count).toFixed(1) : '‚Äî';
                const skipRate = count > 0 ? Math.round((skipCount / count) * 100) : 0;
                plateStats.push({ avgTime, skipRate });
            }
            
            // Header row with plate names and stats
            html += '<thead><tr style="background:#f3f4f6;">';
            html += '<th style="padding:8px;text-align:left;position:sticky;left:0;background:#f3f4f6;z-index:2;min-width:120px;">Player</th>';
            for (let i = 0; i < maxPlates; i++) {
                const stats = plateStats[i];
                const skipColor = stats.skipRate > 50 ? '#dc2626' : stats.skipRate > 25 ? '#f59e0b' : '#16a34a';
                html += `<th style="padding:8px;text-align:center;min-width:100px;">`;
                html += `<div style="font-weight:bold;font-size:1rem;">${plateNames[i]}</div>`;
                html += `<div style="font-size:0.75rem;color:#6b7280;margin-top:2px;">Avg: ${stats.avgTime}s</div>`;
                html += `<div style="font-size:0.75rem;color:${skipColor};margin-top:1px;">Skip: ${stats.skipRate}%</div>`;
                html += `</th>`;
            }
            html += '</tr></thead><tbody>';
            
            // Player rows
            playersData.forEach((player, idx) => {
                const bg = idx % 2 === 0 ? '#fff' : '#f9fafb';
                
                html += `<tr style="background:${bg};">`;
                html += `<td style="padding:12px;font-weight:bold;position:sticky;left:0;background:${bg};z-index:1;white-space:nowrap;">${player.name}<br><span style="font-size:0.85rem;color:#6b7280;">(${player.time.toFixed(1)}s)</span></td>`;
                
                // Combined word + time cells with gradient
                for (let i = 0; i < maxPlates; i++) {
                    if (i < player.history.length) {
                        const entry = player.history[i];
                        const word = entry.skipped ? '‚ùå' : entry.word;
                        
                        // Calculate total time (thinking + penalty for skips)
                        const totalTime = entry.skipped 
                            ? (entry.thinkingSeconds || 0) + entry.penaltySeconds 
                            : entry.thinkingSeconds;
                        
                        const displayTime = entry.skipped 
                            ? `${totalTime.toFixed(1)}s` 
                            : `${totalTime.toFixed(1)}s`;
                        
                        // Skip cells get black background, others get gradient color
                        const bgColor = entry.skipped ? '#000000' : getTimeColor(totalTime);
                        const textColor = entry.skipped ? '#ffffff' : (totalTime > 15 ? '#fff' : '#000');
                        
                        // Tooltip info
                        const tooltip = entry.skipped 
                            ? `Skipped\nThinking: ${(entry.thinkingSeconds || 0).toFixed(1)}s\nPenalty: +${entry.penaltySeconds}s\nTotal: ${totalTime.toFixed(1)}s`
                            : `Word: ${entry.word}\nTime: ${totalTime.toFixed(1)}s`;
                        
                        html += `<td style="padding:8px;text-align:center;background:${bgColor};color:${textColor};border:2px solid #fff;" title="${tooltip}">`;
                        html += `<div style="font-weight:600;font-size:0.9rem;">${word}</div>`;
                        html += `<div style="font-size:0.85rem;margin-top:2px;">${displayTime}</div>`;
                        html += `</td>`;
                    } else {
                        html += `<td style="padding:8px;background:#f3f4f6;border:2px solid #fff;"></td>`;
                    }
                }
                html += '</tr>';
            });
            
            // Stats are now in the header, so remove these rows
            
            html += '</tbody></table>';
            contentEl.innerHTML = html;
            
        } catch (error) {
            console.error('Error building comparison:', error);
            contentEl.innerHTML = '<p style="text-align:center;color:#dc2626;">Error loading comparison</p>';
        }
    }

    async function displayLeaderboard(dateStr) {
        console.log('=== displayLeaderboard called with date:', dateStr);
        currentViewingDate = dateStr; // Track the date we're viewing
        
        // Declare these at function level so they're accessible everywhere
        let userHasPlayed = false;
        let isPastDate = false;
        
        // Auto-collapse comparison table when date changes
        const comparisonContainer = document.getElementById('comparisonTableContainer');
        const compareBtn = document.getElementById('compareRunsBtn');
        if (comparisonContainer && comparisonContainer.style.display === 'block') {
            comparisonContainer.style.display = 'none';
            if (compareBtn) compareBtn.textContent = 'Compare All Runs';
        }
        
        document.getElementById('leaderboardDate').textContent = `Daily Challenge - ${dateStr}`;
        document.getElementById('leaderboardContent').innerHTML = 'Loading...';
        try {
            const scores = await loadLeaderboard(dateStr);
            if (!scores.length) {
                document.getElementById('leaderboardContent').innerHTML = '<p style="text-align:center;color:#6b7280;padding:20px;">No scores for this date</p>';
                return;
            }
            // Calculate these ONCE before the loop
            userHasPlayed = currentUser && scores.some(score => score.userId === currentUser.uid);
            isPastDate = dateStr !== getTodayString();
            
            let h = '<table style="width:100%;border-collapse:collapse;"><thead><tr style="background:#f3f4f6;">';
            h += '<th style="padding:8px;">Rank</th><th style="padding:8px;">Player</th><th style="padding:8px;text-align:right;">Time</th><th style="padding:8px;text-align:center;">Details</th></tr></thead><tbody>';
            scores.forEach((s,i)=>{
                const bg = i===0 ? '#fef3c7' : (i%2?'#fff':'#f9fafb'); // Gold for 1st, alternating grey for rest
                h+=`<tr style="background:${bg};"><td style="padding:8px;font-weight:bold;">#${i+1}</td><td style="padding:8px;">${s.userName}</td><td style="padding:8px;text-align:right;font-weight:600;">${s.totalTime.toFixed(1)}s</td>`;
                // Use the userHasPlayed value calculated before the loop
                if (userHasPlayed || isPastDate) {
                    h+=`<td style="padding:8px;text-align:center;"><button onclick="viewPlayerRun('${s.userId}','${dateStr}','${s.userName.replace(/'/g,"\'")}',${s.totalTime},${s.solved||0},${s.skipped||0})" style="padding:4px 12px;cursor:pointer;background:#3b82f6;color:white;border:1px solid #2563eb;border-radius:4px;">üëÅ View</button></td>`;
                } else {
                    h+=`<td style="padding:8px;text-align:center;"><span style="color:#9ca3af;font-size:0.85rem;">üîí Complete daily to unlock</span></td>`;
                }
                h+=`</tr>`;
            });
            h += '</tbody></table>';
            document.getElementById('leaderboardContent').innerHTML = h;
            
        } catch(e) {
            console.error('Leaderboard error:', e);
            document.getElementById('leaderboardContent').innerHTML = '<p style="text-align:center;color:#dc2626;padding:20px;">Error loading</p>';
        }
        
        // Update Compare button state (grey out if locked) - AFTER try/catch
        try {
            const compareBtn = document.getElementById('compareRunsBtn');
            console.log('=== COMPARE BUTTON STATE ===');
            console.log('currentUser:', currentUser ? currentUser.uid : 'null');
            console.log('userHasPlayed:', userHasPlayed);
            console.log('isPastDate:', isPastDate);
            
            if (userHasPlayed || isPastDate) {
                // Unlocked
                compareBtn.disabled = false;
                compareBtn.style.background = '#3b82f6';
                compareBtn.style.cursor = 'pointer';
                compareBtn.style.opacity = '1';
                compareBtn.textContent = 'Compare All Runs';
                console.log('‚Üí Button UNLOCKED');
            } else {
                // Locked
                compareBtn.disabled = true;
                compareBtn.style.background = '#9ca3af';
                compareBtn.style.cursor = 'not-allowed';
                compareBtn.style.opacity = '0.6';
                compareBtn.textContent = 'üîí Complete Daily to Compare';
                console.log('‚Üí Button LOCKED');
            }
        } catch(btnError) {
            console.error('Button state error:', btnError);
        }
    }
    // === END FIREBASE ===

    // --------- CONFIG ---------
    const TOTAL_PLATES = 10;

    const VERY_EASY_PROB = 0.40; // 0‚Äì10
    const EASY_PROB      = 0.20; // 11‚Äì34
    const MEDIUM_PROB    = 0.15; // 35‚Äì49
    const DIFFICULT_PROB = 0.15; // 50‚Äì79
    const HARD_PROB      = 0.05; // 80‚Äì88
    const VERY_HARD_PROB = 0.03; // 89‚Äì96
    const IMPOSSIBLE_PROB= 0.01; // 97‚Äì100

    const BAND_NAMES = [
        "very_easy",
        "easy",
        "medium",
        "difficult",
        "hard",
        "very_hard",
        "impossible"
    ];

    // --------- GLOBAL STATE ---------
    let WORDS = [];
    let DICTIONARY = new Set();
    let dictionaryReady = false;

    let PLATE_DIFFICULTY = null;
    let difficultyReady = false;

    let ALL_PLATES = [];
    let platesReady = false;

    let VERY_EASY_PLATES = [];
    let EASY_PLATES      = [];
    let MEDIUM_PLATES    = [];
    let DIFFICULT_PLATES = [];
    let HARD_PLATES      = [];
    let VERY_HARD_PLATES = [];
    let IMPOSSIBLE_PLATES= [];

    let usedPlates = new Set();
    let currentPlate = null;

    let gameStarted = false;
    let gameOver = false;
    let solvedCount = 0;
    let startTime = null;
    let penaltySeconds = 0;
    let timerIntervalId = null;

    let skipCount = 0;
    let plateLocked = false;

    let gameModalMode = "start";
    let hasStartedOnce = false;

    let plateStartTime = null;
    let gameHistory = [];

    let currentWordsModalMatches = [];
    let currentWordsModalPlate = null;
    let currentWordsModalSortMode = "alpha";

    // DOM refs
    const plateEl = document.getElementById("plate");
    const difficultyLabelEl = document.getElementById("difficultyLabel");
    const viableCountLabelEl = document.getElementById("viableCountLabel");
    const wordInputEl = document.getElementById("wordInput");
    const resultEl = document.getElementById("result");
    const debugEl = document.getElementById("debug");
    const timerDisplayEl = document.getElementById("timerDisplay");
    const progressDisplayEl = document.getElementById("progressDisplay");
    const historyBodyEl = document.getElementById("historyBody");
    const historyEmptyEl = document.getElementById("historyEmpty");
    const startButtonEl = document.getElementById("startButton");
    const checkButtonEl = document.getElementById("checkButton");
    const skipButtonEl = document.getElementById("skipButton");
    const chartButtonEl = document.getElementById("chartButton");

    const gameModalBackdropEl = document.getElementById("gameModalBackdrop");
    const gameModalTitleEl = document.getElementById("gameModalTitle");
    const gameModalBodyEl = document.getElementById("gameModalBody");
    const gameModalPrimaryBtnEl = document.getElementById("gameModalPrimaryBtn");
    const gameModalSecondaryBtnEl = document.getElementById("gameModalSecondaryBtn");
    const gameModalCloseBtnEl = document.getElementById("gameModalCloseBtn");

    const wordsModalBackdropEl = document.getElementById("wordsModalBackdrop");
    const wordsModalTitleEl = document.getElementById("wordsModalTitle");
    const wordsModalStatusEl = document.getElementById("wordsModalStatus");
    const wordsModalListEl = document.getElementById("wordsModalList");
    const wordsModalCloseBtnEl = document.getElementById("wordsModalCloseBtn");
    const wordsModalCloseBtnBottomEl = document.getElementById("wordsModalCloseBtnBottom");
    const wordsSortAlphaBtnEl = document.getElementById("wordsSortAlphaBtn");
    const wordsSortLengthBtnEl = document.getElementById("wordsSortLengthBtn");

    const chartModalBackdropEl = document.getElementById("chartModalBackdrop");
    const chartModalCloseBtnEl = document.getElementById("chartModalCloseBtn");
    const chartModalCloseBtnBottomEl = document.getElementById("chartModalCloseBtnBottom");
    const resultsChartCanvas = document.getElementById("resultsChart");
    let resultsChart = null;

    // --------- LOADING ---------
    async function loadDictionary() {
        try {
            const res = await fetch("words.txt");
            const text = await res.text();

            WORDS = [];
            DICTIONARY = new Set();

            for (const line of text.split(/\r?\n/)) {
                const w = line.trim().toLowerCase();
                if (!w) continue;
                if (!/^[a-z]+$/.test(w)) continue;
                if (w.length < 3) continue;

                WORDS.push(w);
                DICTIONARY.add(w.toUpperCase());
            }

            dictionaryReady = true;
            debugEl.textContent = `Loaded ${WORDS.length.toLocaleString()} words.`;

            tryBuildPlateList();
        } catch (err) {
            console.error(err);
            resultEl.textContent = "Failed to load words.txt.";
            resultEl.style.color = "red";
        }
    }

    async function loadDifficulty() {
        try {
            const res = await fetch("plate_difficulty.json?v=2");
            PLATE_DIFFICULTY = await res.json();
            difficultyReady = true;

            tryBuildPlateList();
        } catch (err) {
            console.warn("Difficulty JSON not loaded:", err);
            PLATE_DIFFICULTY = null;
            difficultyReady = false;
        } finally {
            maybeEnableStart();
        }
    }

    function tryBuildPlateList() {
        if (!dictionaryReady || !PLATE_DIFFICULTY || platesReady) return;

        const all = [];

        const ve = [];
        const e  = [];
        const m  = [];
        const d  = [];
        const h  = [];
        const vh = [];
        const im = [];

        for (const plate of Object.keys(PLATE_DIFFICULTY)) {
            const entry = PLATE_DIFFICULTY[plate];

            if (DICTIONARY.has(plate)) continue;

            let diff = (entry && typeof entry.difficulty === "number")
                ? entry.difficulty
                : 50;

            all.push(plate);

            if (diff <= 10) {
                ve.push(plate);
            } else if (diff <= 34) {
                e.push(plate);
            } else if (diff <= 49) {
                m.push(plate);
            } else if (diff <= 79) {
                d.push(plate);
            } else if (diff <= 88) {
                h.push(plate);
            } else if (diff <= 96) {
                vh.push(plate);
            } else {
                im.push(plate);
            }
        }

        ALL_PLATES        = all;
        VERY_EASY_PLATES  = ve;
        EASY_PLATES       = e;
        MEDIUM_PLATES     = m;
        DIFFICULT_PLATES  = d;
        HARD_PLATES       = h;
        VERY_HARD_PLATES  = vh;
        IMPOSSIBLE_PLATES = im;

        platesReady = true;

        debugEl.textContent +=
            ` | ${ALL_PLATES.length.toLocaleString()} plates` +
            ` (VE: ${VERY_EASY_PLATES.length}, E: ${EASY_PLATES.length}, M: ${MEDIUM_PLATES.length}, ` +
            `D: ${DIFFICULT_PLATES.length}, H: ${HARD_PLATES.length}, VH: ${VERY_HARD_PLATES.length}, IMP: ${IMPOSSIBLE_PLATES.length})`;

        maybeEnableStart();
    }

    function maybeEnableStart() {
        const ready = dictionaryReady && difficultyReady && platesReady;

        startButtonEl.disabled = !ready;

        if (gameModalMode === "start") {
            gameModalPrimaryBtnEl.disabled = !ready;
            gameModalPrimaryBtnEl.textContent = ready ? "Start Game" : "Loading...";
        }
    }

    // --------- PLATE MATCHING ---------
    function getPlateMatchIndices(plate, word) {
        plate = plate.toUpperCase();
        const upperWord = word.toUpperCase();

        let expectedPlateIndex = 0;
        const matchedIndices = [];

        for (let i = 0; i < upperWord.length; i++) {
            const ch = upperWord[i];
            const posInPlate = plate.indexOf(ch);

            if (posInPlate === -1) continue;

            if (posInPlate === expectedPlateIndex) {
                matchedIndices.push(i);
                expectedPlateIndex++;
                if (expectedPlateIndex === plate.length) {
                    return matchedIndices;
                }
            } else if (posInPlate > expectedPlateIndex) {
                return null;
            } else {
                continue;
            }
        }
        return null;
    }

    function wordMatchesPlate(plate, word) {
        return getPlateMatchIndices(plate, word) !== null;
    }

    function computeJsViableCount(plate) {
        if (!dictionaryReady || !plate) return 0;
        let count = 0;
        for (const w of WORDS) {
            if (wordMatchesPlate(plate, w)) {
                count++;
            }
        }
        return count;
    }

    // --------- PLATE SELECTION ---------
    function getBandPool(bandName) {
        switch (bandName) {
            case "very_easy":   return VERY_EASY_PLATES;
            case "easy":        return EASY_PLATES;
            case "medium":      return MEDIUM_PLATES;
            case "difficult":   return DIFFICULT_PLATES;
            case "hard":        return HARD_PLATES;
            case "very_hard":   return VERY_HARD_PLATES;
            case "impossible":  return IMPOSSIBLE_PLATES;
            default:            return [];
        }
    }

    function pickRandomPlateFromBand(bandName) {
        const poolRef = getBandPool(bandName);
        const remaining = poolRef.filter(p => !usedPlates.has(p));
        if (remaining.length === 0) return null;

        const idx = Math.floor(Math.random() * remaining.length);
        return remaining[idx];
    }

    function choosePrimaryBand() {
        const r = Math.random();
        let threshold = 0;

        threshold += VERY_EASY_PROB;
        if (r < threshold) return "very_easy";

        threshold += EASY_PROB;
        if (r < threshold) return "easy";

        threshold += MEDIUM_PROB;
        if (r < threshold) return "medium";

        threshold += DIFFICULT_PROB;
        if (r < threshold) return "difficult";

        threshold += HARD_PROB;
        if (r < threshold) return "hard";

        threshold += VERY_HARD_PROB;
        if (r < threshold) return "very_hard";

        return "impossible";
    }

    function pickRandomPlate() {
        console.log('=== pickRandomPlate called ===');
        console.log('gameMode:', gameMode, 'solvedCount:', solvedCount, 'usedPlates.size:', usedPlates ? usedPlates.size : 'null');
        if (!platesReady || !ALL_PLATES.length) {
            resultEl.textContent = "No plates available.";
            resultEl.style.color = "red";
            return;
        }
        if (gameMode==='daily' && dailyPlateSequence && dailyPlateSequence.length) {
            const idx = usedPlates.size;
            
            // Check if we've run out of plates
            if (idx>=dailyPlateSequence.length) { 
                // Ran out of plates! This is a problem.
                // Show error and end the game
                resultEl.textContent = "Ran out of plates! This shouldn't happen. Please report this bug.";
                resultEl.style.color = "red";
                endGame(); 
                return; 
            }
            
            // Check if we've SOLVED enough (this is the real end condition)
            console.log('Daily mode - solvedCount:', solvedCount, 'TOTAL_PLATES:', TOTAL_PLATES);
            if (solvedCount >= TOTAL_PLATES) {
                console.log('Ending game - solved 10!');
                endGame();
                return;
            }
            
            // Get next plate from the daily sequence
            const chosen = dailyPlateSequence[idx];
            usedPlates.add(chosen);
            currentPlate = chosen;
            plateEl.textContent = chosen;
            resultEl.textContent = "";
            plateLocked = false;
            checkButtonEl.disabled = false;
            skipButtonEl.disabled = false;
            wordInputEl.disabled = false;
            wordInputEl.readOnly = false;
            plateStartTime = performance.now();
            updateDifficultyDisplay(chosen);
            wordInputEl.value = "";
            wordInputEl.focus();
            return;
        }
        if (usedPlates.size===ALL_PLATES.length) {
            resultEl.textContent = "Seen all plates!";
            resultEl.style.color = "red";
            endGame();
            return;
        }
        const primaryBand = choosePrimaryBand();
        const startIndex = BAND_NAMES.indexOf(primaryBand);
        const bandOrder = [];
        for (let i=0;i<BAND_NAMES.length;i++) bandOrder.push(BAND_NAMES[(startIndex+i)%BAND_NAMES.length]);
        let chosen = null;
        for (const band of bandOrder) { chosen = pickRandomPlateFromBand(band); if (chosen) break; }
        if (!chosen) {
            const remaining = ALL_PLATES.filter(p=>!usedPlates.has(p));
            if (!remaining.length) { resultEl.textContent = "No unused plates."; resultEl.style.color = "red"; endGame(); return; }
            chosen = remaining[Math.floor(Math.random()*remaining.length)];
        }
        usedPlates.add(chosen);
        const jsCount = computeJsViableCount(chosen);
        if (jsCount<=0) {
            if (usedPlates.size===ALL_PLATES.length) { resultEl.textContent = "No viable words."; resultEl.style.color = "red"; endGame(); return; }
            pickRandomPlate();
            return;
        }
        currentPlate = chosen;
        plateEl.textContent = chosen;
        resultEl.textContent = "";
        plateLocked = false;
        checkButtonEl.disabled = false;
        skipButtonEl.disabled = false;
        wordInputEl.disabled = false;
        wordInputEl.readOnly = false;
        plateStartTime = performance.now();
        updateDifficultyDisplay(chosen);
        wordInputEl.value = "";
        wordInputEl.focus();
    }

    // --------- DIFFICULTY ---------
    function classifyDifficulty(score) {
        if (score >= 80) return "diff-hard";
        if (score >= 40) return "diff-med";
        return "diff-easy";
    }

    function updateDifficultyDisplay(plate) {
        if (!PLATE_DIFFICULTY || !PLATE_DIFFICULTY[plate]) {
            difficultyLabelEl.textContent = "Difficulty: ‚Äî";
            difficultyLabelEl.className = "difficulty diff-med";
        } else {
            const entry = PLATE_DIFFICULTY[plate];
            const diff = entry.difficulty;
            if (!diff || diff <= 0) {
                difficultyLabelEl.textContent = "Difficulty: ‚Äî";
                difficultyLabelEl.className = "difficulty diff-med";
            } else {
                difficultyLabelEl.textContent = `Difficulty: ${diff} / 100`;
                difficultyLabelEl.className = "difficulty " + classifyDifficulty(diff);
            }
        }

        if (!dictionaryReady || !plate) {
            viableCountLabelEl.textContent = "";
        } else {
            const jsCount = computeJsViableCount(plate);
            viableCountLabelEl.textContent = `${jsCount.toLocaleString()} viable words`;
        }
    }

    function getPlateDifficultyScore(plate) {
        if (!PLATE_DIFFICULTY || !PLATE_DIFFICULTY[plate]) return null;
        const d = PLATE_DIFFICULTY[plate].difficulty;
        if (!d || d <= 0) return null;
        return d;
    }

    // --------- TIMER / GAME STATE ---------
    function updateProgressDisplay() {
        progressDisplayEl.textContent = `Solved: ${solvedCount} / ${TOTAL_PLATES}`;
    }

    function updateSkipButtonLabel() {
        const nextPenalty = (skipCount + 1) * 5;
        skipButtonEl.textContent = `Skip +${nextPenalty}s`;
    }

    function showStartGameButton() {
        startButtonEl.style.display = "inline-block";
        startButtonEl.textContent = "Start Game";
        const ready = dictionaryReady && difficultyReady && platesReady;
        startButtonEl.disabled = !ready;
    }

    function showRestartGameButton() {
        startButtonEl.style.display = "inline-block";
        startButtonEl.textContent = "Restart game";
        startButtonEl.disabled = false;
    }

    function hideMainStartButton() {
        startButtonEl.style.display = "none";
    }

    function showChartButton() {
        if (gameHistory.length > 0) {
            chartButtonEl.style.display = "inline-block";
        }
    }

    function hideChartButton() {
        chartButtonEl.style.display = "none";
    }

    function resetGameState() {
        gameStarted = false;
        gameOver = false;
        solvedCount = 0;
        startTime = null;
        penaltySeconds = 0;
        skipCount = 0;
        plateLocked = false;
        usedPlates = new Set();
        plateStartTime = null;
        gameHistory = [];
        updateSkipButtonLabel();
        hideChartButton();

        if (timerIntervalId) clearInterval(timerIntervalId);
        timerIntervalId = null;

        plateEl.textContent = "---";
        difficultyLabelEl.textContent = "Difficulty: ‚Äî";
        difficultyLabelEl.className = "difficulty diff-med";
        viableCountLabelEl.textContent = "";
        timerDisplayEl.textContent = "Time: 0.0 s";
        updateProgressDisplay();
        resultEl.textContent = "";
        resultEl.style.color = "";
        wordInputEl.value = "";

        checkButtonEl.disabled = false;
        skipButtonEl.disabled = false;
        wordInputEl.disabled = false;
        wordInputEl.readOnly = false;

        while (historyBodyEl.firstChild) {
            historyBodyEl.removeChild(historyBodyEl.firstChild);
        }
        historyEmptyEl.style.display = "block";
    }

    function beginNewRun() {
        resetGameState();
        gameStarted = true;
        gameOver = false;
        startTime = performance.now();
        timerIntervalId = setInterval(updateTimer, 100);
        updateProgressDisplay();
        document.getElementById('dailyChallengeBtn').disabled = true;
        document.getElementById('practiceBtn').disabled = true;
        
        // Hide restart button during daily challenge
        if (gameMode === 'daily') {
            startButtonEl.style.display = 'none';
        }
        
        if (gameMode==='daily' && currentUser) {
            // Save started flag to Firebase
            database.ref(`started/${getTodayString()}/${currentUser.uid}`).set({
                userName: currentUser.displayName || currentUser.email,
                timestamp: Date.now(),
                started: true
            });
            
            window.onbeforeunload = e => {
                if (gameStarted && !gameOver && gameMode==='daily') {
                    e.preventDefault();
                    return 'Leave? Daily attempt will be used!';
                }
            };
        }
        pickRandomPlate();
    }

    function startGameFromModal() {
        const ready = dictionaryReady && difficultyReady && platesReady;
        if (!ready) {
            resultEl.textContent = "Still loading‚Ä¶";
            resultEl.style.color = "red";
            return;
        }

        if (ALL_PLATES.length === 0) {
            resultEl.textContent = "No viable plates to start the game.";
            resultEl.style.color = "red";
            return;
        }

        closeGameModal();
        hideChartButton();

        hasStartedOnce = true;
        showRestartGameButton();

        beginNewRun();
    }

    function startOrRestartFromMain() {
        const ready = dictionaryReady && difficultyReady && platesReady;
        if (!ready) {
            resultEl.textContent = "Still loading‚Ä¶";
            resultEl.style.color = "red";
            return;
        }

        if (ALL_PLATES.length === 0) {
            resultEl.textContent = "No viable plates to start the game.";
            resultEl.style.color = "red";
            return;
        }

        hasStartedOnce = true;
        showRestartGameButton();
        hideChartButton();

        beginNewRun();
    }

    function updateTimer() {
        if (!gameStarted || !startTime) return;
        const baseElapsedSec = (performance.now() - startTime) / 1000;
        const totalSec = baseElapsedSec + penaltySeconds;
        timerDisplayEl.textContent = "Time: " + totalSec.toFixed(1) + " s";
    }

    function endGame() {
        if (gameOver) return;
        gameOver = true;
        gameStarted = false;
        plateLocked = true;

        if (!startTime) return;

        const baseElapsedSec = (performance.now() - startTime) / 1000;
        const totalSec = baseElapsedSec + penaltySeconds;

        if (timerIntervalId) {
            clearInterval(timerIntervalId);
            timerIntervalId = null;
        }

        resultEl.textContent = `üèÅ Finished! Time: ${totalSec.toFixed(1)} s`;
        resultEl.style.color = "green";
        wordInputEl.blur();

        checkButtonEl.disabled = true;
        skipButtonEl.disabled = true;
        wordInputEl.disabled = true;
        wordInputEl.readOnly = true;

        openEndModal(totalSec);
        // Don't show restart for daily challenge
        if (gameMode !== 'daily') {
            showRestartGameButton();
        }
        showChartButton();
        document.getElementById('dailyChallengeBtn').disabled = false;
        document.getElementById('practiceBtn').disabled = false;
        window.onbeforeunload = null;
        if (gameMode==='daily' && currentUser) saveScore(totalSec,solvedCount,skipCount);
    }

    // --------- FLOATING LABELS & HISTORY ---------
    function createFloatingLabel(text, fromRect, toRect, extraClass) {
        const el = document.createElement("div");
        el.textContent = text;
        el.className = "float-label " + (extraClass || "");

        const startX = fromRect.left + fromRect.width / 2;
        const startY = fromRect.top + fromRect.height / 2;
        const endX = toRect.left + toRect.width / 2;
        const endY = toRect.top + toRect.height / 2;

        el.style.left = startX + "px";
        el.style.top = startY + "px";

        document.body.appendChild(el);

        requestAnimationFrame(() => {
            el.style.left = endX + "px";
            el.style.top = endY + "px";
            el.style.opacity = "0";
        });

        return el;
    }

    function addPlateCellClickHandler(plateTd, plate) {
        plateTd.classList.add("clickable-plate");
        plateTd.title = "Click to see all viable words";
        plateTd.addEventListener("click", () => {
            openWordsModal(plate);
        });
    }

    function addToHistoryWithAnimation(
        plate,
        word,
        matchIndices,
        fromRectWord,
        diffScore,
        timeLabel,
        onComplete
    ) {
        if (!plate || !word) {
            if (onComplete) onComplete();
            return;
        }

        historyEmptyEl.style.display = "none";

        const row = document.createElement("tr");
        row.style.opacity = "0";

        const plateTd = document.createElement("td");
        const wordTd = document.createElement("td");
        const timeTd = document.createElement("td");
        const diffTd = document.createElement("td");

        plateTd.textContent = plate;

        if (Array.isArray(matchIndices) && matchIndices.length > 0) {
            const set = new Set(matchIndices);
            let html = "";
            for (let i = 0; i < word.length; i++) {
                const ch = word[i];
                if (set.has(i)) {
                    html += `<span class="plate-letter-highlight">${ch}</span>`;
                } else {
                    html += ch;
                }
            }
            wordTd.innerHTML = html;
        } else {
            wordTd.textContent = word;
        }

        timeTd.textContent = timeLabel || "‚Äî";

        if (diffScore === null || diffScore <= 0) {
            diffTd.textContent = "‚Äî";
        } else {
            diffTd.textContent = diffScore;
            diffTd.className = classifyDifficulty(diffScore);
        }

        row.appendChild(plateTd);
        row.appendChild(wordTd);
        row.appendChild(timeTd);
        row.appendChild(diffTd);

        if (historyBodyEl.firstChild) {
            historyBodyEl.insertBefore(row, historyBodyEl.firstChild);
        } else {
            historyBodyEl.appendChild(row);
        }

        while (historyBodyEl.rows.length > 30) {
            historyBodyEl.removeChild(historyBodyEl.lastChild);
        }

        addPlateCellClickHandler(plateTd, plate);

        const plateFrom = plateEl.getBoundingClientRect();
        const wordFrom = fromRectWord || wordInputEl.getBoundingClientRect();
        const plateTo = plateTd.getBoundingClientRect();
        const wordTo = wordTd.getBoundingClientRect();
        const diffTo = diffTd.getBoundingClientRect();

        const plateClone = createFloatingLabel(plate, plateFrom, plateTo, "float-label-plate");
        const wordClone = createFloatingLabel(word, wordFrom, wordTo, "float-label-word");
        const diffText = (diffScore === null || diffScore <= 0) ? "‚Äî" : String(diffScore);
        const diffClone = createFloatingLabel(diffText, plateFrom, diffTo, "float-label-diff");

        if (typeof onComplete === "function") {
            onComplete();
        }

        const animDuration = 400;
        setTimeout(() => {
            row.style.opacity = "1";

            [plateClone, wordClone, diffClone].forEach(clone => {
                if (clone && clone.parentNode) clone.parentNode.removeChild(clone);
            });
        }, animDuration);
    }

    // --------- WORDS MODAL (SORTING) ---------
    function setWordsSortMode(mode) {
        currentWordsModalSortMode = mode;

        if (mode === "alpha") {
            wordsSortAlphaBtnEl.classList.add("active");
            wordsSortLengthBtnEl.classList.remove("active");
        } else {
            wordsSortAlphaBtnEl.classList.remove("active");
            wordsSortLengthBtnEl.classList.add("active");
        }

        renderWordsList(mode);
    }

    function renderWordsList(sortMode) {
        wordsModalListEl.innerHTML = "";

        const plate = currentWordsModalPlate;
        if (!plate || !currentWordsModalMatches || currentWordsModalMatches.length === 0) {
            wordsModalListEl.textContent = "(no viable words found)";
            return;
        }

        const arr = [...currentWordsModalMatches];

        if (sortMode === "alpha") {
            arr.sort((a, b) => a.localeCompare(b));
        } else {
            arr.sort((a, b) => {
                const lenDiff = a.length - b.length;
                return lenDiff !== 0 ? lenDiff : a.localeCompare(b);
            });
        }

        const frag = document.createDocumentFragment();
        for (const w of arr) {
            const line = document.createElement("div");
            line.className = "words-list-item";

            const indices = getPlateMatchIndices(plate, w) || [];
            const indexSet = new Set(indices);

            let html = "";
            for (let i = 0; i < w.length; i++) {
                const ch = w[i];
                if (indexSet.has(i)) {
                    html += `<span class="plate-letter-highlight">${ch}</span>`;
                } else {
                    html += ch;
                }
            }

            line.innerHTML = html;
            frag.appendChild(line);
        }

        wordsModalListEl.appendChild(frag);
    }

    function openWordsModal(plate) {
        if (!dictionaryReady) return;

        wordsModalTitleEl.textContent = `Plate: ${plate}`;
        wordsModalStatusEl.textContent = "Finding viable words‚Ä¶";

        currentWordsModalPlate = plate;
        currentWordsModalMatches = [];
        setWordsSortMode("alpha");

        wordsModalBackdropEl.classList.add("show");

        const matches = [];
        for (const w of WORDS) {
            if (wordMatchesPlate(plate, w)) {
                matches.push(w);
            }
        }

        matches.sort();
        currentWordsModalMatches = matches;

        const countFromScan = matches.length;
        wordsModalStatusEl.textContent =
            `${countFromScan.toLocaleString()} viable words`;

        renderWordsList(currentWordsModalSortMode);
    }

    function closeWordsModal() {
        wordsModalBackdropEl.classList.remove("show");
    }

    // --------- GAME MODAL ---------
    function openStartModal() {
        gameModalMode = "start";
        gameModalTitleEl.textContent = "Daily Challenge";
        gameModalBodyEl.innerHTML = `
            <p style="margin-bottom:1rem;">${gameMode==='daily'?'<strong>‚ö†Ô∏è One attempt per day</strong> ‚Äì do not exit or refresh mid-game.':'<strong>üéÆ Practice Mode:</strong> Unlimited random plays!'}</p>
            <p><strong>How it works:</strong></p>
            <ul>
                <li>You will see plates one after another until you correctly solve <strong>${TOTAL_PLATES}</strong>.</li>
                <li>Enter a word that contains the three plate letters <em>in order</em> (not necessarily consecutively).</li>
                <li>The first instance of each letter must come in order. If your plate is <strong>ABC</strong>, then the first A must appear before the first B or C.</li>
                <li>Example: plate <strong>PMS</strong> ‚Äì <strong>"promise"</strong> works, but <strong>"spams"</strong> does not ("spams" contains PMS, but the first S appears before the first M).</li>
                <li>You can press <strong>Skip</strong>, but it adds an increasing time penalty: +5s, then +10s, +15s, ...</li>
                <li>Click any solved plate in the table to see <strong>all</strong> viable words for that plate.</li>
            </ul>
        `;

        const ready = dictionaryReady && difficultyReady && platesReady;
        gameModalPrimaryBtnEl.disabled = !ready;
        gameModalPrimaryBtnEl.textContent = ready ? "Start Game" : "Loading...";

        gameModalSecondaryBtnEl.style.display = "none";

        gameModalBackdropEl.classList.add("show");
    }

    function openEndModal(finalTimeSec) {
        gameModalMode = "end";
        gameModalTitleEl.textContent = "Run complete!";
        gameModalBodyEl.innerHTML = `
            <p>You solved <strong>${solvedCount}</strong> plates in
            <strong>${finalTimeSec.toFixed(1)} seconds</strong> (including skip penalties).</p>
            <p>You can view a breakdown chart of each plate's time, or close this and inspect the table.</p>
            ${gameMode === 'daily' ? '<p style="margin-top:1rem; color:#92400e; background:#fef3c7; padding:8px; border-radius:4px;"><strong>Daily Challenge Complete!</strong> Come back tomorrow for a new challenge.</p>' : ''}
        `;

        // Only show "Play again" for practice mode
        if (gameMode === 'daily') {
            gameModalPrimaryBtnEl.style.display = "none";
        } else {
            gameModalPrimaryBtnEl.disabled = false;
            gameModalPrimaryBtnEl.textContent = "Play again";
            gameModalPrimaryBtnEl.style.display = "inline-block";
        }

        gameModalSecondaryBtnEl.style.display = "inline-block";
        gameModalSecondaryBtnEl.textContent = "View chart";

        gameModalBackdropEl.classList.add("show");
    }

    function closeGameModal() {
        gameModalBackdropEl.classList.remove("show");
    }

    // --------- MISMATCH EXPLANATION ---------
    function explainPlateMismatch(plate, word) {
        const plateUpper = plate.toUpperCase();
        const wordUpper = word.toUpperCase();

        const missing = [];
        for (const ch of plateUpper) {
            if (!wordUpper.includes(ch)) {
                if (!missing.includes(ch)) missing.push(ch);
            }
        }

        if (missing.length > 0) {
            const missingList = missing.join(", ");
            const letterWord = missing.length === 1 ? "letter" : "letters";
            return `‚ùå "${word}" doesn‚Äôt work for <strong>${plateUpper}</strong>.<br>` +
                   `It‚Äôs missing the ${letterWord}: <strong>${missingList}</strong>.`;
        }

        const firstOccurrences = [];
        for (const ch of plateUpper) {
            const idx = wordUpper.indexOf(ch);
            if (idx !== -1) {
                firstOccurrences.push({ ch, idx });
            }
        }

        firstOccurrences.sort((a, b) => a.idx - b.idx);
        const wordOrder = firstOccurrences.map(x => x.ch).join(" \u2192 ");
        const plateOrder = plateUpper.split("").join(" \u2192 ");
        const lettersList = plateUpper.split("").join(", ");

        return `‚ùå "${word}" doesn‚Äôt work for <strong>${plateUpper}</strong>.<br>` +
               `In your word, the first <strong>${lettersList}</strong> appear in this order: <strong>${wordOrder}</strong>.<br>` +
               `The plate <strong>${plateUpper}</strong> requires them in this order: <strong>${plateOrder}</strong>.`;
    }

    // --------- CHART ---------
    function buildChart() {
        if (!gameHistory.length) return;

        const labels = [];
        const thinkingData = [];
        const penaltyData = [];
        const cumulativeData = [];
        const platesForChart = [];

        let runningTotal = 0;

        for (const entry of gameHistory) {
            const plate = entry.plate;
            platesForChart.push(plate);

            let labelText;
            if (entry.skipped) {
                labelText = `${plate} ‚Äî skipped`;
            } else {
                labelText = `${plate} ‚Äî "${entry.word}"`;
            }
            labels.push(labelText);

            const think = entry.thinkingSeconds != null ? entry.thinkingSeconds : 0;
            const pen   = entry.penaltySeconds != null ? entry.penaltySeconds : 0;

            thinkingData.push(think);
            penaltyData.push(pen);

            runningTotal += think + pen;
            cumulativeData.push(runningTotal);
        }

        const ctx = resultsChartCanvas.getContext("2d");

        resultsChart = new Chart(ctx, {
            type: "bar",
            data: {
                labels,
                datasets: [
                    {
                        type: "bar",
                        label: "Thinking time (s)",
                        data: thinkingData,
                        backgroundColor: "rgba(59, 130, 246, 0.8)",
                        stack: "time"
                    },
                    {
                        type: "bar",
                        label: "Skip penalty (s)",
                        data: penaltyData,
                        backgroundColor: "rgba(220, 38, 38, 0.8)",
                        stack: "time"
                    },
                    {
                        type: "line",
                        label: "Cumulative time (s)",
                        data: cumulativeData,
                        borderColor: "rgba(15, 23, 42, 0.9)",
                        backgroundColor: "rgba(15, 23, 42, 0.5)",
                        tension: 0.25,
                        pointRadius: 3,
                        pointHoverRadius: 4,
                        fill: false,
                        yAxisID: "y"
                    }
                ],
                _plates: platesForChart
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: "bottom"
                    },
                    tooltip: {
                        callbacks: {
                            title: function(items) {
                                if (!items || !items.length) return "";
                                const idx = items[0].dataIndex;
                                const plate = resultsChart.config.data._plates[idx];
                                const entry = gameHistory[idx];
                                if (entry.skipped) {
                                    return `${plate} ‚Äî skipped`;
                                }
                                return `${plate} ‚Äî "${entry.word}"`;
                            },
                            label: function(context) {
                                const label = context.dataset.label || "";
                                const value = context.parsed.y;
                                return `${label}: ${value.toFixed(1)}s`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        stacked: true,
                        grid: {
                            display: false,
                            drawBorder: false
                        },
                        ticks: {
                            autoSkip: false,
                            maxRotation: 45,
                            minRotation: 0
                        }
                    },
                    y: {
                        stacked: true,
                        title: {
                            display: true,
                            text: "Seconds"
                        },
                        grid: {
                            display: false,
                            drawBorder: false
                        }
                    }
                },
                onClick: (evt, elements) => {
                    if (!elements.length) return;
                    const index = elements[0].index;
                    const plate = resultsChart.config.data._plates[index];
                    openWordsModal(plate);
                }
            }
        });
    }

    function openChartModal() {
        if (!gameHistory.length) return;

        if (resultsChart) {
            resultsChart.destroy();
            resultsChart = null;
        }

        buildChart();
        chartModalBackdropEl.classList.add("show");
    }

    function closeChartModal() {
        chartModalBackdropEl.classList.remove("show");
    }

    // --------- ACTIONS ---------
    function checkWord() {
        const rawWord = wordInputEl.value.trim();
        if (!rawWord) return;

        if (!gameStarted) {
            resultEl.textContent = "Press Start to begin the game.";
            resultEl.style.color = "red";
            return;
        }
        if (gameOver) {
            resultEl.textContent = "Game over. Press Restart game to play again.";
            resultEl.style.color = "red";
            return;
        }
        if (plateLocked) {
            return;
        }

        if (!DICTIONARY.has(rawWord.toUpperCase())) {
            resultEl.textContent = `‚ùå "${rawWord}" is not in the dictionary.`;
            resultEl.style.color = "red";
            return;
        }

        const matchIndices = getPlateMatchIndices(currentPlate, rawWord);
        if (!matchIndices) {
            const html = explainPlateMismatch(currentPlate, rawWord);
            resultEl.innerHTML = html;
            resultEl.style.color = "red";
            return;
        }

        plateLocked = true;
        checkButtonEl.disabled = true;
        skipButtonEl.disabled = true;
        wordInputEl.readOnly = true;

        solvedCount++;
        updateProgressDisplay();

        resultEl.textContent = `‚úÖ "${rawWord}" matches ${currentPlate}.`;
        resultEl.style.color = "green";

        const plate = currentPlate;
        const word = rawWord.toLowerCase();
        const diffScore = getPlateDifficultyScore(plate);

        let timeLabel = "‚Äî";
        let thinkingSeconds = 0;
        if (plateStartTime != null) {
            thinkingSeconds = (performance.now() - plateStartTime) / 1000;
            timeLabel = `${thinkingSeconds.toFixed(1)}s`;
        }

        gameHistory.push({
            plate,
            word,
            skipped: false,
            thinkingSeconds,
            penaltySeconds: 0
        });

        addToHistoryWithAnimation(
            plate,
            word,
            matchIndices,
            null,
            diffScore,
            timeLabel,
            () => {
                if (solvedCount >= TOTAL_PLATES) {
                    endGame();
                } else {
                    pickRandomPlate();
                }
            }
        );
    }

    function handleSkip() {
        console.log('=== SKIP CLICKED ===');
        console.log('gameStarted:', gameStarted, 'gameOver:', gameOver, 'solvedCount:', solvedCount);
        if (!gameStarted) {
            resultEl.textContent = "Press Start to begin the game.";
            resultEl.style.color = "red";
            return;
        }
        if (gameOver) {
            resultEl.textContent = "Game over. Press Restart game to play again.";
            resultEl.style.color = "red";
            return;
        }
        if (!currentPlate) return;
        if (plateLocked) {
            return;
        }

        plateLocked = true;
        checkButtonEl.disabled = true;
        skipButtonEl.disabled = true;
        wordInputEl.readOnly = true;

        skipCount += 1;
        const added = skipCount * 5;
        penaltySeconds += added;

        resultEl.textContent = `‚è© Skipped ${currentPlate}. +${added}s penalty.`;
        resultEl.style.color = "orange";

        const plate = currentPlate;
        const penaltyLabel = `+${added}s (skipped)`;
        const diffScore = getPlateDifficultyScore(plate);
        const skipRect = skipButtonEl.getBoundingClientRect();

        let timeLabel = "‚Äî";
        let thinkingSeconds = 0;
        if (plateStartTime != null) {
            thinkingSeconds = (performance.now() - plateStartTime) / 1000;
            timeLabel = `${thinkingSeconds.toFixed(1)}s (+${added}s)`;
        }

        gameHistory.push({
            plate,
            word: "skipped",
            skipped: true,
            thinkingSeconds,
            penaltySeconds: added
        });

        addToHistoryWithAnimation(
            plate,
            penaltyLabel,
            null,
            skipRect,
            diffScore,
            timeLabel,
            () => {
                console.log('After skip - solvedCount:', solvedCount, 'skipCount:', skipCount);
                updateSkipButtonLabel();
                pickRandomPlate();
            }
        );
    }

    // --------- INIT ---------
    startButtonEl.disabled = true;
    hideMainStartButton();
    hideChartButton();
    updateSkipButtonLabel();

    startButtonEl.addEventListener("click", startOrRestartFromMain);
    checkButtonEl.addEventListener("click", checkWord);
    skipButtonEl.addEventListener("click", handleSkip);
    chartButtonEl.addEventListener("click", openChartModal);

    wordInputEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
            checkWord();
        }
    });

    wordsModalCloseBtnEl.addEventListener("click", closeWordsModal);
    wordsModalCloseBtnBottomEl.addEventListener("click", closeWordsModal);
    wordsModalBackdropEl.addEventListener("click", (e) => {
        if (e.target === wordsModalBackdropEl) {
            closeWordsModal();
        }
    });

    wordsSortAlphaBtnEl.addEventListener("click", () => {
        setWordsSortMode("alpha");
    });

    wordsSortLengthBtnEl.addEventListener("click", () => {
        setWordsSortMode("length");
    });

    gameModalPrimaryBtnEl.addEventListener("click", () => {
        if (gameModalMode === "start") {
            startGameFromModal();
        } else if (gameModalMode === "end") {
            startGameFromModal();
        }
    });

    gameModalSecondaryBtnEl.addEventListener("click", () => {
        closeGameModal();
        openChartModal();
    });

    gameModalCloseBtnEl.addEventListener("click", () => {
        closeGameModal();
        if (!gameStarted && !gameOver && gameModalMode === "start") {
            showStartGameButton();
        }
    });

    gameModalBackdropEl.addEventListener("click", (e) => {
        if (e.target === gameModalBackdropEl) {
            closeGameModal();
            if (!gameStarted && !gameOver && gameModalMode === "start") {
                showStartGameButton();
            }
        }
    });

    chartModalCloseBtnEl.addEventListener("click", closeChartModal);
    chartModalCloseBtnBottomEl.addEventListener("click", closeChartModal);
    chartModalBackdropEl.addEventListener("click", (e) => {
        if (e.target === chartModalBackdropEl) {
            closeChartModal();
        }
    });







    // Highlight plate letters in a word
    function highlightPlateInWord(plate, word) {
        const upperWord = word.toUpperCase();
        const upperPlate = plate.toUpperCase();
        let result = '';
        let plateIndex = 0;
        
        for (let i = 0; i < word.length; i++) {
            if (plateIndex < upperPlate.length && upperWord[i] === upperPlate[plateIndex]) {
                result += `<span style="color:#16a34a;font-weight:700;">${word[i]}</span>`;
                plateIndex++;
            } else {
                result += `<span style="color:#000000;">${word[i]}</span>`;
            }
        }
        
        return result;
    }
    // View player run details
    async function viewPlayerRun(userId, dateString, userName, totalTime, solved, skipped) {
        const backdrop = document.getElementById('runDetailsModalBackdrop');
        const titleEl = document.getElementById('runDetailsModalTitle');
        const contentEl = document.getElementById('runDetailsContent');
        
        titleEl.textContent = `${userName}'s Run`;
        contentEl.innerHTML = 'Loading...';
        backdrop.classList.add('show');
        
        try {
            const snapshot = await database.ref(`scores/${dateString}/${userId}`).once('value');
            const data = snapshot.val();
            
            if (!data || !data.history || data.history.length === 0) {
                contentEl.innerHTML = `
                    <p style="text-align:center;color:#6b7280;padding:20px;">
                        <strong>Summary Stats:</strong><br>
                        Total Time: ${totalTime.toFixed(1)}s<br>
                        Solved: ${solved}<br>
                        Skipped: ${skipped}<br><br>
                        <em>Detailed breakdown not available (run completed before this feature was added)</em>
                    </p>`;
                return;
            }
            
            let html = `<p style="margin-bottom:16px;"><strong>Total Time:</strong> ${totalTime.toFixed(1)}s | <strong>Solved:</strong> ${data.solved} | <strong>Skipped:</strong> ${data.skipped}</p>`;
            html += '<table style="width:100%;border-collapse:collapse;"><thead><tr style="background:#f3f4f6;">';
            html += '<th style="padding:8px;text-align:left;">Plate</th>';
            html += '<th style="padding:8px;text-align:left;">Word / Penalty</th>';
            html += '<th style="padding:8px;text-align:right;">Time</th></tr></thead><tbody>';
            
            data.history.forEach((entry, idx) => {
                const bg = idx % 2 === 0 ? '#f9fafb' : '#fff';
                html += `<tr style="background:${bg};">`;
                html += `<td style="padding:8px;font-weight:600;">${entry.plate}</td>`;
                
                if (entry.skipped) {
                    html += `<td style="padding:8px;color:#f59e0b;">+${entry.penaltySeconds}s (skipped)</td>`;
                    html += `<td style="padding:8px;text-align:right;">${entry.thinkingSeconds.toFixed(1)}s (+${entry.penaltySeconds}s)</td>`;
                } else {
                    // Highlight the plate letters in the word
                    const highlightedWord = highlightPlateInWord(entry.plate, entry.word);
                    html += `<td style="padding:8px;color:#16a34a;">${highlightedWord}</td>`;
                    html += `<td style="padding:8px;text-align:right;">${entry.thinkingSeconds.toFixed(1)}s</td>`;
                }
                
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            contentEl.innerHTML = html;
            
        } catch (error) {
            console.error('Error loading run details:', error);
            contentEl.innerHTML = '<p style="text-align:center;color:#dc2626;">Failed to load run details</p>';
        }
    }
    
    window.viewPlayerRun = viewPlayerRun; // Make it globally accessible for onclick

    // Global function to close run details modal
    function closeRunDetailsModal() {
        const backdrop = document.getElementById('runDetailsModalBackdrop');
        if (backdrop) {
            backdrop.classList.remove('show');
        }
    }
    window.closeRunDetailsModal = closeRunDetailsModal;

    // Global function for Load button
    function loadSelectedDate() {
        const v = document.getElementById('leaderboardDatePicker').value;
        if (v) {
            console.log('Loading date:', v);
            displayLeaderboard(v);
        } else {
            console.log('No date selected');
        }
    }
    window.loadSelectedDate = loadSelectedDate;


    // Global function for Today button (backup)
    function loadTodayScores() {
        console.log('=== TODAY BUTTON CLICKED ===');
        const t = getTodayString();
        const picker = document.getElementById('leaderboardDatePicker');
        if (picker) picker.value = t;
        displayLeaderboard(t);
    }
    window.loadTodayScores = loadTodayScores;



    // === FIREBASE EVENT HANDLERS ===
    // Wait for page to fully load before attaching event listeners
    window.addEventListener('DOMContentLoaded', function() {
    document.getElementById('dailyChallengeBtn').addEventListener('click', async () => {
        console.log('Daily Challenge clicked!');
        // Check if game data is loaded
        if (!platesReady || !dictionaryReady || !ALL_PLATES || ALL_PLATES.length === 0) {
            alert('Game data is still loading... Please wait a moment and try again.');
            return;
        }
        // Sign in if needed
        if (!currentUser && !await signInWithGoogle()) return;
        // Check if already played today
        if (await checkIfPlayedToday()) { 
            alert('You already played today\'s challenge! Come back tomorrow, or try Practice Mode.'); 
            return; 
        }
        // Generate daily plates
        gameMode = 'daily';
        dailyPlateSequence = generateDailyPlates(getTodayString());
        if (!dailyPlateSequence || !dailyPlateSequence.length) { 
            alert('Failed to generate daily plates. Please try again.'); 
            return; 
        }
        // Show mode indicator
        const mi = document.getElementById('modeIndicator');
        mi.style.display = 'block';
        mi.textContent = 'üèÜ DAILY CHALLENGE MODE';
        mi.style.background = '#fef3c7';
        mi.style.color = '#92400e';
        // Start the game
        openStartModal();
    });
    document.getElementById('practiceBtn').addEventListener('click', () => {
        console.log('Practice clicked!');
        gameMode = 'practice';
        dailyPlateSequence = null;
        
        // Update button styles
        document.getElementById('practiceBtn').style.background = '#dbeafe';
        document.getElementById('practiceBtn').style.border = '2px solid #3b82f6';
        document.getElementById('dailyChallengeBtn').style.background = '';
        document.getElementById('dailyChallengeBtn').style.border = '';
        
        // Update mode indicator
        const mi = document.getElementById('modeIndicator');
        mi.style.display = 'block';
        mi.textContent = 'üéÆ PRACTICE MODE';
        mi.style.background = '#e0e7ff';
        mi.style.color = '#3730a3';
        mi.style.border = 'none';
        mi.style.textAlign = 'left';
        openStartModal();
    });
    document.getElementById('leaderboardBtn').addEventListener('click', () => {
        console.log('Leaderboard clicked!');
        const t = getTodayString();
        document.getElementById('leaderboardDatePicker').value = t;
        document.getElementById('leaderboardDatePicker').max = t;
        displayLeaderboard(t);
        document.getElementById('leaderboardContent').scrollIntoView({behavior:'smooth',block:'nearest'});
    });
    document.getElementById('loadLeaderboardBtn').addEventListener('click', () => {
        const v = document.getElementById('leaderboardDatePicker').value;
        if (v) displayLeaderboard(v);
    });
    document.getElementById('todayLeaderboardBtn').addEventListener('click', () => {
        const t = getTodayString();
        document.getElementById('leaderboardDatePicker').value = t;
        displayLeaderboard(t);
    });
    document.getElementById('signOutBtn').addEventListener('click', () => auth.signOut());
    });
    // === END FIREBASE HANDLERS ===

    loadDictionary();
    loadDifficulty();
</script>

<script>
// Auto-load today's leaderboard when page is fully loaded
window.addEventListener('load', function() {
    setTimeout(function() {
        try {
            const today = getTodayString();
            const datePicker = document.getElementById('leaderboardDatePicker');
            if (datePicker) {
                datePicker.value = today;
                datePicker.max = today;
                displayLeaderboard(today);
                console.log('Auto-loaded leaderboard for:', today);
            }
        } catch (error) {
            console.error('Error auto-loading leaderboard:', error);
        }
    }, 500); // Wait 2 seconds for Firebase to connect
});
</script>




<!-- Player Run Details Modal -->
<div id="runDetailsModalBackdrop" class="modal-backdrop" onclick="if(event.target.id==='runDetailsModalBackdrop')closeRunDetailsModal()">
    <div class="modal">
        <div class="modal-header">
            <div class="modal-title" id="runDetailsModalTitle">Player's Run</div>
            <button class="modal-close-btn" onclick="closeRunDetailsModal()">&times;</button>
        </div>
        <div class="modal-body">
            <div id="runDetailsContent"></div>
        </div>
        <div class="modal-footer">
            <button onclick="closeRunDetailsModal()">Close</button>
        </div>
    </div>
</div>

<div style="margin-top:40px;padding:20px;background:#f9fafb;border-radius:8px;">
    <h2 style="margin-top:0;">üèÜ Daily Leaderboard</h2>
    <div style="margin-bottom:20px;display:flex;gap:10px;align-items:center;flex-wrap:wrap;">
        <label for="leaderboardDatePicker" style="font-weight:600;">Date:</label>
        <input type="date" id="leaderboardDatePicker" style="padding:8px;border:1px solid #d1d5db;border-radius:4px;">
        <button id="loadLeaderboardBtn" onclick="loadSelectedDate()" style="padding:8px 16px;cursor:pointer;">Load</button>
        <button id="todayLeaderboardBtn" onclick="loadTodayScores()" style="padding:8px 16px;cursor:pointer;">Today</button>
    </div>
    <div id="leaderboardDate" style="text-align:center;margin-bottom:16px;font-size:1.1rem;color:#6b7280;font-weight:600;"></div>
    <div id="leaderboardContent" style="background:white;padding:20px;border-radius:8px;min-height:200px;max-height:600px;overflow-y:auto;">
        <p style="text-align:center;color:#6b7280;">Click a button above to view scores</p>
    </div>
    
    <!-- Compare Runs Button -->
    <div id="compareRunsContainer" style="margin-top:20px;text-align:center;display:block;">
        <button id="compareRunsBtn" onclick="toggleCompareTable()" style="padding:12px 24px;font-size:1rem;background:#3b82f6;color:white;border:none;border-radius:6px;cursor:pointer;font-weight:600;">
            Compare All Runs
        </button>
    </div>
    
    <!-- Comparison Table -->
    <div id="comparisonTableContainer" style="margin-top:20px;background:white;padding:20px;border-radius:8px;display:none;overflow-x:auto;">
        <h3 style="margin-top:0;">Run Comparison</h3>
        <div id="comparisonTable"></div>
    </div>
</div>

</body>
</html>
