<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>License Plate Game ‚Äì Time Trial</title>
    <style>

        @font-face {
            font-family: "RoadgeekUS";
            src: url("fonts/Roadgeek.woff2") format("woff2");
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            max-width: 1100px;
            margin: 40px auto;
            padding: 0 16px 40px;
            line-height: 1.5;
        }

        h1 {
            margin-top: 0;
            margin-bottom: 0.5rem;
        }

        .layout {
            display: flex;
            align-items: flex-start;
            gap: 32px;
        }

        .left-panel { flex: 0 0 55%; }
        .right-panel { flex: 1; }

        .car-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
            max-width: 360px;
            height: 380px;
            overflow: hidden;
        }

        .car-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .plate-text {
            position: absolute;
            left: 52%;
            bottom: 26%;
            transform: translateX(-50%);
            font-family: "RoadgeekUS", sans-serif;
            font-size: 3rem;
            letter-spacing: 0.33em;
            color: #222;
            font-weight: 400;
            text-transform: uppercase;
            text-shadow: 0 1px 2px rgba(0,0,0,0.35);
            pointer-events: none;
        }

        .difficulty {
            margin-top: 8px;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .diff-easy { color: #16a34a; }
        .diff-med  { color: #d97706; }
        .diff-hard { color: #dc2626; }

        .controls {
            margin: 24px 0 12px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }

        .controls input[type="text"] {
            flex: 1;
            min-width: 180px;
            padding: 8px;
            font-size: 1rem;
        }

        button {
            padding: 8px 14px;
            font-size: 0.95rem;
            cursor: pointer;
        }

        button:disabled {
            opacity: 0.6;
            cursor: default;
        }

        #startButton {
            display: none;
        }

        #chartButton {
            margin-top: 8px;
            padding: 6px 12px;
            font-size: 0.85rem;
            display: none;
        }

        #result {
            margin-top: 10px;
            font-weight: 600;
        }

        #debug {
            margin-top: 6px;
            font-size: 0.85rem;
            color: #6b7280;
        }

        #timerRow {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin-bottom: 8px;
            font-weight: 600;
            font-size: 0.95rem;
        }

        #timerDisplay { color: #111827; }
        #progressDisplay { color: #374151; }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-size: 0.95rem;
        }

        th, td {
            border-bottom: 1px solid #e5e7eb;
            padding: 6px 8px;
            text-align: left;
        }

        th {
            background-color: #f3f4f6;
            font-weight: 600;
        }

        tr:nth-child(even) td {
            background-color: #f9fafb;
        }

        .history-empty {
            font-size: 0.85rem;
            color: #6b7280;
            margin-top: 4px;
        }

        .plate-letter-highlight {
            color: #16a34a;
            font-weight: 700;
        }

        .clickable-plate {
            cursor: pointer;
            text-decoration: underline;
            text-decoration-style: dotted;
        }

        .clickable-plate:hover {
            text-decoration-style: solid;
        }

        /* Floating labels */
        .float-label {
            position: fixed;
            transform: translate(-50%, -50%);
            z-index: 999;
            pointer-events: none;
            background: rgba(255,255,255,0.95);
            padding: 3px 6px;
            border-radius: 4px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.25);
            opacity: 1;
            transition:
                top 0.4s ease-out,
                left 0.4s ease-out,
                opacity 0.4s ease-out;
            white-space: nowrap;
            font-size: 0.9rem;
        }

        .float-label-plate {
            font-size: 1.1rem;
            letter-spacing: 0.3em;
            font-weight: 600;
        }

        .float-label-word {
            font-weight: 600;
        }

        .float-label-diff {
            font-size: 0.8rem;
            font-weight: 700;
        }

        /* Modal base styles */
        .modal-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.45);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 900;
        }

        /* Explicit stacking order so words > chart > game */
        #gameModalBackdrop {
            z-index: 900;
        }
        #chartModalBackdrop {
            z-index: 950;
        }
        #wordsModalBackdrop {
            z-index: 1000;
        }

        .modal-backdrop.show {
            display: flex;
        }

        .modal {
            background: #ffffff;
            border-radius: 8px;
            max-width: 700px;
            width: 100%;
            max-height: 80vh;
            box-shadow: 0 10px 30px rgba(0,0,0,0.25);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .modal-header {
            padding: 10px 14px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #f3f4f6;
        }

        .modal-title {
            font-weight: 600;
            font-size: 1rem;
        }

        .modal-body {
            padding: 10px 14px;
            overflow-y: auto;
            font-size: 0.95rem;
        }

        .modal-footer {
            padding: 8px 14px;
            border-top: 1px solid #e5e7eb;
            text-align: right;
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }

        .modal-close-btn {
            border: none;
            background: transparent;
            font-size: 1.1rem;
            cursor: pointer;
        }

        .words-list {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            white-space: normal;
        }

        .words-list-item {
            display: block;
            margin-bottom: 2px;
        }

        .words-sort-controls {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 6px;
            font-size: 0.85rem;
        }

        .words-sort-label {
            color: #6b7280;
        }

        .words-sort-button {
            padding: 2px 8px;
            font-size: 0.8rem;
            border-radius: 9999px;
            border: 1px solid #d1d5db;
            background: #f9fafb;
            cursor: pointer;
        }

        .words-sort-button.active {
            background: #111827;
            color: #ffffff;
            border-color: #111827;
        }

        /* Chart container */
        #resultsChart {
            width: 100%;
            min-height: 320px;
        }

        @media (max-width: 800px) {
            .layout {
                flex-direction: column;
            }
        }
    </style>

    <!-- Chart.js for the end-of-game bar chart -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>

<h1>The License Plate Game v4</h1>

<div class="layout">
    <!-- LEFT PANEL -->
    <div class="left-panel">
        <p>
            Solve <strong>10 plates</strong> as fast as you can.<br>
            The plate letters must appear in your word in order (not necessarily consecutively).
        </p>

        <div class="car-wrapper">
            <img src="car.png" alt="Car with license plate" class="car-image">
            <div id="plate" class="plate-text">---</div>
        </div>

        <div id="difficultyLabel" class="difficulty diff-med">
            Difficulty: ‚Äî
        </div>
        <div id="viableCountLabel" style="color:#6b7280; font-size:0.9rem; margin-top:2px;">
        </div>

        <div class="controls">
            <button id="startButton">Play again</button>
            <input id="wordInput" type="text" placeholder="Type a word" autocomplete="off">
            <button id="checkButton">Check</button>
            <button id="skipButton">Skip +5s</button>
        </div>

        <div id="result"></div>
        <button id="chartButton">View run chart</button>

        <div id="debug"></div>
    </div>

    <!-- RIGHT PANEL -->
    <div class="right-panel">
        <div id="timerRow">
            <span id="timerDisplay">Time: 0.0 s</span>
            <span id="progressDisplay">Solved: 0 / 10</span>
        </div>

        <h2>Solved Plates</h2>
        <table>
            <thead>
            <tr>
                <th>Plate</th>
                <th>Word / Penalty</th>
                <th>Time</th>
                <th>Difficulty</th>
            </tr>
            </thead>
            <tbody id="historyBody"></tbody>
        </table>
        <div id="historyEmpty" class="history-empty">
            No solved plates yet.
        </div>
    </div>
</div>

<!-- GAME START / END MODAL -->
<div id="gameModalBackdrop" class="modal-backdrop">
    <div class="modal">
        <div class="modal-header">
            <div class="modal-title" id="gameModalTitle">License Plate Game</div>
            <button class="modal-close-btn" id="gameModalCloseBtn" aria-label="Close">&times;</button>
        </div>
        <div class="modal-body" id="gameModalBody">
            <!-- Filled dynamically -->
        </div>
        <div class="modal-footer">
            <button id="gameModalSecondaryBtn" style="display:none;">View chart</button>
            <button id="gameModalPrimaryBtn">Start Game</button>
        </div>
    </div>
</div>

<!-- MODAL: Viable words for a plate -->
<div id="wordsModalBackdrop" class="modal-backdrop">
    <div class="modal">
        <div class="modal-header">
            <div class="modal-title" id="wordsModalTitle">Plate: ---</div>
            <button class="modal-close-btn" id="wordsModalCloseBtn" aria-label="Close">&times;</button>
        </div>
        <div class="modal-body">
            <div id="wordsModalStatus" style="margin-bottom:6px; color:#6b7280; font-size:0.9rem;">
                Loading...
            </div>
            <div id="wordsModalSortControls" class="words-sort-controls">
                <span class="words-sort-label">Sort:</span>
                <button id="wordsSortAlphaBtn" class="words-sort-button active">A‚ÄìZ</button>
                <button id="wordsSortLengthBtn" class="words-sort-button">Shortest ‚Üí longest</button>
            </div>
            <div id="wordsModalList" class="words-list"></div>
        </div>
        <div class="modal-footer">
            <button id="wordsModalCloseBtnBottom">Close</button>
        </div>
    </div>
</div>

<!-- MODAL: End-of-game chart -->
<div id="chartModalBackdrop" class="modal-backdrop">
    <div class="modal">
        <div class="modal-header">
            <div class="modal-title">Run breakdown</div>
            <button class="modal-close-btn" id="chartModalCloseBtn" aria-label="Close">&times;</button>
        </div>
        <div class="modal-body">
            <canvas id="resultsChart"></canvas>
            <div style="margin-top:8px; font-size:0.85rem; color:#6b7280;">
                Blue = thinking time, red = skip penalty. Click a bar to see all viable words for that plate.
            </div>
        </div>
        <div class="modal-footer">
            <button id="chartModalCloseBtnBottom">Close</button>
        </div>
    </div>
</div>

<script>
    // --------- CONFIG ---------
    const TOTAL_PLATES = 10;

    // Difficulty bucket probabilities
    const VERY_EASY_PROB = 0.40; // 0‚Äì10
    const EASY_PROB      = 0.20; // 11‚Äì34
    const MEDIUM_PROB    = 0.15; // 35‚Äì49
    const DIFFICULT_PROB = 0.15; // 50‚Äì79
    const HARD_PROB      = 0.05; // 80‚Äì88
    const VERY_HARD_PROB = 0.03; // 89‚Äì96
    const IMPOSSIBLE_PROB= 0.01; // 97‚Äì100

    const BAND_NAMES = [
        "very_easy",
        "easy",
        "medium",
        "difficult",
        "hard",
        "very_hard",
        "impossible"
    ];

    // --------- GLOBAL STATE ---------
    let WORDS = [];
    let DICTIONARY = new Set();
    let dictionaryReady = false;

    let PLATE_DIFFICULTY = null;
    let difficultyReady = false;

    // All viable plates according to rules
    let ALL_PLATES = [];
    let platesReady = false;

    // Difficulty-banded lists
    let VERY_EASY_PLATES = [];
    let EASY_PLATES      = [];
    let MEDIUM_PLATES    = [];
    let DIFFICULT_PLATES = [];
    let HARD_PLATES      = [];
    let VERY_HARD_PLATES = [];
    let IMPOSSIBLE_PLATES= [];

    // Plates already used in this run (no repeats)
    let usedPlates = new Set();

    let currentPlate = null;

    let gameStarted = false;
    let gameOver = false;
    let solvedCount = 0;
    let startTime = null;
    let penaltySeconds = 0;
    let timerIntervalId = null;

    let skipCount = 0;
    let plateLocked = false;

    let gameModalMode = "start";

    // per-plate timing
    let plateStartTime = null;

    // per-run history for chart
    let gameHistory = [];

    // words modal sorting state
    let currentWordsModalMatches = [];
    let currentWordsModalPlate = null;
    let currentWordsModalSortMode = "alpha";

    // DOM refs
    const plateEl = document.getElementById("plate");
    const difficultyLabelEl = document.getElementById("difficultyLabel");
    const viableCountLabelEl = document.getElementById("viableCountLabel");
    const wordInputEl = document.getElementById("wordInput");
    const resultEl = document.getElementById("result");
    const debugEl = document.getElementById("debug");
    const timerDisplayEl = document.getElementById("timerDisplay");
    const progressDisplayEl = document.getElementById("progressDisplay");
    const historyBodyEl = document.getElementById("historyBody");
    const historyEmptyEl = document.getElementById("historyEmpty");
    const startButtonEl = document.getElementById("startButton");
    const checkButtonEl = document.getElementById("checkButton");
    const skipButtonEl = document.getElementById("skipButton");
    const chartButtonEl = document.getElementById("chartButton");

    // Game modal refs
    const gameModalBackdropEl = document.getElementById("gameModalBackdrop");
    const gameModalTitleEl = document.getElementById("gameModalTitle");
    const gameModalBodyEl = document.getElementById("gameModalBody");
    const gameModalPrimaryBtnEl = document.getElementById("gameModalPrimaryBtn");
    const gameModalSecondaryBtnEl = document.getElementById("gameModalSecondaryBtn");
    const gameModalCloseBtnEl = document.getElementById("gameModalCloseBtn");

    // Words modal refs
    const wordsModalBackdropEl = document.getElementById("wordsModalBackdrop");
    const wordsModalTitleEl = document.getElementById("wordsModalTitle");
    const wordsModalStatusEl = document.getElementById("wordsModalStatus");
    const wordsModalListEl = document.getElementById("wordsModalList");
    const wordsModalCloseBtnEl = document.getElementById("wordsModalCloseBtn");
    const wordsModalCloseBtnBottomEl = document.getElementById("wordsModalCloseBtnBottom");
    const wordsModalSortControlsEl = document.getElementById("wordsModalSortControls");
    const wordsSortAlphaBtnEl = document.getElementById("wordsSortAlphaBtn");
    const wordsSortLengthBtnEl = document.getElementById("wordsSortLengthBtn");

    // Chart modal refs
    const chartModalBackdropEl = document.getElementById("chartModalBackdrop");
    const chartModalCloseBtnEl = document.getElementById("chartModalCloseBtn");
    const chartModalCloseBtnBottomEl = document.getElementById("chartModalCloseBtnBottom");
    const resultsChartCanvas = document.getElementById("resultsChart");
    let resultsChart = null;

    // --------- LOADING ---------
    async function loadDictionary() {
        try {
            const res = await fetch("words.txt");
            const text = await res.text();

            WORDS = [];
            DICTIONARY = new Set();

            for (const line of text.split(/\r?\n/)) {
                const w = line.trim().toLowerCase();
                if (!w) continue;
                if (!/^[a-z]+$/.test(w)) continue;
                if (w.length < 3) continue;

                WORDS.push(w);
                DICTIONARY.add(w.toUpperCase());
            }

            dictionaryReady = true;
            debugEl.textContent = `Loaded ${WORDS.length.toLocaleString()} words.`;

            tryBuildPlateList();
        } catch (err) {
            console.error(err);
            resultEl.textContent = "Failed to load words.txt.";
            resultEl.style.color = "red";
        }
    }

    async function loadDifficulty() {
        try {
            const res = await fetch("plate_difficulty.json?v=2");
            PLATE_DIFFICULTY = await res.json();
            difficultyReady = true;

            tryBuildPlateList();
        } catch (err) {
            console.warn("Difficulty JSON not loaded:", err);
            PLATE_DIFFICULTY = null;
            difficultyReady = false;
        } finally {
            maybeEnableStart();
        }
    }

    // Build ALL_PLATES + difficulty bands once both dictionary + difficulty are ready
    function tryBuildPlateList() {
        if (!dictionaryReady || !PLATE_DIFFICULTY || platesReady) return;

        const all = [];

        const ve = [];
        const e  = [];
        const m  = [];
        const d  = [];
        const h  = [];
        const vh = [];
        const im = [];

        for (const plate of Object.keys(PLATE_DIFFICULTY)) {
            const entry = PLATE_DIFFICULTY[plate];

            // Exclude if plate itself is a word in the dictionary
            if (DICTIONARY.has(plate)) continue;

            // Always recompute viable count from the *current* JS dictionary
            const viableCountJs = computeJsViableCount(plate);
            if (viableCountJs <= 0) {
                // No viable words in the current words.txt; never include this plate in gameplay
                continue;
            }

            // Difficulty score still comes from JSON
            let diff = (entry && typeof entry.difficulty === "number")
                ? entry.difficulty
                : 50;

            all.push(plate);

            if (diff <= 10) {
                ve.push(plate);
            } else if (diff <= 34) {
                e.push(plate);
            } else if (diff <= 49) {
                m.push(plate);
            } else if (diff <= 79) {
                d.push(plate);
            } else if (diff <= 88) {
                h.push(plate);
            } else if (diff <= 96) {
                vh.push(plate);
            } else {
                im.push(plate);
            }
        }

        ALL_PLATES        = all;
        VERY_EASY_PLATES  = ve;
        EASY_PLATES       = e;
        MEDIUM_PLATES     = m;
        DIFFICULT_PLATES  = d;
        HARD_PLATES       = h;
        VERY_HARD_PLATES  = vh;
        IMPOSSIBLE_PLATES = im;

        platesReady = true;

        debugEl.textContent +=
            ` | ${ALL_PLATES.length.toLocaleString()} viable plates` +
            ` (VE: ${VERY_EASY_PLATES.length}, E: ${EASY_PLATES.length}, M: ${MEDIUM_PLATES.length}, ` +
            `D: ${DIFFICULT_PLATES.length}, H: ${HARD_PLATES.length}, VH: ${VERY_HARD_PLATES.length}, IMP: ${IMPOSSIBLE_PLATES.length})`;

        maybeEnableStart();
    }

    function maybeEnableStart() {
        const ready = dictionaryReady && difficultyReady && platesReady;

        startButtonEl.disabled = !ready;

        if (gameModalMode === "start") {
            gameModalPrimaryBtnEl.disabled = !ready;
            gameModalPrimaryBtnEl.textContent = ready ? "Start Game" : "Loading...";
        }
    }

    // --------- PLATE MATCHING ---------
    function getPlateMatchIndices(plate, word) {
        plate = plate.toUpperCase();
        const upperWord = word.toUpperCase();

        let expectedPlateIndex = 0;
        const matchedIndices = [];

        for (let i = 0; i < upperWord.length; i++) {
            const ch = upperWord[i];
            const posInPlate = plate.indexOf(ch);

            if (posInPlate === -1) continue;

            if (posInPlate === expectedPlateIndex) {
                matchedIndices.push(i);
                expectedPlateIndex++;
                if (expectedPlateIndex === plate.length) {
                    return matchedIndices;
                }
            } else if (posInPlate > expectedPlateIndex) {
                return null;
            } else {
                continue;
            }
        }
        return null;
    }

    function wordMatchesPlate(plate, word) {
        return getPlateMatchIndices(plate, word) !== null;
    }

    // --------- JS-BASED VIABLE COUNT ---------
    function computeJsViableCount(plate) {
        if (!dictionaryReady || !plate) return 0;
        let count = 0;
        for (const w of WORDS) {
            if (wordMatchesPlate(plate, w)) {
                count++;
            }
        }
        return count;
    }

    // --------- PER-GAME RANDOM PLATE (7 BANDS, NO REPEATS) ---------
    function getBandPool(bandName) {
        switch (bandName) {
            case "very_easy":   return VERY_EASY_PLATES;
            case "easy":        return EASY_PLATES;
            case "medium":      return MEDIUM_PLATES;
            case "difficult":   return DIFFICULT_PLATES;
            case "hard":        return HARD_PLATES;
            case "very_hard":   return VERY_HARD_PLATES;
            case "impossible":  return IMPOSSIBLE_PLATES;
            default:            return [];
        }
    }

    function pickRandomPlateFromBand(bandName) {
        const poolRef = getBandPool(bandName);
        const remaining = poolRef.filter(p => !usedPlates.has(p));
        if (remaining.length === 0) return null;

        const idx = Math.floor(Math.random() * remaining.length);
        return remaining[idx];
    }

    function choosePrimaryBand() {
        const r = Math.random();
        let threshold = 0;

        threshold += VERY_EASY_PROB;
        if (r < threshold) return "very_easy";

        threshold += EASY_PROB;
        if (r < threshold) return "easy";

        threshold += MEDIUM_PROB;
        if (r < threshold) return "medium";

        threshold += DIFFICULT_PROB;
        if (r < threshold) return "difficult";

        threshold += HARD_PROB;
        if (r < threshold) return "hard";

        threshold += VERY_HARD_PROB;
        if (r < threshold) return "very_hard";

        return "impossible";
    }

    function pickRandomPlate() {
        if (!platesReady || ALL_PLATES.length === 0) {
            resultEl.textContent = "No viable plates available.";
            resultEl.style.color = "red";
            return;
        }

        if (usedPlates.size === ALL_PLATES.length) {
            resultEl.textContent = "You‚Äôve seen all available plates! Ending this run.";
            resultEl.style.color = "red";
            endGame();
            return;
        }

        const primaryBand = choosePrimaryBand();

        const startIndex = BAND_NAMES.indexOf(primaryBand);
        const bandOrder = [];
        for (let i = 0; i < BAND_NAMES.length; i++) {
            bandOrder.push(BAND_NAMES[(startIndex + i) % BAND_NAMES.length]);
        }

        let chosen = null;
        for (const band of bandOrder) {
            chosen = pickRandomPlateFromBand(band);
            if (chosen) break;
        }

        if (!chosen) {
            const remaining = ALL_PLATES.filter(p => !usedPlates.has(p));
            if (remaining.length === 0) {
                resultEl.textContent = "No unused plates left. Ending this run.";
                resultEl.style.color = "red";
                endGame();
                return;
            }
            const idx = Math.floor(Math.random() * remaining.length);
            chosen = remaining[idx];
        }

        usedPlates.add(chosen);
        currentPlate = chosen;

        plateEl.textContent = chosen;
        resultEl.textContent = "";
        resultEl.style.color = "";

        plateLocked = false;
        checkButtonEl.disabled = false;
        skipButtonEl.disabled = false;
        wordInputEl.disabled = false;
        wordInputEl.readOnly = false;

        plateStartTime = performance.now();

        updateDifficultyDisplay(chosen);
        wordInputEl.value = "";
        wordInputEl.focus();
    }

    // --------- DIFFICULTY DISPLAY ---------
    function classifyDifficulty(score) {
        if (score >= 80) return "diff-hard";
        if (score >= 40) return "diff-med";
        return "diff-easy";
    }

    function updateDifficultyDisplay(plate) {
        if (!PLATE_DIFFICULTY || !PLATE_DIFFICULTY[plate]) {
            difficultyLabelEl.textContent = "Difficulty: ‚Äî";
            difficultyLabelEl.className = "difficulty diff-med";
        } else {
            const entry = PLATE_DIFFICULTY[plate];
            const diff = entry.difficulty;
            if (!diff || diff <= 0) {
                difficultyLabelEl.textContent = "Difficulty: ‚Äî";
                difficultyLabelEl.className = "difficulty diff-med";
            } else {
                difficultyLabelEl.textContent = `Difficulty: ${diff} / 100`;
                difficultyLabelEl.className = "difficulty " + classifyDifficulty(diff);
            }
        }

        if (!dictionaryReady || !plate) {
            viableCountLabelEl.textContent = "";
        } else {
            const jsCount = computeJsViableCount(plate);
            viableCountLabelEl.textContent = `${jsCount.toLocaleString()} viable words`;
        }
    }

    function getPlateDifficultyScore(plate) {
        if (!PLATE_DIFFICULTY || !PLATE_DIFFICULTY[plate]) return null;
        const d = PLATE_DIFFICULTY[plate].difficulty;
        if (!d || d <= 0) return null;
        return d;
    }

    // --------- TIMER / GAME STATE ---------
    function updateProgressDisplay() {
        progressDisplayEl.textContent = `Solved: ${solvedCount} / ${TOTAL_PLATES}`;
    }

    function updateSkipButtonLabel() {
        const nextPenalty = (skipCount + 1) * 5;
        skipButtonEl.textContent = `Skip +${nextPenalty}s`;
    }

    function showStartGameButton() {
        startButtonEl.style.display = "inline-block";
        startButtonEl.textContent = "Start Game";
        const ready = dictionaryReady && difficultyReady && platesReady;
        startButtonEl.disabled = !ready;
    }

    function showPlayAgainButton() {
        startButtonEl.style.display = "inline-block";
        startButtonEl.textContent = "Play again";
        startButtonEl.disabled = false;
    }

    function hideMainStartButton() {
        startButtonEl.style.display = "none";
    }

    function showChartButton() {
        if (gameHistory.length > 0) {
            chartButtonEl.style.display = "inline-block";
        }
    }

    function hideChartButton() {
        chartButtonEl.style.display = "none";
    }

    function resetGameState() {
        gameStarted = false;
        gameOver = false;
        solvedCount = 0;
        startTime = null;
        penaltySeconds = 0;
        skipCount = 0;
        plateLocked = false;
        usedPlates = new Set();
        plateStartTime = null;
        gameHistory = [];
        updateSkipButtonLabel();
        hideChartButton();

        if (timerIntervalId) clearInterval(timerIntervalId);
        timerIntervalId = null;

        plateEl.textContent = "---";
        difficultyLabelEl.textContent = "Difficulty: ‚Äî";
        difficultyLabelEl.className = "difficulty diff-med";
        viableCountLabelEl.textContent = "";
        timerDisplayEl.textContent = "Time: 0.0 s";
        updateProgressDisplay();
        resultEl.textContent = "";
        resultEl.style.color = "";
        wordInputEl.value = "";

        checkButtonEl.disabled = false;
        skipButtonEl.disabled = false;
        wordInputEl.disabled = false;
        wordInputEl.readOnly = false;

        while (historyBodyEl.firstChild) {
            historyBodyEl.removeChild(historyBodyEl.firstChild);
        }
        historyEmptyEl.style.display = "block";
    }

    function startGame() {
        const ready = dictionaryReady && difficultyReady && platesReady;
        if (!ready) {
            resultEl.textContent = "Still loading‚Ä¶";
            resultEl.style.color = "red";
            return;
        }

        if (ALL_PLATES.length === 0) {
            resultEl.textContent = "No viable plates to start the game.";
            resultEl.style.color = "red";
            return;
        }

        closeGameModal();
        hideMainStartButton();
        hideChartButton();

        resetGameState();
        gameStarted = true;
        gameOver = false;
        startTime = performance.now();
        timerIntervalId = setInterval(updateTimer, 100);
        updateProgressDisplay();
        pickRandomPlate();
    }

    function updateTimer() {
        if (!gameStarted || !startTime) return;
        const baseElapsedSec = (performance.now() - startTime) / 1000;
        const totalSec = baseElapsedSec + penaltySeconds;
        timerDisplayEl.textContent = "Time: " + totalSec.toFixed(1) + " s";
    }

    function endGame() {
        if (gameOver) return;
        gameOver = true;
        gameStarted = false;
        plateLocked = true;

        if (!startTime) return;

        const baseElapsedSec = (performance.now() - startTime) / 1000;
        const totalSec = baseElapsedSec + penaltySeconds;

        if (timerIntervalId) {
            clearInterval(timerIntervalId);
            timerIntervalId = null;
        }

        resultEl.textContent = `üèÅ Finished! Time: ${totalSec.toFixed(1)} s`;
        resultEl.style.color = "green";
        wordInputEl.blur();

        checkButtonEl.disabled = true;
        skipButtonEl.disabled = true;
        wordInputEl.disabled = true;
        wordInputEl.readOnly = true;

        openEndModal(totalSec);
        showPlayAgainButton();
        showChartButton();
    }

    // --------- FLOATING LABELS & HISTORY ---------
    function createFloatingLabel(text, fromRect, toRect, extraClass) {
        const el = document.createElement("div");
        el.textContent = text;
        el.className = "float-label " + (extraClass || "");

        const startX = fromRect.left + fromRect.width / 2;
        const startY = fromRect.top + fromRect.height / 2;
        const endX = toRect.left + toRect.width / 2;
        const endY = toRect.top + toRect.height / 2;

        el.style.left = startX + "px";
        el.style.top = startY + "px";

        document.body.appendChild(el);

        requestAnimationFrame(() => {
            el.style.left = endX + "px";
            el.style.top = endY + "px";
            el.style.opacity = "0";
        });

        return el;
    }

    function addPlateCellClickHandler(plateTd, plate) {
        plateTd.classList.add("clickable-plate");
        plateTd.title = "Click to see all viable words";
        plateTd.addEventListener("click", () => {
            openWordsModal(plate);
        });
    }

    function addToHistoryWithAnimation(
        plate,
        word,
        matchIndices,
        fromRectWord,
        diffScore,
        timeLabel,
        onComplete
    ) {
        if (!plate || !word) {
            if (onComplete) onComplete();
            return;
        }

        historyEmptyEl.style.display = "none";

        const row = document.createElement("tr");
        row.style.opacity = "0";

        const plateTd = document.createElement("td");
        const wordTd = document.createElement("td");
        const timeTd = document.createElement("td");
        const diffTd = document.createElement("td");

        plateTd.textContent = plate;

        if (Array.isArray(matchIndices) && matchIndices.length > 0) {
            const set = new Set(matchIndices);
            let html = "";
            for (let i = 0; i < word.length; i++) {
                const ch = word[i];
                if (set.has(i)) {
                    html += `<span class="plate-letter-highlight">${ch}</span>`;
                } else {
                    html += ch;
                }
            }
            wordTd.innerHTML = html;
        } else {
            wordTd.textContent = word;
        }

        timeTd.textContent = timeLabel || "‚Äî";

        if (diffScore === null || diffScore <= 0) {
            diffTd.textContent = "‚Äî";
        } else {
            diffTd.textContent = diffScore;
            diffTd.className = classifyDifficulty(diffScore);
        }

        row.appendChild(plateTd);
        row.appendChild(wordTd);
        row.appendChild(timeTd);
        row.appendChild(diffTd);

        if (historyBodyEl.firstChild) {
            historyBodyEl.insertBefore(row, historyBodyEl.firstChild);
        } else {
            historyBodyEl.appendChild(row);
        }

        while (historyBodyEl.rows.length > 30) {
            historyBodyEl.removeChild(historyBodyEl.lastChild);
        }

        addPlateCellClickHandler(plateTd, plate);

        const plateFrom = plateEl.getBoundingClientRect();
        const wordFrom = fromRectWord || wordInputEl.getBoundingClientRect();
        const plateTo = plateTd.getBoundingClientRect();
        const wordTo = wordTd.getBoundingClientRect();
        const diffTo = diffTd.getBoundingClientRect();

        const plateClone = createFloatingLabel(plate, plateFrom, plateTo, "float-label-plate");
        const wordClone = createFloatingLabel(word, wordFrom, wordTo, "float-label-word");
        const diffText = (diffScore === null || diffScore <= 0) ? "‚Äî" : String(diffScore);
        const diffClone = createFloatingLabel(diffText, plateFrom, diffTo, "float-label-diff");

        if (typeof onComplete === "function") {
            onComplete();
        }

        const animDuration = 400;
        setTimeout(() => {
            row.style.opacity = "1";

            [plateClone, wordClone, diffClone].forEach(clone => {
                if (clone && clone.parentNode) clone.parentNode.removeChild(clone);
            });
        }, animDuration);
    }

    // --------- MODAL: ALL VIABLE WORDS (WITH SORT TOGGLE) ---------
    function setWordsSortMode(mode) {
        currentWordsModalSortMode = mode;

        if (mode === "alpha") {
            wordsSortAlphaBtnEl.classList.add("active");
            wordsSortLengthBtnEl.classList.remove("active");
        } else {
            wordsSortAlphaBtnEl.classList.remove("active");
            wordsSortLengthBtnEl.classList.add("active");
        }

        renderWordsList(mode);
    }

    function renderWordsList(sortMode) {
        wordsModalListEl.innerHTML = "";

        const plate = currentWordsModalPlate;
        if (!plate || !currentWordsModalMatches || currentWordsModalMatches.length === 0) {
            wordsModalListEl.textContent = "(no viable words found)";
            return;
        }

        const arr = [...currentWordsModalMatches];

        if (sortMode === "alpha") {
            arr.sort((a, b) => a.localeCompare(b));
        } else {
            arr.sort((a, b) => {
                const lenDiff = a.length - b.length;
                return lenDiff !== 0 ? lenDiff : a.localeCompare(b);
            });
        }

        const frag = document.createDocumentFragment();
        for (const w of arr) {
            const line = document.createElement("div");
            line.className = "words-list-item";

            const indices = getPlateMatchIndices(plate, w) || [];
            const indexSet = new Set(indices);

            let html = "";
            for (let i = 0; i < w.length; i++) {
                const ch = w[i];
                if (indexSet.has(i)) {
                    html += `<span class="plate-letter-highlight">${ch}</span>`;
                } else {
                    html += ch;
                }
            }

            line.innerHTML = html;
            frag.appendChild(line);
        }

        wordsModalListEl.appendChild(frag);
    }

    function openWordsModal(plate) {
        if (!dictionaryReady) return;

        wordsModalTitleEl.textContent = `Plate: ${plate}`;
        wordsModalStatusEl.textContent = "Finding viable words‚Ä¶";

        // Reset sort mode state
        currentWordsModalPlate = plate;
        currentWordsModalMatches = [];
        setWordsSortMode("alpha");

        wordsModalBackdropEl.classList.add("show");

        const matches = [];
        for (const w of WORDS) {
            if (wordMatchesPlate(plate, w)) {
                matches.push(w);
            }
        }

        matches.sort(); // baseline
        currentWordsModalMatches = matches;

        const countFromScan = matches.length;
        wordsModalStatusEl.textContent =
            `${countFromScan.toLocaleString()} viable words`;

        renderWordsList(currentWordsModalSortMode);
    }

    function closeWordsModal() {
        wordsModalBackdropEl.classList.remove("show");
    }

    // --------- GAME MODAL (START / END) ---------
    function openStartModal() {
        gameModalMode = "start";
        gameModalTitleEl.textContent = "License Plate Game ‚Äì Time Trial";
        gameModalBodyEl.innerHTML = `
            <p><strong>How it works:</strong></p>
            <ul>
                <li>You will see plates one after another until you correctly solve <strong>${TOTAL_PLATES}</strong>.</li>
                <li>Enter a word that contains the three plate letters <em>in order</em> (not necessarily consecutively).</li>
                <li>The first instance of each letter must come in order. If your plate is <strong>ABC</strong>, then the first A must appear before the first B or C.</li>
                <li>Example: plate <strong>PMS</strong> ‚Äì <strong>"promise"</strong> works, but <strong>"spams"</strong> does not ("spams" contains PMS, but the first S appears before the first M).</li>
                <li>You can press <strong>Skip</strong>, but it adds an increasing time penalty: +5s, then +10s, +15s, ...</li>
                <li>Click any solved plate in the table to see <strong>all</strong> viable words for that plate.</li>
            </ul>
        `;

        const ready = dictionaryReady && difficultyReady && platesReady;
        gameModalPrimaryBtnEl.disabled = !ready;
        gameModalPrimaryBtnEl.textContent = ready ? "Start Game" : "Loading...";

        gameModalSecondaryBtnEl.style.display = "none";

        gameModalBackdropEl.classList.add("show");
    }

    function openEndModal(finalTimeSec) {
        gameModalMode = "end";
        gameModalTitleEl.textContent = "Run complete!";
        gameModalBodyEl.innerHTML = `
            <p>You solved <strong>${TOTAL_PLATES}</strong> plates in
            <strong>${finalTimeSec.toFixed(1)} seconds</strong> (including skip penalties).</p>
            <p>You can view a breakdown chart of each plate's time, or close this and inspect the table.</p>
        `;

        gameModalPrimaryBtnEl.disabled = false;
        gameModalPrimaryBtnEl.textContent = "Play again";

        gameModalSecondaryBtnEl.style.display = "inline-block";
        gameModalSecondaryBtnEl.textContent = "View chart";

        gameModalBackdropEl.classList.add("show");
    }

    function closeGameModal() {
        gameModalBackdropEl.classList.remove("show");
    }

    // --------- MISMATCH EXPLANATION ---------
    function explainPlateMismatch(plate, word) {
        const plateUpper = plate.toUpperCase();
        const wordUpper = word.toUpperCase();

        const missing = [];
        for (const ch of plateUpper) {
            if (!wordUpper.includes(ch)) {
                if (!missing.includes(ch)) missing.push(ch);
            }
        }

        if (missing.length > 0) {
            const missingList = missing.join(", ");
            const letterWord = missing.length === 1 ? "letter" : "letters";
            return `‚ùå "${word}" doesn‚Äôt work for <strong>${plateUpper}</strong>.<br>` +
                   `It‚Äôs missing the ${letterWord}: <strong>${missingList}</strong>.`;
        }

        const firstOccurrences = [];
        for (const ch of plateUpper) {
            const idx = wordUpper.indexOf(ch);
            if (idx !== -1) {
                firstOccurrences.push({ ch, idx });
            }
        }

        firstOccurrences.sort((a, b) => a.idx - b.idx);
        const wordOrder = firstOccurrences.map(x => x.ch).join(" \u2192 ");
        const plateOrder = plateUpper.split("").join(" \u2192 ");
        const lettersList = plateUpper.split("").join(", ");

        return `‚ùå "${word}" doesn‚Äôt work for <strong>${plateUpper}</strong>.<br>` +
               `In your word, the first <strong>${lettersList}</strong> appear in this order: <strong>${wordOrder}</strong>.<br>` +
               `The plate <strong>${plateUpper}</strong> requires them in this order: <strong>${plateOrder}</strong>.`;
    }

    // --------- CHART PLUGIN: difficulty dots ---------
    const difficultyDotsPlugin = {
        id: "difficultyDots",
        afterDatasetsDraw(chart, args, opts) {
            const difficulties = chart.options.plugins.difficultyDots?.difficulties;
            if (!difficulties) return;
            const { ctx } = chart;
            const meta = chart.getDatasetMeta(0);
            if (!meta || !meta.data) return;

            const xDot = chart.chartArea.left + 8;

            meta.data.forEach((bar, index) => {
                const diff = difficulties[index];
                if (diff == null) return;

                let color;
                if (diff >= 80) {
                    color = "#dc2626"; // red
                } else if (diff >= 40) {
                    color = "#d97706"; // orange
                } else {
                    color = "#16a34a"; // green
                }

                const y = bar.y;

                ctx.save();
                ctx.beginPath();
                ctx.fillStyle = color;
                ctx.arc(xDot, y, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
        }
    };

    // --------- CHART BUILD / UPDATE ---------
    function buildChart() {
        if (!gameHistory.length) return;
        const labels = [];
        const thinkingData = [];
        const penaltyData = [];
        const difficulties = [];
        const platesForChart = [];

        for (const entry of gameHistory) {
            const diff = getPlateDifficultyScore(entry.plate);
            difficulties.push(diff);
            platesForChart.push(entry.plate);

            let labelText;
            if (entry.skipped) {
                labelText = `${entry.plate} ‚Äî skipped`;
            } else {
                labelText = `${entry.plate} ‚Äî "${entry.word}"`;
            }
            labels.push(labelText);

            const think = entry.thinkingSeconds != null ? entry.thinkingSeconds : 0;
            const pen   = entry.penaltySeconds != null ? entry.penaltySeconds : 0;

            thinkingData.push(think);
            penaltyData.push(pen);
        }

        const ctx = resultsChartCanvas.getContext("2d");

        resultsChart = new Chart(ctx, {
            type: "bar",
            data: {
                labels,
                datasets: [
                    {
                        label: "Thinking time (s)",
                        data: thinkingData,
                        backgroundColor: "rgba(59, 130, 246, 0.8)", // blue
                        stack: "time"
                    },
                    {
                        label: "Skip penalty (s)",
                        data: penaltyData,
                        backgroundColor: "rgba(220, 38, 38, 0.8)", // red
                        stack: "time"
                    }
                ],
                _plates: platesForChart
            },
            options: {
                indexAxis: "y",
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: "bottom"
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.dataset.label || "";
                                const value = context.parsed.x;
                                return `${label}: ${value.toFixed(1)}s`;
                            }
                        }
                    },
                    difficultyDots: {
                        difficulties
                    }
                },
                scales: {
                    x: {
                        stacked: true,
                        title: {
                            display: true,
                            text: "Seconds"
                        },
                        grid: {
                            display: false,
                            drawBorder: false
                        }
                    },
                    y: {
                        stacked: true,
                        categoryPercentage: 0.7,
                        barPercentage: 0.7,
                        grid: {
                            display: false,
                            drawBorder: false
                        }
                    }
                },
                onClick: (evt, elements) => {
                    if (!elements.length) return;
                    const index = elements[0].index;
                    const plate = resultsChart.config.data._plates[index];
                    openWordsModal(plate);
                }
            },
            plugins: [difficultyDotsPlugin]
        });
    }

    function openChartModal() {
        if (!gameHistory.length) return;

        // Destroy any existing chart instance so we always recreate fresh
        if (resultsChart) {
            resultsChart.destroy();
            resultsChart = null;
        }

        buildChart();
        chartModalBackdropEl.classList.add("show");
    }

    function closeChartModal() {
        chartModalBackdropEl.classList.remove("show");
    }

    // --------- ACTIONS ---------
    function checkWord() {
        const rawWord = wordInputEl.value.trim();
        if (!rawWord) return;

        if (!gameStarted) {
            resultEl.textContent = "Press Start to begin the game.";
            resultEl.style.color = "red";
            return;
        }
        if (gameOver) {
            resultEl.textContent = "Game over. Press Play again to restart.";
            resultEl.style.color = "red";
            return;
        }
        if (plateLocked) {
            return;
        }

        if (!DICTIONARY.has(rawWord.toUpperCase())) {
            resultEl.textContent = `‚ùå "${rawWord}" is not in the dictionary.`;
            resultEl.style.color = "red";
            return;
        }

        const matchIndices = getPlateMatchIndices(currentPlate, rawWord);
        if (!matchIndices) {
            const html = explainPlateMismatch(currentPlate, rawWord);
            resultEl.innerHTML = html;
            resultEl.style.color = "red";
            return;
        }

        plateLocked = true;
        checkButtonEl.disabled = true;
        skipButtonEl.disabled = true;
        wordInputEl.readOnly = true;

        solvedCount++;
        updateProgressDisplay();

        resultEl.textContent = `‚úÖ "${rawWord}" matches ${currentPlate}.`;
        resultEl.style.color = "green";

        const plate = currentPlate;
        const word = rawWord.toLowerCase();
        const diffScore = getPlateDifficultyScore(plate);

        let timeLabel = "‚Äî";
        let thinkingSeconds = 0;
        if (plateStartTime != null) {
            thinkingSeconds = (performance.now() - plateStartTime) / 1000;
            timeLabel = `${thinkingSeconds.toFixed(1)}s`;
        }

        gameHistory.push({
            plate,
            word,
            skipped: false,
            thinkingSeconds,
            penaltySeconds: 0
        });

        addToHistoryWithAnimation(
            plate,
            word,
            matchIndices,
            null,
            diffScore,
            timeLabel,
            () => {
                if (solvedCount >= TOTAL_PLATES) {
                    endGame();
                } else {
                    pickRandomPlate();
                }
            }
        );
    }

    function handleSkip() {
        if (!gameStarted) {
            resultEl.textContent = "Press Start to begin the game.";
            resultEl.style.color = "red";
            return;
        }
        if (gameOver) {
            resultEl.textContent = "Game over. Press Play again to restart.";
            resultEl.style.color = "red";
            return;
        }
        if (!currentPlate) return;
        if (plateLocked) {
            return;
        }

        plateLocked = true;
        checkButtonEl.disabled = true;
        skipButtonEl.disabled = true;
        wordInputEl.readOnly = true;

        skipCount += 1;
        const added = skipCount * 5;
        penaltySeconds += added;

        resultEl.textContent = `‚è© Skipped ${currentPlate}. +${added}s penalty.`;
        resultEl.style.color = "orange";

        const plate = currentPlate;
        const penaltyLabel = `+${added}s (skipped)`;
        const diffScore = getPlateDifficultyScore(plate);
        const skipRect = skipButtonEl.getBoundingClientRect();

        let timeLabel = "‚Äî";
        let thinkingSeconds = 0;
        if (plateStartTime != null) {
            thinkingSeconds = (performance.now() - plateStartTime) / 1000;
            timeLabel = `${thinkingSeconds.toFixed(1)}s (+${added}s)`;
        }

        gameHistory.push({
            plate,
            word: "skipped",
            skipped: true,
            thinkingSeconds,
            penaltySeconds: added
        });

        addToHistoryWithAnimation(
            plate,
            penaltyLabel,
            null,
            skipRect,
            diffScore,
            timeLabel,
            () => {
                updateSkipButtonLabel();
                pickRandomPlate();
            }
        );
    }

    // --------- INIT ---------
    startButtonEl.disabled = true;
    hideMainStartButton();
    hideChartButton();
    updateSkipButtonLabel();

    startButtonEl.addEventListener("click", startGame);
    checkButtonEl.addEventListener("click", checkWord);
    skipButtonEl.addEventListener("click", handleSkip);
    chartButtonEl.addEventListener("click", openChartModal);

    wordInputEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
            checkWord();
        }
    });

    wordsModalCloseBtnEl.addEventListener("click", closeWordsModal);
    wordsModalCloseBtnBottomEl.addEventListener("click", closeWordsModal);
    wordsModalBackdropEl.addEventListener("click", (e) => {
        if (e.target === wordsModalBackdropEl) {
            closeWordsModal();
        }
    });

    wordsSortAlphaBtnEl.addEventListener("click", () => {
        setWordsSortMode("alpha");
    });

    wordsSortLengthBtnEl.addEventListener("click", () => {
        setWordsSortMode("length");
    });

    gameModalPrimaryBtnEl.addEventListener("click", () => {
        if (gameModalMode === "start") {
            startGame();
        } else if (gameModalMode === "end") {
            startGame();
        }
    });

    gameModalSecondaryBtnEl.addEventListener("click", () => {
        closeGameModal();
        openChartModal();
    });

    gameModalCloseBtnEl.addEventListener("click", () => {
        closeGameModal();
        if (!gameStarted && !gameOver && gameModalMode === "start") {
            showStartGameButton();
        }
    });

    gameModalBackdropEl.addEventListener("click", (e) => {
        if (e.target === gameModalBackdropEl) {
            closeGameModal();
            if (!gameStarted && !gameOver && gameModalMode === "start") {
                showStartGameButton();
            }
        }
    });

    chartModalCloseBtnEl.addEventListener("click", closeChartModal);
    chartModalCloseBtnBottomEl.addEventListener("click", closeChartModal);
    chartModalBackdropEl.addEventListener("click", (e) => {
        if (e.target === chartModalBackdropEl) {
            closeChartModal();
        }
    });

    loadDictionary();
    loadDifficulty();
    openStartModal();
</script>

</body>
</html>
