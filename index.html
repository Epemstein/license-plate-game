<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>License Plate Game â€“ Time Trial</title>
    <style>

        @font-face {
            font-family: "RoadgeekUS";
            src: url("fonts/Roadgeek.woff2") format("woff2");
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            max-width: 1100px;
            margin: 40px auto;
            padding: 0 16px 40px;
            line-height: 1.5;
        }

        h1 {
            margin-top: 0;
            margin-bottom: 0.5rem;
        }

        .layout {
            display: flex;
            align-items: flex-start;
            gap: 32px;
        }

        .left-panel { flex: 0 0 55%; }
        .right-panel { flex: 1; }

        .car-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
            max-width: 360px;
            height: 380px;
            overflow: hidden;
        }

        .car-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .plate-text {
            position: absolute;
            left: 52%;
            bottom: 26.5%;
            transform: translateX(-50%);
        
            font-family: "RoadgeekUS", sans-serif;
            font-size: 3rem;
            letter-spacing: 0.33em;   /* Roadgeek letters are wide */
            color: #222;
            font-weight: 400;         /* Plate fonts look best without bold */
            text-transform: uppercase;
            text-shadow: 0 1px 2px rgba(0,0,0,0.35);
            pointer-events: none;
        }


        .difficulty {
            margin-top: 8px;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .diff-easy { color: #16a34a; }   /* green */
        .diff-med  { color: #d97706; }   /* orange */
        .diff-hard { color: #dc2626; }   /* red */

        .controls {
            margin: 24px 0 12px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }

        .controls input[type="text"] {
            flex: 1;
            min-width: 180px;
            padding: 8px;
            font-size: 1rem;
        }

        button {
            padding: 8px 14px;
            font-size: 0.95rem;
            cursor: pointer;
        }

        button:disabled {
            opacity: 0.6;
            cursor: default;
        }

        /* hidden initially; we show this as "Start Game" if user closes the rules modal without starting */
        #startButton {
            display: none;
        }

        #result {
            margin-top: 10px;
            font-weight: 600;
        }

        #debug {
            margin-top: 6px;
            font-size: 0.85rem;
            color: #6b7280;
        }

        #timerRow {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin-bottom: 8px;
            font-weight: 600;
            font-size: 0.95rem;
        }

        #timerDisplay { color: #111827; }
        #progressDisplay { color: #374151; }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-size: 0.95rem;
        }

        th, td {
            border-bottom: 1px solid #e5e7eb;
            padding: 6px 8px;
            text-align: left;
        }

        th {
            background-color: #f3f4f6;
            font-weight: 600;
        }

        tr:nth-child(even) td {
            background-color: #f9fafb;
        }

        .history-empty {
            font-size: 0.85rem;
            color: #6b7280;
            margin-top: 4px;
        }

        .plate-letter-highlight {
            color: #16a34a;
            font-weight: 700;
        }

        .clickable-plate {
            cursor: pointer;
            text-decoration: underline;
            text-decoration-style: dotted;
        }

        .clickable-plate:hover {
            text-decoration-style: solid;
        }

        /* Floating labels */
        .float-label {
            position: fixed;
            transform: translate(-50%, -50%);
            z-index: 999;
            pointer-events: none;
            background: rgba(255,255,255,0.95);
            padding: 3px 6px;
            border-radius: 4px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.25);
            opacity: 1;
            transition:
                top 0.4s ease-out,
                left 0.4s ease-out,
                opacity 0.4s ease-out;
            white-space: nowrap;
            font-size: 0.9rem;
        }

        .float-label-plate {
            font-size: 1.1rem;
            letter-spacing: 0.3em;
            font-weight: 600;
        }

        .float-label-word {
            font-weight: 600;
        }

        .float-label-diff {
            font-size: 0.8rem;
            font-weight: 700;
        }

        /* Modal base styles */
        .modal-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.45);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-backdrop.show {
            display: flex;
        }

        .modal {
            background: #ffffff;
            border-radius: 8px;
            max-width: 600px;
            width: 100%;
            max-height: 80vh;
            box-shadow: 0 10px 30px rgba(0,0,0,0.25);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .modal-header {
            padding: 10px 14px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #f3f4f6;
        }

        .modal-title {
            font-weight: 600;
            font-size: 1rem;
        }

        .modal-body {
            padding: 10px 14px;
            overflow-y: auto;
            font-size: 0.95rem;
        }

        .modal-footer {
            padding: 8px 14px;
            border-top: 1px solid #e5e7eb;
            text-align: right;
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }

        .modal-close-btn {
            border: none;
            background: transparent;
            font-size: 1.1rem;
            cursor: pointer;
        }

        .words-list {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            white-space: normal;
        }

        .words-list-item {
            display: block;
            margin-bottom: 2px;
        }

        @media (max-width: 800px) {
            .layout {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>

<h1>The License Plate Game v4</h1>

<div class="layout">
    <!-- LEFT PANEL -->
    <div class="left-panel">
        <p>
            Solve <strong>10 plates</strong> as fast as you can.<br>
            The plate letters must appear in your word in order (not necessarily consecutively).
        </p>

        <div class="car-wrapper">
            <img src="car.png" alt="Car with license plate" class="car-image">
            <div id="plate" class="plate-text">---</div>
        </div>

        <div id="difficultyLabel" class="difficulty diff-med">
            Difficulty: â€”
        </div>
        <div id="viableCountLabel" style="color:#6b7280; font-size:0.9rem; margin-top:2px;">
        </div>

        <div class="controls">
            <button id="startButton">Play again</button>
            <input id="wordInput" type="text" placeholder="Type a word" autocomplete="off">
            <button id="checkButton">Check</button>
            <button id="skipButton">Skip +5s</button>
        </div>

        <div id="result"></div>
        <div id="debug"></div>
    </div>

    <!-- RIGHT PANEL -->
    <div class="right-panel">
        <div id="timerRow">
            <span id="timerDisplay">Time: 0.0 s</span>
            <span id="progressDisplay">Solved: 0 / 10</span>
        </div>

        <h2>Solved Plates</h2>
        <table>
            <thead>
            <tr>
                <th>Plate</th>
                <th>Word / Penalty</th>
                <th>Difficulty</th>
            </tr>
            </thead>
            <tbody id="historyBody"></tbody>
        </table>
        <div id="historyEmpty" class="history-empty">
            No solved plates yet.
        </div>
    </div>
</div>

<!-- GAME START / END MODAL -->
<div id="gameModalBackdrop" class="modal-backdrop">
    <div class="modal">
        <div class="modal-header">
            <div class="modal-title" id="gameModalTitle">License Plate Game</div>
            <button class="modal-close-btn" id="gameModalCloseBtn" aria-label="Close">&times;</button>
        </div>
        <div class="modal-body" id="gameModalBody">
            <!-- Filled dynamically -->
        </div>
        <div class="modal-footer">
            <button id="gameModalSecondaryBtn" style="display:none;">See results</button>
            <button id="gameModalPrimaryBtn">Start Game</button>
        </div>
    </div>
</div>

<!-- MODAL: Viable words for a plate -->
<div id="wordsModalBackdrop" class="modal-backdrop">
    <div class="modal">
        <div class="modal-header">
            <div class="modal-title" id="wordsModalTitle">Plate: ---</div>
            <button class="modal-close-btn" id="wordsModalCloseBtn" aria-label="Close">&times;</button>
        </div>
        <div class="modal-body">
            <div id="wordsModalStatus" style="margin-bottom:6px; color:#6b7280; font-size:0.9rem;">
                Loading...
            </div>
            <div id="wordsModalList" class="words-list"></div>
        </div>
        <div class="modal-footer">
            <button id="wordsModalCloseBtnBottom">Close</button>
        </div>
    </div>
</div>

<script>
    // --------- CONFIG ---------
    const TOTAL_PLATES = 10;
    const TARGET_FUNKY_SHARE = 0.3; // ~30% plates with J/Q/X/Z

    // --------- GLOBAL STATE ---------
    let WORDS = [];
    let DICTIONARY = new Set();
    let dictionaryReady = false;

    let FUNKY_WORDS = [];
    let NORMAL_WORDS = [];

    let PLATE_DIFFICULTY = null;
    let difficultyReady = false;

    let currentPlate = null;

    let gameStarted = false;
    let gameOver = false;
    let solvedCount = 0;
    let startTime = null;
    let penaltySeconds = 0;
    let timerIntervalId = null;

    let skipCount = 0; // track number of skips
    let plateLocked = false; // prevent double submit / double skip on same plate

    let gameModalMode = "start"; // "start" or "end"

    // DOM refs
    const plateEl = document.getElementById("plate");
    const difficultyLabelEl = document.getElementById("difficultyLabel");
    const viableCountLabelEl = document.getElementById("viableCountLabel");
    const wordInputEl = document.getElementById("wordInput");
    const resultEl = document.getElementById("result");
    const debugEl = document.getElementById("debug");
    const timerDisplayEl = document.getElementById("timerDisplay");
    const progressDisplayEl = document.getElementById("progressDisplay");
    const historyBodyEl = document.getElementById("historyBody");
    const historyEmptyEl = document.getElementById("historyEmpty");
    const startButtonEl = document.getElementById("startButton");
    const checkButtonEl = document.getElementById("checkButton");
    const skipButtonEl = document.getElementById("skipButton");

    // Game modal refs
    const gameModalBackdropEl = document.getElementById("gameModalBackdrop");
    const gameModalTitleEl = document.getElementById("gameModalTitle");
    const gameModalBodyEl = document.getElementById("gameModalBody");
    const gameModalPrimaryBtnEl = document.getElementById("gameModalPrimaryBtn");
    const gameModalSecondaryBtnEl = document.getElementById("gameModalSecondaryBtn");
    const gameModalCloseBtnEl = document.getElementById("gameModalCloseBtn");

    // Words modal refs
    const wordsModalBackdropEl = document.getElementById("wordsModalBackdrop");
    const wordsModalTitleEl = document.getElementById("wordsModalTitle");
    const wordsModalStatusEl = document.getElementById("wordsModalStatus");
    const wordsModalListEl = document.getElementById("wordsModalList");
    const wordsModalCloseBtnEl = document.getElementById("wordsModalCloseBtn");
    const wordsModalCloseBtnBottomEl = document.getElementById("wordsModalCloseBtnBottom");

    // --------- LOADING ---------
    async function loadDictionary() {
        try {
            const res = await fetch("words.txt");
            const text = await res.text();

            WORDS = [];
            FUNKY_WORDS = [];
            NORMAL_WORDS = [];
            DICTIONARY = new Set();

            for (const line of text.split(/\r?\n/)) {
                const w = line.trim().toLowerCase();
                if (!w) continue;
                if (!/^[a-z]+$/.test(w)) continue;
                if (w.length < 3) continue;

                WORDS.push(w);
                DICTIONARY.add(w.toUpperCase());

                if (/[jqxz]/.test(w)) {
                    FUNKY_WORDS.push(w);
                } else {
                    NORMAL_WORDS.push(w);
                }
            }

            dictionaryReady = true;
            debugEl.textContent = `Loaded ${WORDS.length.toLocaleString()} words.`;
            maybeEnableStart();
        } catch (err) {
            console.error(err);
            resultEl.textContent = "Failed to load words.txt.";
            resultEl.style.color = "red";
        }
    }

    async function loadDifficulty() {
        try {
            // cache-busted JSON fetch
            const res = await fetch("plate_difficulty.json?v=2");
            PLATE_DIFFICULTY = await res.json();
            difficultyReady = true;
            maybeEnableStart();
        } catch (err) {
            console.warn("Difficulty JSON not loaded:", err);
            PLATE_DIFFICULTY = null;
            difficultyReady = false;
            maybeEnableStart();
        }
    }

    function maybeEnableStart() {
        const ready = dictionaryReady && (difficultyReady || PLATE_DIFFICULTY === null);

        // Only matters if the main start button is currently visible
        startButtonEl.disabled = !ready;

        if (gameModalMode === "start") {
            gameModalPrimaryBtnEl.disabled = !ready;
            gameModalPrimaryBtnEl.textContent = ready ? "Start Game" : "Loading...";
        }
    }

    // --------- PLATE MATCHING ---------
    function getPlateMatchIndices(plate, word) {
        plate = plate.toUpperCase();
        const upperWord = word.toUpperCase();

        let expectedPlateIndex = 0;
        const matchedIndices = [];

        for (let i = 0; i < upperWord.length; i++) {
            const ch = upperWord[i];
            const posInPlate = plate.indexOf(ch);

            if (posInPlate === -1) continue;

            if (posInPlate === expectedPlateIndex) {
                matchedIndices.push(i);
                expectedPlateIndex++;
                if (expectedPlateIndex === plate.length) {
                    return matchedIndices;
                }
            } else if (posInPlate > expectedPlateIndex) {
                // later plate letter appears before earlier one
                return null;
            } else {
                // already passed this plate letter; ignore
                continue;
            }
        }
        return null;
    }

    function wordMatchesPlate(plate, word) {
        return getPlateMatchIndices(plate, word) !== null;
    }

    // --------- JS-BASED VIABLE COUNT ---------
    function computeJsViableCount(plate) {
        if (!dictionaryReady || !plate) return 0;
        let count = 0;
        for (const w of WORDS) {
            if (wordMatchesPlate(plate, w)) {
                count++;
            }
        }
        return count;
    }

    // --------- PLATE GENERATION ---------
    function plateHasFunkyLetter(plate) {
        return /[JQXZ]/.test(plate);
    }

    function generatePlateFromWord(word) {
        const upper = word.toUpperCase();
        const len = upper.length;
        if (len < 3) return null;

        for (let attempt = 0; attempt < 40; attempt++) {
            const i = Math.floor(Math.random() * (len - 2));
            const j = i + 1 + Math.floor(Math.random() * (len - i - 2));
            const k = j + 1 + Math.floor(Math.random() * (len - j - 1));

            const a = upper[i], b = upper[j], c = upper[k];
            if (a === b || a === c || b === c) continue;

            const plate = a + b + c;

            // skip plates that are exact words
            if (DICTIONARY.has(plate)) continue;

            if (!wordMatchesPlate(plate, upper)) continue;

            return plate;
        }
        return null;
    }

    function pickRandomPlate() {
        if (!dictionaryReady) {
            resultEl.textContent = "Dictionary still loading...";
            resultEl.style.color = "red";
            return;
        }
        if (gameOver || !gameStarted) {
            return;
        }

        if (WORDS.length === 0) {
            plateEl.textContent = "ERR";
            resultEl.textContent = "No words available.";
            resultEl.style.color = "red";
            return;
        }

        const wantFunky = Math.random() < TARGET_FUNKY_SHARE;
        let sourceWords;

        if (wantFunky && FUNKY_WORDS.length > 0) {
            sourceWords = FUNKY_WORDS;
        } else if (!wantFunky && NORMAL_WORDS.length > 0) {
            sourceWords = NORMAL_WORDS;
        } else {
            sourceWords = WORDS;
        }

        for (let attempts = 0; attempts < 500; attempts++) {
            const word = sourceWords[Math.floor(Math.random() * sourceWords.length)];
            const plate = generatePlateFromWord(word);
            if (!plate) continue;

            const isFunky = plateHasFunkyLetter(plate);
            if (wantFunky && !isFunky) continue;
            if (!wantFunky && isFunky) continue;

            currentPlate = plate;
            plateEl.textContent = plate;
            resultEl.textContent = "";
            resultEl.style.color = "";

            plateLocked = false; // unlock for this new plate
            checkButtonEl.disabled = false;
            skipButtonEl.disabled = false;
            wordInputEl.disabled = false;
            wordInputEl.readOnly = false;

            updateDifficultyDisplay(plate);
            wordInputEl.value = "";
            wordInputEl.focus();
            return;
        }

        plateEl.textContent = "ERR";
        resultEl.textContent = "Could not generate plate.";
        resultEl.style.color = "red";
    }

    // --------- DIFFICULTY DISPLAY ---------
    function classifyDifficulty(score) {
        if (score >= 80) return "diff-hard";
        if (score >= 40) return "diff-med";
        return "diff-easy";
    }

    function updateDifficultyDisplay(plate) {
        // Difficulty from JSON
        if (!PLATE_DIFFICULTY || !PLATE_DIFFICULTY[plate]) {
            difficultyLabelEl.textContent = "Difficulty: â€”";
            difficultyLabelEl.className = "difficulty diff-med";
        } else {
            const entry = PLATE_DIFFICULTY[plate];
            const diff = entry.difficulty;
            if (!diff || diff <= 0) {
                difficultyLabelEl.textContent = "Difficulty: â€”";
                difficultyLabelEl.className = "difficulty diff-med";
            } else {
                difficultyLabelEl.textContent = `Difficulty: ${diff} / 100`;
                difficultyLabelEl.className = "difficulty " + classifyDifficulty(diff);
            }
        }

        // Viable word count from JS
        if (!dictionaryReady || !plate) {
            viableCountLabelEl.textContent = "";
        } else {
            const jsCount = computeJsViableCount(plate);
            viableCountLabelEl.textContent = `${jsCount.toLocaleString()} viable words`;
        }
    }

    function getPlateDifficultyScore(plate) {
        if (!PLATE_DIFFICULTY || !PLATE_DIFFICULTY[plate]) return null;
        const d = PLATE_DIFFICULTY[plate].difficulty;
        if (!d || d <= 0) return null;
        return d;
    }

    // --------- TIMER / GAME STATE ---------
    function updateProgressDisplay() {
        progressDisplayEl.textContent = `Solved: ${solvedCount} / ${TOTAL_PLATES}`;
    }

    function updateSkipButtonLabel() {
        const nextPenalty = (skipCount + 1) * 5;
        skipButtonEl.textContent = `Skip +${nextPenalty}s`;
    }

    // Main-page button helpers:
    // - before game: "Start Game"
    // - after game: "Play again"
    // - during game: hidden
    function showStartGameButton() {
        startButtonEl.style.display = "inline-block";
        startButtonEl.textContent = "Start Game";
        const ready = dictionaryReady && (difficultyReady || PLATE_DIFFICULTY === null);
        startButtonEl.disabled = !ready;
    }

    function showPlayAgainButton() {
        startButtonEl.style.display = "inline-block";
        startButtonEl.textContent = "Play again";
        startButtonEl.disabled = false;
    }

    function hideMainStartButton() {
        startButtonEl.style.display = "none";
    }

    function resetGameState() {
        gameStarted = false;
        gameOver = false;
        solvedCount = 0;
        startTime = null;
        penaltySeconds = 0;
        skipCount = 0;
        plateLocked = false;
        updateSkipButtonLabel();

        if (timerIntervalId) clearInterval(timerIntervalId);
        timerIntervalId = null;

        plateEl.textContent = "---";
        difficultyLabelEl.textContent = "Difficulty: â€”";
        difficultyLabelEl.className = "difficulty diff-med";
        viableCountLabelEl.textContent = "";
        timerDisplayEl.textContent = "Time: 0.0 s";
        updateProgressDisplay();
        resultEl.textContent = "";
        resultEl.style.color = "";
        wordInputEl.value = "";

        checkButtonEl.disabled = false;
        skipButtonEl.disabled = false;
        wordInputEl.disabled = false;
        wordInputEl.readOnly = false;

        while (historyBodyEl.firstChild) {
            historyBodyEl.removeChild(historyBodyEl.firstChild);
        }
        historyEmptyEl.style.display = "block";
    }

    function startGame() {
        const ready = dictionaryReady && (difficultyReady || PLATE_DIFFICULTY === null);
        if (!ready) {
            resultEl.textContent = "Still loadingâ€¦";
            resultEl.style.color = "red";
            return;
        }

        closeGameModal();
        hideMainStartButton(); // hide the main button while game is in progress

        resetGameState();
        gameStarted = true;
        gameOver = false;
        startTime = performance.now();
        timerIntervalId = setInterval(updateTimer, 100);
        updateProgressDisplay();
        pickRandomPlate();
    }

    function updateTimer() {
        if (!gameStarted || !startTime) return;
        const baseElapsedSec = (performance.now() - startTime) / 1000;
        const totalSec = baseElapsedSec + penaltySeconds;
        timerDisplayEl.textContent = "Time: " + totalSec.toFixed(1) + " s";
    }

    function endGame() {
        if (gameOver) return;
        gameOver = true;
        gameStarted = false;
        plateLocked = true;

        if (!startTime) return;

        const baseElapsedSec = (performance.now() - startTime) / 1000;
        const totalSec = baseElapsedSec + penaltySeconds;

        if (timerIntervalId) {
            clearInterval(timerIntervalId);
            timerIntervalId = null;
        }

        resultEl.textContent = `ðŸ Finished! Time: ${totalSec.toFixed(1)} s`;
        resultEl.style.color = "green";
        wordInputEl.blur();

        // disable controls at end of run
        checkButtonEl.disabled = true;
        skipButtonEl.disabled = true;
        wordInputEl.disabled = true;
        wordInputEl.readOnly = true;

        openEndModal(totalSec);
        showPlayAgainButton(); // main-page button becomes "Play again"
    }

    // --------- FLOATING LABELS & HISTORY ---------
    function createFloatingLabel(text, fromRect, toRect, extraClass) {
        const el = document.createElement("div");
        el.textContent = text;
        el.className = "float-label " + (extraClass || "");

        const startX = fromRect.left + fromRect.width / 2;
        const startY = fromRect.top + fromRect.height / 2;
        const endX = toRect.left + toRect.width / 2;
        const endY = toRect.top + toRect.height / 2;

        el.style.left = startX + "px";
        el.style.top = startY + "px";

        document.body.appendChild(el);

        requestAnimationFrame(() => {
            el.style.left = endX + "px";
            el.style.top = endY + "px";
            el.style.opacity = "0";
        });

        return el;
    }

    function addPlateCellClickHandler(plateTd, plate) {
        plateTd.classList.add("clickable-plate");
        plateTd.title = "Click to see all viable words";
        plateTd.addEventListener("click", () => {
            openWordsModal(plate);
        });
    }

    function addToHistoryWithAnimation(plate, word, matchIndices, fromRectWord, diffScore, onComplete) {
        if (!plate || !word) {
            if (onComplete) onComplete();
            return;
        }

        historyEmptyEl.style.display = "none";

        const row = document.createElement("tr");
        row.style.opacity = "0";

        const plateTd = document.createElement("td");
        const wordTd = document.createElement("td");
        const diffTd = document.createElement("td");

        plateTd.textContent = plate;

        if (Array.isArray(matchIndices) && matchIndices.length > 0) {
            const set = new Set(matchIndices);
            let html = "";
            for (let i = 0; i < word.length; i++) {
                const ch = word[i];
                if (set.has(i)) {
                    html += `<span class="plate-letter-highlight">${ch}</span>`;
                } else {
                    html += ch;
                }
            }
            wordTd.innerHTML = html;
        } else {
            wordTd.textContent = word;
        }

        if (diffScore === null || diffScore <= 0) {
            diffTd.textContent = "â€”";
        } else {
            diffTd.textContent = diffScore;
            diffTd.className = classifyDifficulty(diffScore);
        }

        row.appendChild(plateTd);
        row.appendChild(wordTd);
        row.appendChild(diffTd);

        if (historyBodyEl.firstChild) {
            historyBodyEl.insertBefore(row, historyBodyEl.firstChild);
        } else {
            historyBodyEl.appendChild(row);
        }

        while (historyBodyEl.rows.length > 30) {
            historyBodyEl.removeChild(historyBodyEl.lastChild);
        }

        addPlateCellClickHandler(plateTd, plate);

        const plateFrom = plateEl.getBoundingClientRect();
        const wordFrom = fromRectWord || wordInputEl.getBoundingClientRect();
        const plateTo = plateTd.getBoundingClientRect();
        const wordTo = wordTd.getBoundingClientRect();
        const diffTo = diffTd.getBoundingClientRect();

        const plateClone = createFloatingLabel(plate, plateFrom, plateTo, "float-label-plate");
        const wordClone = createFloatingLabel(word, wordFrom, wordTo, "float-label-word");
        const diffText = (diffScore === null || diffScore <= 0) ? "â€”" : String(diffScore);
        const diffClone = createFloatingLabel(diffText, plateFrom, diffTo, "float-label-diff");

        // Next plate appears immediately (logic not blocked by animation)
        if (typeof onComplete === "function") {
            onComplete();
        }

        const animDuration = 400;
        setTimeout(() => {
            row.style.opacity = "1";

            [plateClone, wordClone, diffClone].forEach(clone => {
                if (clone && clone.parentNode) clone.parentNode.removeChild(clone);
            });
        }, animDuration);
    }

    // --------- MODAL: ALL VIABLE WORDS ---------
    function openWordsModal(plate) {
        if (!dictionaryReady) return;

        wordsModalTitleEl.textContent = `Plate: ${plate}`;
        wordsModalStatusEl.textContent = "Finding viable wordsâ€¦";
        wordsModalListEl.textContent = "";

        wordsModalBackdropEl.classList.add("show");

        const matches = [];
        for (const w of WORDS) {
            if (wordMatchesPlate(plate, w)) {
                matches.push(w);
            }
        }

        matches.sort();

        const countFromScan = matches.length;
        wordsModalStatusEl.textContent =
            `${countFromScan.toLocaleString()} viable words`;

        if (matches.length === 0) {
            wordsModalListEl.textContent = "(no viable words found)";
            return;
        }

        const frag = document.createDocumentFragment();
        for (const w of matches) {
            const line = document.createElement("div");
            line.className = "words-list-item";

            const indices = getPlateMatchIndices(plate, w) || [];
            const indexSet = new Set(indices);

            let html = "";
            for (let i = 0; i < w.length; i++) {
                const ch = w[i];
                if (indexSet.has(i)) {
                    html += `<span class="plate-letter-highlight">${ch}</span>`;
                } else {
                    html += ch;
                }
            }

            line.innerHTML = html;
            frag.appendChild(line);
        }

        wordsModalListEl.innerHTML = "";
        wordsModalListEl.appendChild(frag);
    }

    function closeWordsModal() {
        wordsModalBackdropEl.classList.remove("show");
    }

    // --------- GAME MODAL (START / END) ---------
    function openStartModal() {
        gameModalMode = "start";
        gameModalTitleEl.textContent = "License Plate Game â€“ Time Trial";
        gameModalBodyEl.innerHTML = `
            <p><strong>How it works:</strong></p>
            <ul>
                <li>You will see <strong>${TOTAL_PLATES}</strong> random license plates, one after another.</li>
                <li>Enter a word that contains the three plate letters <em>in order</em> (not necessarily consecutively).</li>
                <li>The first instance of each letter must come in order. If your plate is <strong>ABC</strong>, then the first A must appear before the first B or C.</li>
                <li>Example: plate <strong>PMS</strong> â€“ <strong>"promise"</strong> works, but <strong>"spams"</strong> does not ("spams" contains PMS, but the first S appears before the the first M).</li>
                <li>You can press <strong>Skip</strong>, but it adds an increasing time penalty: +5s, then +10s, +15s, ...</li>
                <li>Click any solved plate in the table to see <strong>all</strong> viable words for that plate.</li>
            </ul>
        `;

        const ready = dictionaryReady && (difficultyReady || PLATE_DIFFICULTY === null);
        gameModalPrimaryBtnEl.disabled = !ready;
        gameModalPrimaryBtnEl.textContent = ready ? "Start Game" : "Loading...";

        // In start mode there is no "See results"
        gameModalSecondaryBtnEl.style.display = "none";

        gameModalBackdropEl.classList.add("show");
    }

    function openEndModal(finalTimeSec) {
        gameModalMode = "end";
        gameModalTitleEl.textContent = "Run complete!";
        gameModalBodyEl.innerHTML = `
            <p>You solved <strong>${TOTAL_PLATES}</strong> plates in
            <strong>${finalTimeSec.toFixed(1)} seconds</strong> (including skip penalties).</p>
            <p>Want to go again and try to beat your time?</p>
        `;

        gameModalPrimaryBtnEl.disabled = false;
        gameModalPrimaryBtnEl.textContent = "Play again";

        // In end mode we show "See results"
        gameModalSecondaryBtnEl.style.display = "inline-block";
        gameModalSecondaryBtnEl.textContent = "See results";

        gameModalBackdropEl.classList.add("show");
    }

    function closeGameModal() {
        gameModalBackdropEl.classList.remove("show");
    }

    // --------- ACTIONS ---------
    function checkWord() {
        const rawWord = wordInputEl.value.trim();
        if (!rawWord) return;

        if (!gameStarted) {
            resultEl.textContent = "Press Start to begin the game.";
            resultEl.style.color = "red";
            return;
        }
        if (gameOver) {
            resultEl.textContent = "Game over. Press Play again to restart.";
            resultEl.style.color = "red";
            return;
        }
        if (plateLocked) {
            return;
        }

        if (!DICTIONARY.has(rawWord.toUpperCase())) {
            resultEl.textContent = `âŒ "${rawWord}" is not in the dictionary.`;
            resultEl.style.color = "red";
            return;
        }

        const matchIndices = getPlateMatchIndices(currentPlate, rawWord);
        if (!matchIndices) {
            resultEl.textContent = `âŒ "${rawWord}" does not match ${currentPlate}.`;
            resultEl.style.color = "red";
            return;
        }

        // Lock this plate so Enter spam can't double-submit
        plateLocked = true;
        checkButtonEl.disabled = true;
        skipButtonEl.disabled = true;
        wordInputEl.readOnly = true;

        solvedCount++;
        updateProgressDisplay();

        resultEl.textContent = `âœ… "${rawWord}" matches ${currentPlate}.`;
        resultEl.style.color = "green";

        const plate = currentPlate;
        const word = rawWord.toLowerCase();
        const diffScore = getPlateDifficultyScore(plate);

        addToHistoryWithAnimation(plate, word, matchIndices, null, diffScore, () => {
            if (solvedCount >= TOTAL_PLATES) {
                endGame();
            } else {
                pickRandomPlate(); // next plate appears immediately
            }
        });
    }

    function handleSkip() {
        if (!gameStarted) {
            resultEl.textContent = "Press Start to begin the game.";
            resultEl.style.color = "red";
            return;
        }
        if (gameOver) {
            resultEl.textContent = "Game over. Press Play again to restart.";
            resultEl.style.color = "red";
            return;
        }
        if (!currentPlate) return;
        if (plateLocked) {
            return;
        }

        // Lock this plate so skip can't be spammed
        plateLocked = true;
        checkButtonEl.disabled = true;
        skipButtonEl.disabled = true;
        wordInputEl.readOnly = true;

        // Escalating penalty: 5s, 10s, 15s, ...
        skipCount += 1;
        const added = skipCount * 5;
        penaltySeconds += added;

        resultEl.textContent = `â© Skipped ${currentPlate}. +${added}s penalty.`;
        resultEl.style.color = "orange";

        const plate = currentPlate;
        const penaltyLabel = `+${added}s (skipped)`;
        const diffScore = getPlateDifficultyScore(plate);
        const skipRect = skipButtonEl.getBoundingClientRect();

        addToHistoryWithAnimation(plate, penaltyLabel, null, skipRect, diffScore, () => {
            updateSkipButtonLabel();
            pickRandomPlate(); // next plate appears immediately
        });
    }

    // --------- INIT ---------
    startButtonEl.disabled = true;
    hideMainStartButton(); // hidden at first; appears as needed
    updateSkipButtonLabel();

    startButtonEl.addEventListener("click", startGame);
    checkButtonEl.addEventListener("click", checkWord);
    skipButtonEl.addEventListener("click", handleSkip);

    wordInputEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
            checkWord();
        }
    });

    wordsModalCloseBtnEl.addEventListener("click", closeWordsModal);
    wordsModalCloseBtnBottomEl.addEventListener("click", closeWordsModal);
    wordsModalBackdropEl.addEventListener("click", (e) => {
        if (e.target === wordsModalBackdropEl) {
            closeWordsModal();
        }
    });

    gameModalPrimaryBtnEl.addEventListener("click", () => {
        if (gameModalMode === "start") {
            startGame();
        } else if (gameModalMode === "end") {
            startGame();
        }
    });

    gameModalSecondaryBtnEl.addEventListener("click", () => {
        // "See results" just closes modal; results remain visible; Play again button is already on page
        closeGameModal();
    });

    gameModalCloseBtnEl.addEventListener("click", () => {
        closeGameModal();
        // If user closes the start modal without starting, show main "Start Game" button
        if (!gameStarted && !gameOver && gameModalMode === "start") {
            showStartGameButton();
        }
    });

    gameModalBackdropEl.addEventListener("click", (e) => {
        if (e.target === gameModalBackdropEl) {
            closeGameModal();
            // Same behavior when clicking outside to dismiss the start modal
            if (!gameStarted && !gameOver && gameModalMode === "start") {
                showStartGameButton();
            }
        }
    });

    loadDictionary();
    loadDifficulty();
    openStartModal();
</script>

</body>
</html>
