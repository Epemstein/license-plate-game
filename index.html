<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>License Plate Game v15</title>
    <style>
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            max-width: 1100px;
            margin: 40px;
            padding: 0 16px 40px;
            line-height: 1.5;
        }

        h1 {
            margin-top: 0;
            margin-bottom: 0.5rem;
        }

        /* Two-column layout */
        .layout {
            display: flex;
            align-items: flex-start;
            gap: 32px;
        }

        .left-panel {
            flex: 0 0 55%;
        }

        .right-panel {
            flex: 1;
        }

        .plate-wrapper {
            text-align: left;
            margin: 20px 0;
        }

        /* Cropped car image */
        .car-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
            max-width: 360px;
            height: 380px;
            overflow: hidden;
        }

        .car-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: center;
            display: block;
        }

        /* Your tuned plate position */
        .plate-text {
            position: absolute;
            left: 52.5%;
            bottom: 28.5%;
            transform: translateX(-50%);
            font-size: 2.3rem;
            letter-spacing: 0.45em;
            color: #333;
            font-weight: 600;
            text-transform: uppercase;
            text-shadow: 0 1px 2px rgba(0,0,0,0.25);
            pointer-events: none;
        }

        .controls {
            margin: 24px 0 12px;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .controls input[type="text"] {
            flex: 1;
            min-width: 180px;
            padding: 8px;
            font-size: 1rem;
        }

        button {
            padding: 8px 16px;
            font-size: 1rem;
            cursor: pointer;
        }

        #result {
            margin-top: 10px;
            font-weight: bold;
        }

        #debug {
            margin-top: 6px;
            font-size: 0.9rem;
            color: #666;
        }

        /* Solved plates table */
        .history-title {
            margin-top: 0;
            margin-bottom: 8px;
        }

        table {
            border-collapse: collapse;
            width: 100%;
            font-size: 0.95rem;
        }

        th, td {
            border-bottom: 1px solid #ddd;
            padding: 6px 8px;
            text-align: left;
        }

        th {
            background-color: #f3f4f6;
            font-weight: 600;
        }

        tr:nth-child(even) td {
            background-color: #f9fafb;
        }

        .history-empty {
            font-size: 0.9rem;
            color: #777;
            margin-top: 4px;
        }

        /* History rows fade in */
        .history-row {
            transition: opacity 0.3s ease;
        }

        @media (max-width: 800px) {
            .layout {
                flex-direction: column;
            }
            .left-panel, .right-panel {
                flex: 1 1 auto;
            }
        }

        /* Floating labels animation */
        .float-label {
            position: fixed;
            transform: translate(-50%, -50%);
            z-index: 1000;
            pointer-events: none;
            background: rgba(255, 255, 255, 0.95);
            padding: 2px 6px;
            border-radius: 4px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.25);
            font-size: 0.9rem;
            opacity: 1;
            transition:
                top 0.6s ease-out,
                left 0.6s ease-out,
                opacity 0.6s ease-out;
            white-space: nowrap;
        }

        .float-label-plate {
            font-size: 1.2rem;
            letter-spacing: 0.3em;
            font-weight: 600;
        }

        .float-label-word {
            font-weight: 500;
        }
    </style>
</head>
<body>
    <h1>License Plate Game v15</h1>

    <div class="layout">
        <!-- LEFT: game -->
        <div class="left-panel">
            <p>
                The plate letters must appear in your word in this order (not necessarily consecutively).<br>
                A word like <strong>spams</strong> does <em>not</em> work for <strong>PMS</strong> because the S appears before the M.
            </p>

            <div class="plate-wrapper">
                <div class="car-wrapper">
                    <!-- make sure this filename matches your uploaded image -->
                    <img src="car.png" alt="Car with license plate" class="car-image">
                    <div class="plate-text" id="plate">---</div>
                </div>
            </div>

            <div class="controls">
                <input id="wordInput" type="text" placeholder="Type a word">
                <button id="checkButton">Check word</button>
                <button id="newPlateButton">New plate</button>
            </div>

            <div id="result"></div>
            <div id="debug"></div>
        </div>

        <!-- RIGHT: history table -->
        <div class="right-panel">
            <h2 class="history-title">Solved plates</h2>
            <table>
                <thead>
                    <tr>
                        <th>Plate</th>
                        <th>Word</th>
                    </tr>
                </thead>
                <tbody id="historyBody">
                    <!-- rows added here -->
                </tbody>
            </table>
            <div id="historyEmpty" class="history-empty">
                Solve a plate to add it here.
            </div>
        </div>
    </div>

    <script>
        // ===== Globals =====
        let WORDS = [];
        let DICTIONARY = new Set();
        let dictionaryReady = false;
        let currentPlate = null;

        // Buckets for funky / normal words
        let FUNKY_WORDS = [];
        let NORMAL_WORDS = [];

        const TARGET_FUNKY_SHARE = 0.3; // ~30% plates with J/Q/X/Z

        const plateEl = document.getElementById("plate");
        const wordInputEl = document.getElementById("wordInput");
        const resultEl = document.getElementById("result");
        const debugEl = document.getElementById("debug");
        const historyBodyEl = document.getElementById("historyBody");
        const historyEmptyEl = document.getElementById("historyEmpty");

        // ===== Matching logic =====
        function wordMatchesPlate(plate, word) {
            plate = plate.toUpperCase();
            word = word.toUpperCase();

            let expectedPlateIndex = 0;

            for (let i = 0; i < word.length; i++) {
                const ch = word[i];
                const posInPlate = plate.indexOf(ch);

                if (posInPlate === -1) continue;

                if (posInPlate === expectedPlateIndex) {
                    expectedPlateIndex++;
                    if (expectedPlateIndex === plate.length) return true;
                } else if (posInPlate > expectedPlateIndex) {
                    return false;
                }
            }

            return false;
        }

        // ===== Plate generation from a single word =====
        function generatePlateFromWord(word) {
            const upper = word.toUpperCase();
            const len = upper.length;
            if (len < 3) return null;

            for (let attempt = 0; attempt < 40; attempt++) {
                const i = Math.floor(Math.random() * (len - 2));
                const j = i + 1 + Math.floor(Math.random() * (len - i - 2));
                const k = j + 1 + Math.floor(Math.random() * (len - j - 1));

                const a = upper[i], b = upper[j], c = upper[k];
                if (a === b || a === c || b === c) continue;

                const plate = a + b + c;
                if (wordMatchesPlate(plate, upper)) return plate;
            }

            return null;
        }

        function plateHasFunkyLetter(plate) {
            return /[JQXZ]/.test(plate);
        }

        // ===== Floating label helper =====
        function createFloatingLabel(text, fromRect, toRect, extraClass) {
            const el = document.createElement("div");
            el.textContent = text;
            el.className = "float-label " + (extraClass || "");

            // Start at center of fromRect
            const startX = fromRect.left + fromRect.width / 2;
            const startY = fromRect.top + fromRect.height / 2;

            // End at center of toRect
            const endX = toRect.left + toRect.width / 2;
            const endY = toRect.top + toRect.height / 2;

            el.style.left = startX + "px";
            el.style.top = startY + "px";

            document.body.appendChild(el);

            // Next frame: move to destination
            requestAnimationFrame(() => {
                el.style.left = endX + "px";
                el.style.top = endY + "px";
                el.style.opacity = "0";
            });

            return el;
        }

        // ===== Add solved plate to history with animation =====
        function addToHistoryWithAnimation(plate, word) {
            if (!plate || !word) return;

            historyEmptyEl.style.display = "none";

            // Create the real row (start invisible)
            const row = document.createElement("tr");
            row.className = "history-row";
            row.style.opacity = "0";

            const plateTd = document.createElement("td");
            const wordTd = document.createElement("td");
            plateTd.textContent = plate;
            wordTd.textContent = word;

            row.appendChild(plateTd);
            row.appendChild(wordTd);

            // Insert at top
            if (historyBodyEl.firstChild) {
                historyBodyEl.insertBefore(row, historyBodyEl.firstChild);
            } else {
                historyBodyEl.appendChild(row);
            }

            // Cap history length
            while (historyBodyEl.rows.length > 20) {
                historyBodyEl.removeChild(historyBodyEl.lastChild);
            }

            // Get bounding boxes
            const plateFrom = plateEl.getBoundingClientRect();
            const wordFrom = wordInputEl.getBoundingClientRect();
            const plateTo = plateTd.getBoundingClientRect();
            const wordTo = wordTd.getBoundingClientRect();

            // Create floating labels
            const plateClone = createFloatingLabel(plate, plateFrom, plateTo, "float-label-plate");
            const wordClone = createFloatingLabel(word, wordFrom, wordTo, "float-label-word");

            const animDuration = 650; // ms

            setTimeout(() => {
                // Fade in the real row
                row.style.opacity = "1";

                // Remove clones
                if (plateClone && plateClone.parentNode) plateClone.parentNode.removeChild(plateClone);
                if (wordClone && wordClone.parentNode) wordClone.parentNode.removeChild(wordClone);

                // Automatically move to next plate
                pickRandomPlate();
            }, animDuration);
        }

        // ===== Pick a random plate (with funky control) =====
        function pickRandomPlate() {
            if (!dictionaryReady) {
                resultEl.textContent = "Dictionary not loaded yet.";
                resultEl.style.color = "red";
                return;
            }

            if (WORDS.length === 0) {
                plateEl.textContent = "ERR";
                resultEl.textContent = "No words available. Check words.txt.";
                resultEl.style.color = "red";
                return;
            }

            const wantFunky = Math.random() < TARGET_FUNKY_SHARE;

            let sourceWords;
            if (wantFunky && FUNKY_WORDS.length > 0) {
                sourceWords = FUNKY_WORDS;
            } else if (!wantFunky && NORMAL_WORDS.length > 0) {
                sourceWords = NORMAL_WORDS;
            } else {
                sourceWords = WORDS; // fallback
            }

            for (let attempts = 0; attempts < 500; attempts++) {
                const word = sourceWords[Math.floor(Math.random() * sourceWords.length)];
                const plate = generatePlateFromWord(word);
                if (!plate) continue;

                const isFunky = plateHasFunkyLetter(plate);
                if (wantFunky && !isFunky) continue;
                if (!wantFunky && isFunky) continue;

                currentPlate = plate;
                plateEl.textContent = plate;
                resultEl.textContent = "";
                resultEl.style.color = "";
                wordInputEl.value = "";
                wordInputEl.focus();
                debugEl.textContent =
                    `Loaded ${WORDS.length.toLocaleString()} words. Funky plates target: ${(TARGET_FUNKY_SHARE * 100).toFixed(0)}%.`;
                return;
            }

            plateEl.textContent = "ERR";
            resultEl.textContent = "Could not generate plate.";
            resultEl.style.color = "red";
        }

        // ===== Load dictionary =====
        async function loadDictionary() {
            try {
                const response = await fetch("words.txt");
                const text = await response.text();

                WORDS = [];
                FUNKY_WORDS = [];
                NORMAL_WORDS = [];
                DICTIONARY = new Set();

                for (const line of text.split(/\r?\n/)) {
                    const w = line.trim().toLowerCase();
                    if (!w) continue;
                    if (!/^[a-z]+$/.test(w)) continue;
                    if (w.length < 3) continue;

                    WORDS.push(w);
                    DICTIONARY.add(w.toUpperCase());

                    if (/[jqxz]/.test(w)) {
                        FUNKY_WORDS.push(w);
                    } else {
                        NORMAL_WORDS.push(w);
                    }
                }

                dictionaryReady = true;
                pickRandomPlate();
            } catch (err) {
                resultEl.textContent = "Failed to load words.txt";
                resultEl.style.color = "red";
                console.error(err);
            }
        }

        // ===== Check guess =====
        function checkWord() {
            const rawWord = wordInputEl.value.trim();
            if (!rawWord) return;

            if (!DICTIONARY.has(rawWord.toUpperCase())) {
                resultEl.textContent = `❌ "${rawWord}" is not in the dictionary.`;
                resultEl.style.color = "red";
                return;
            }

            if (!wordMatchesPlate(currentPlate, rawWord)) {
                resultEl.textContent = `❌ "${rawWord}" does not match the plate order.`;
                resultEl.style.color = "red";
                return;
            }

            resultEl.textContent = `✅ Correct! "${rawWord}" matches ${currentPlate}.`;
            resultEl.style.color = "green";

            // Log success with animation and auto-new-plate
            addToHistoryWithAnimation(currentPlate, rawWord.toLowerCase());
        }

        // ===== Event listeners =====
        document.getElementById("checkButton").onclick = checkWord;
        document.getElementById("newPlateButton").onclick = pickRandomPlate;

        wordInputEl.addEventListener("keydown", (e) => {
            if (e.key === "Enter") checkWord();
        });

        // ===== Start =====
        loadDictionary();
    </script>
</body>
</html>
