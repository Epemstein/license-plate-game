<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plate Speller</title>
    <style>

        @keyframes pulse {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(245, 158, 11, 0.7);
            }
            50% {
                box-shadow: 0 0 0 8px rgba(245, 158, 11, 0);
            }
        }

        @font-face {
            font-family: "RoadgeekUS";
            src: url("fonts/Roadgeek.woff2") format("woff2");
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            max-width: 1100px;
            margin: 40px auto;
            padding: 0 16px 40px;
            line-height: 1.5;
        }

        h1 {
            margin-top: 0;
            margin-bottom: 0.5rem;
        }

        .layout {
            display: flex;
            align-items: flex-start;
            gap: 32px;
        }

        .left-panel { flex: 0 0 55%; }
        .right-panel { flex: 1; }

        .car-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
            max-width: 360px;
            height: 380px;
            overflow: hidden;
        }

        .car-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .plate-text {
            position: absolute;
            left: 52%;
            bottom: 8.5%; /* Moved down from 26% */
            transform: translateX(-50%);
            font-family: "RoadgeekUS", sans-serif;
            font-size: 3.5rem;
            letter-spacing: 0.33em;
            color: #222;
            font-weight: 600;
            text-transform: uppercase;
            text-shadow: 0 1px 2px rgba(0,0,0,0.35);
            pointer-events: none;
        }

        .difficulty {
            margin-top: 8px;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .diff-easy { color: #16a34a; }
        .diff-med  { color: #d97706; }
        .diff-hard { color: #dc2626; }

        .controls {
            margin: 24px 0 12px;
            display: flex;
            flex-direction: column; /* Buttons always under input */
            gap: 10px;
        }

        .controls input[type="text"] {
            width: 100%; /* Full width input */
            padding: 8px;
            font-size: 16px; /* 16px prevents iOS zoom */
        }
        
        .controls .button-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        /* Mobile only styles */
        @media (max-width: 768px) {
            /* Hide the debug/loaded text on mobile */
            #debug {
                display: none;
            }
            
            /* Make buttons bigger on mobile */
            .controls .button-row button {
                padding: 14px 20px;
                font-size: 16px;
            }
        }

        button {
            padding: 8px 14px;
            font-size: 0.95rem;
            cursor: pointer;
        }

        button:disabled {
            opacity: 0.6;
            cursor: default;
        }

        #startButton {
            /* Always visible now */
        }

        #chartButton {
            margin-top: 8px;
            padding: 6px 12px;
            font-size: 0.85rem;
            display: none;
        }

        #result {
            margin-top: 10px;
            font-weight: 600;
        }

        #debug {
            margin-top: 6px;
            font-size: 0.85rem;
            color: #6b7280;
        }

        #timerRow {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin-bottom: 8px;
            font-weight: 600;
            font-size: 0.95rem;
        }

        #timerDisplay { color: #111827; }
        #progressDisplay { color: #374151; }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-size: 0.95rem;
        }

        th, td {
            border-bottom: 1px solid #e5e7eb;
            padding: 6px 8px;
            text-align: left;
        }

        th {
            background-color: #f3f4f6;
            font-weight: 600;
        }

        tr:nth-child(even) td {
            background-color: #f9fafb;
        }

        .history-empty {
            font-size: 0.85rem;
            color: #6b7280;
            margin-top: 4px;
        }

        .plate-letter-highlight {
            color: #16a34a;
            font-weight: 700;
        }

        .clickable-plate {
            cursor: pointer;
            text-decoration: underline;
            text-decoration-style: dotted;
        }

        .clickable-plate:hover {
            text-decoration-style: solid;
        }

        /* Floating labels */
        .float-label {
            position: fixed;
            transform: translate(-50%, -50%);
            z-index: 999;
            pointer-events: none;
            background: rgba(255,255,255,0.95);
            padding: 3px 6px;
            border-radius: 4px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.25);
            opacity: 1;
            transition:
                top 0.4s ease-out,
                left 0.4s ease-out,
                opacity 0.4s ease-out;
            white-space: nowrap;
            font-size: 0.9rem;
        }

        .float-label-plate {
            font-size: 1.1rem;
            letter-spacing: 0.3em;
            font-weight: 600;
        }

        .float-label-word {
            font-weight: 600;
        }

        .float-label-diff {
            font-size: 0.8rem;
            font-weight: 700;
        }

        /* Modal base styles */
        .modal-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.45);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 900;
        }

        /* Explicit stacking order so words > chart > game */
        #gameModalBackdrop {
            z-index: 900;
        }
        #chartModalBackdrop {
            z-index: 950;
        }
        #wordsModalBackdrop {
            z-index: 1000;
        }

        .modal-backdrop.show {
            display: flex;
        }

        .modal {
            background: #ffffff;
            border-radius: 8px;
            max-width: 700px;
            width: 100%;
            max-height: 80vh;
            box-shadow: 0 10px 30px rgba(0,0,0,0.25);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .modal-header {
            padding: 10px 14px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #f3f4f6;
        }

        .modal-title {
            font-weight: 600;
            font-size: 1rem;
        }

        .modal-body {
            padding: 10px 14px;
            overflow-y: auto;
            font-size: 0.95rem;
        }

        .modal-footer {
            padding: 8px 14px;
            border-top: 1px solid #e5e7eb;
            text-align: right;
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }

        .modal-close-btn {
            border: none;
            background: transparent;
            font-size: 1.1rem;
            cursor: pointer;
        }

        .words-list {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            white-space: normal;
        }

        .words-list-item {
            display: block;
            margin-bottom: 2px;
        }

        .words-sort-controls {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 6px;
            font-size: 0.85rem;
        }

        .words-sort-label {
            color: #6b7280;
        }

        .words-sort-button {
            padding: 2px 8px;
            font-size: 0.8rem;
            border-radius: 9999px;
            border: 1px solid #d1d5db;
            background: #f9fafb;
            cursor: pointer;
        }

        .words-sort-button.active {
            background: #111827;
            color: #ffffff;
            border-color: #111827;
        }

        #resultsChart {
            width: 100%;
            min-height: 320px;
        }

        @media (max-width: 800px) {
            .layout {
                flex-direction: column;
            }
        }
    
        button#dailyChallengeBtn:hover {
            filter: brightness(0.9);
        }
        
        button#practiceBtn:hover {
            filter: brightness(0.9);
        }
        
        button#rulesBtn:hover {
            filter: brightness(0.9);
        }
    
        #wordInput:focus {
            outline: none;
            border: 2px solid #9370db;
            background: #faf5ff;
        }
    
        .blurred-score {
            filter: blur(5px);
            user-select: none;
        }
    
        /* Purple button hover effects */
        button[style*="background:#9370db"]:hover,
        button[style*="background: #9370db"]:hover,
        #compareRunsBtn:hover,
        #hideComparisonBtn:hover {
            background: #7d5bbe !important;
        }
    
        .clickable-plate:hover {
            color: #7d5bbe !important;
            cursor: pointer;
        }
    
        .plate-name-clickable:hover {
            color: #7d5bbe !important;
        }
        
        @keyframes pulseGlow {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(147, 112, 219, 0.4);
                transform: scale(1);
            }
            50% {
                box-shadow: 0 0 20px 5px rgba(147, 112, 219, 0.6);
                transform: scale(1.02);
            }
        }
        
        .pulse-button {
            animation: pulseGlow 2s ease-in-out infinite;
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
    <link rel="icon" type="image/png" href="favicon.png">
</head>
<body>

<h1>Plate Speller</h1>

<!-- Row 1: Game mode buttons -->
<div style="margin-bottom:10px;display:flex;gap:10px;">
    <button id="dailyChallengeBtn" style="padding:10px 20px;background:#fbbf24;border:2px solid #f59e0b;font-weight:bold;cursor:pointer;">Daily Challenge</button>
    <button id="practiceBtn" style="padding:10px 20px;background:#e9d5ff;border:2px solid #9370db;cursor:pointer;font-weight:bold;">Practice Mode</button>
    <button id="rulesBtn" style="padding:10px 20px;background:#e5e7eb;border:2px solid #9ca3af;cursor:pointer;font-weight:bold;">How to Play</button>
</div>

<!-- Row 2: Auth section -->
<div id="authSection" style="margin-bottom:20px;">
    <div id="authPlaceholder" style="padding:10px;background:#f3f4f6;border-radius:4px;color:#9ca3af;display:inline-block;">
        Loading...
    </div>
    <button id="signInBtn" onclick="signInWithGoogle()" style="display:none;padding:8px 16px;cursor:pointer;background:#4285f4;color:white;border:none;border-radius:4px;font-weight:600;">Sign In with Google</button>
    <div id="userInfo" style="display:none;padding:10px;background:#f3f4f6;border-radius:4px;display:inline-block;">
        Signed in: <strong id="userName"></strong>
        <button id="signOutBtn" onclick="firebase.auth().signOut()" style="margin-left:10px;padding:4px 8px;cursor:pointer;">Sign Out</button>
    </div>
    </div>
</div>
<div id="modeIndicator" style="padding:8px;background:#f3f4f6;border:2px dashed #d1d5db;border-radius:4px;margin-bottom:10px;font-weight:600;text-align:left;color:#000000;">Select a game mode above to begin</div>


<div class="layout">
    <!-- LEFT PANEL -->
    <div class="left-panel">
        <!-- Instructions removed -->

        <div class="car-wrapper">
            <img src="car.png" alt="Car with license plate" class="car-image">
            <div id="plate" class="plate-text">---</div>
        </div>

        <div id="difficultyLabel" class="difficulty diff-med" style="display:none;">
            Difficulty: ‚Äî
        </div>
        <div id="viableCountLabel" style="color:#6b7280; font-size:0.9rem; margin-top:2px;">
        </div>

        <div class="controls">
            <input id="wordInput" type="text" placeholder="Type a word" autocomplete="off">
            <div class="button-row">
                <button id="startButton">Start Game</button>
                <button id="checkButton">Check</button>
                <button id="skipButton">Skip +5s</button>
            </div>
        </div>

        <div id="result"></div>
        <button id="chartButton">View run chart</button>

        <div id="debug" style="color:#9ca3af;font-size:0.9rem;margin-top:10px;">Loading game data...</div>
    </div>

    <!-- RIGHT PANEL -->
    <div class="right-panel">
        <div id="timerRow">
            <span id="timerDisplay">Time: 0.0 s</span>
            <span id="progressDisplay">Solved: 0 / 10</span>
        </div>

        <h2>Solved Plates</h2>
        <table>
            <thead>
            <tr>
                <th>Plate</th>
                <th>Word / Penalty</th>
                <th>Time</th>
                <th>Difficulty</th>
            </tr>
            </thead>
            <tbody id="historyBody"></tbody>
        </table>
        <div id="historyEmpty" class="history-empty">
            No solved plates yet.
        </div>
    </div>
</div>

<!-- GAME START / END MODAL -->
<div id="gameModalBackdrop" class="modal-backdrop">
    <div class="modal">
        <div class="modal-header">
            <div class="modal-title" id="gameModalTitle">License Plate Game</div>
            <button class="modal-close-btn" id="gameModalCloseBtn" aria-label="Close">&times;</button>
        </div>
        <div class="modal-body" id="gameModalBody">
            <!-- Filled dynamically -->
        </div>
        <div class="modal-footer">
            <button id="gameModalSecondaryBtn" style="display:none;">View chart</button>
            <button id="gameModalPrimaryBtn">Start Game</button>
        </div>
    </div>
</div>

<!-- MODAL: Viable words for a plate -->
<div id="wordsModalBackdrop" class="modal-backdrop">
    <div class="modal">
        <div class="modal-header">
            <div class="modal-title" id="wordsModalTitle">Plate: ---</div>
            <button class="modal-close-btn" id="wordsModalCloseBtn" aria-label="Close">&times;</button>
        </div>
        <div class="modal-body">
            <div id="wordsModalStatus" style="margin-bottom:6px; color:#6b7280; font-size:0.9rem;">
                Loading...
            </div>
            <div id="wordsModalSortControls" class="words-sort-controls">
                <span class="words-sort-label">Sort:</span>
                <button id="wordsSortAlphaBtn" class="words-sort-button active">A‚ÄìZ</button>
                <button id="wordsSortLengthBtn" class="words-sort-button">Shortest ‚Üí longest</button>
            </div>
            <div id="wordsModalList" class="words-list"></div>
        </div>
        <div class="modal-footer">
            <button id="wordsModalCloseBtnBottom">Close</button>
        </div>
    </div>
</div>

<!-- MODAL: End-of-game chart -->
<div id="chartModalBackdrop" class="modal-backdrop">
    <div class="modal">
        <div class="modal-header">
            <div class="modal-title">Run breakdown</div>
            <button class="modal-close-btn" id="chartModalCloseBtn" aria-label="Close">&times;</button>
        </div>
        <div class="modal-body">
            <canvas id="resultsChart"></canvas>
            <div style="margin-top:8px; font-size:0.85rem; color:#6b7280;">
                Blue = thinking time, red = skip penalty. Click a bar or point to see all viable words for that plate.
            </div>
        </div>
        <div class="modal-footer">
            <button id="chartModalCloseBtnBottom">Close</button>
        </div>
    </div>
</div>

<script>

    // === FIREBASE ===
    const firebaseConfig = {
        apiKey: "AIzaSyBEa4aJf-cB25uzvEXdpNf1bG5kOOL5PXs",
        authDomain: "license-plate-game-2ea96.firebaseapp.com",
        databaseURL: "https://license-plate-game-2ea96-default-rtdb.firebaseio.com",
        projectId: "license-plate-game-2ea96",
        storageBucket: "license-plate-game-2ea96.firebasestorage.app",
        messagingSenderId: "247985429580",
        appId: "1:247985429580:web:4927cee2ca3581b569a8e9"
    };
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const database = firebase.database();
    let gameMode = 'practice';
    let currentUser = null;
    let dailyPlateSequence = null;
    let currentViewingDate = null; // Track which date we're viewing

    auth.onAuthStateChanged(async (user) => {
        currentUser = user;
        const signInBtn = document.getElementById('signInBtn');
        const userInfo = document.getElementById('userInfo');
        if (user) {
            signInBtn.style.display = 'none';
            document.getElementById('authPlaceholder').style.display = 'none';
                userInfo.style.display = 'block';
            document.getElementById('userName').textContent = user.displayName || user.email;
            
            // Register user for H2H (without requiring permissions - will use users node later)
            try {
                await database.ref(`users/${user.uid}`).set({
                    displayName: user.displayName || user.email,
                    email: user.email,
                    lastSeen: Date.now()
                });
            } catch (error) {
                console.log('Could not register user (may need Firebase permissions)', error);
            }
            
            // Check for abandoned challenges
            checkAbandonedChallenges(user.uid);
            
            // Load H2H challenges to update notification badge
            loadH2HChallenges();
            
            // Check if there's a challenge ID in the URL
            const urlParams = new URLSearchParams(window.location.search);
            const challengeId = urlParams.get('challenge');
            if (challengeId) {
                // User just signed in with a challenge link - load the challenge
                setTimeout(() => {
                    document.getElementById('h2hTab').click();
                    setTimeout(() => {
                        playChallenge(challengeId);
                    }, 500);
                }, 500);
            }
        } else {
            document.getElementById('authPlaceholder').style.display = 'none';
                signInBtn.style.display = 'inline-block';
            userInfo.style.display = 'none';
        }
    });

    function getTodayString() {
        const d = new Date();
        return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
    }

    function seededRandom(seed) {
        let v = seed;
        return () => { v = (v*9301+49297)%233280; return v/233280; };
    }

    function generateDailyPlates(dateStr) {
        const seed = dateStr.split('-').reduce((a,v)=>a+parseInt(v),0);
        const rng = seededRandom(seed);
        if (!platesReady || !ALL_PLATES.length) return [];
        
        // Use weighted difficulty selection like the original game
        const dailyPlates = [];
        const usedPlates = new Set();
        
        while (dailyPlates.length < 200 && usedPlates.size < ALL_PLATES.length) {
            // Pick a difficulty band using the same probabilities as the game
            const r = rng();
            let band;
            if (r < 0.40) band = "very_easy";
            else if (r < 0.60) band = "easy";
            else if (r < 0.75) band = "medium";
            else if (r < 0.90) band = "difficult";
            else if (r < 0.95) band = "hard";
            else if (r < 0.98) band = "very_hard";
            else band = "impossible";
            
            // Get all plates in this band that haven't been used
            const bandPlates = ALL_PLATES.filter(plate => {
                if (usedPlates.has(plate)) return false;
                const diff = PLATE_DIFFICULTY && PLATE_DIFFICULTY[plate] ? PLATE_DIFFICULTY[plate].difficulty : null;
                if (!diff) return false;
                
                if (band === "very_easy" && diff >= 0 && diff <= 10) return true;
                if (band === "easy" && diff >= 11 && diff <= 34) return true;
                if (band === "medium" && diff >= 35 && diff <= 49) return true;
                if (band === "difficult" && diff >= 50 && diff <= 79) return true;
                if (band === "hard" && diff >= 80 && diff <= 88) return true;
                if (band === "very_hard" && diff >= 89 && diff <= 96) return true;
                if (band === "impossible" && diff >= 97 && diff <= 100) return true;
                return false;
            });
            
            // Pick a random plate from this band
            if (bandPlates.length > 0) {
                const idx = Math.floor(rng() * bandPlates.length);
                const chosen = bandPlates[idx];
                dailyPlates.push(chosen);
                usedPlates.add(chosen);
            }
        }
        
        return dailyPlates;
    }

    async function signInWithGoogle() {
        try {
            await auth.signInWithPopup(new firebase.auth.GoogleAuthProvider());
            return true;
        } catch(e) {
            alert('Sign in failed: '+e.message);
            return false;
        }
    }

    async function checkIfPlayedToday() {
        if (!currentUser) return false;
        const t = getTodayString();
        const s1 = await database.ref(`scores/${t}/${currentUser.uid}`).once('value');
        if (s1.exists()) return true;
        const s2 = await database.ref(`started/${t}/${currentUser.uid}`).once('value');
        return s2.exists();
    }

    async function saveScore(time,solved,skipped) {
        if (!currentUser || gameMode!=='daily') return;
        const today = getTodayString();
        
        // Prepare game history for saving
        const historyData = gameHistory.map(entry => ({
            plate: entry.plate,
            word: entry.word,
            skipped: entry.skipped || false,
            thinkingSeconds: Math.floor(entry.thinkingSeconds * 10) / 10,
            penaltySeconds: entry.penaltySeconds || 0
        }));
        
        await database.ref(`scores/${today}/${currentUser.uid}`).set({
            userId: currentUser.uid,
            userName: currentUser.displayName || currentUser.email,
            totalTime: Math.floor(time*10)/10,
            solved: solved,
            skipped: skipped,
            timestamp: Date.now(),
            history: historyData
        });
        
        // Refresh leaderboard to unlock View buttons and Compare button
        // Small delay to ensure Firebase write propagates
        setTimeout(() => {
            displayLeaderboard(today);
        }, 500);
    }


    // Load a specific player's run history (only when View is clicked)
    async function loadPlayerHistory(userId, dateStr) {
        const ref = database.ref(`scores/${dateStr}/${userId}`);
        const snapshot = await ref.once('value');
        if (!snapshot.exists()) return null;
        return snapshot.val();
    }

    async function loadLeaderboard(dateStr) {
        const ref = database.ref(`scores/${dateStr}`);
        const snapshot = await ref.once('value');
        if (!snapshot.exists()) return [];
        
        const arr = [];
        const rawData = snapshot.val();
        
        // Process each user's score WITHOUT including history
        for (const userId in rawData) {
            const data = rawData[userId];
            // DON'T include history to prevent cheating via console
            arr.push({
                userId: data.userId,
                userName: data.userName,
                totalTime: data.totalTime,
                solved: data.solved,
                skipped: data.skipped,
                timestamp: data.timestamp
                // history is intentionally excluded
            });
        }
        
        arr.sort((a, b) => a.totalTime - b.totalTime);
        
        // Only log count, not actual data
        return arr;
    }



    // Toggle comparison table
    function toggleCompareTable() {
        const btn = document.getElementById('compareRunsBtn');
        
        // Don't do anything if button is disabled (locked)
        if (btn.disabled) {
            return;
        }
        
        const container = document.getElementById('comparisonTableContainer');
        if (container.style.display === 'none') {
            container.style.display = 'block';
            btn.textContent = 'Hide Comparison';
            buildComparisonTable();
        } else {
            container.style.display = 'none';
            btn.textContent = 'Compare All Runs';
        }
    }
    window.toggleCompareTable = toggleCompareTable;
    
    // Get color based on time (gradient)
    function getTimeColor(seconds) {
        if (seconds <= 1.5) return '#22c55e'; // green (under 1.5s)
        if (seconds >= 30) return '#ef4444'; // dark red (30s+)
        
        if (seconds <= 6) {
            // Green to white (1.5s ‚Üí 6s)
            const ratio = (seconds - 1.5) / 4.5;
            const r = Math.round(34 + (255 - 34) * ratio);
            const g = Math.round(197 + (255 - 197) * ratio);
            const b = Math.round(94 + (255 - 94) * ratio);
            return `rgb(${r},${g},${b})`;
        } else {
            // White to red (6s ‚Üí 30s)
            const ratio = (seconds - 6) / 24;
            const r = 255;
            const g = Math.round(255 - (255 - 68) * ratio);
            const b = Math.round(255 - (255 - 68) * ratio);
            return `rgb(${r},${g},${b})`;
        }
    }
    
    // Build comparison table
    async function buildComparisonTable() {
        const contentEl = document.getElementById('comparisonTable');
        contentEl.innerHTML = 'Loading comparison...';
        
        try {
            // Use the date currently being viewed, not always today
            const dateStr = currentViewingDate || getTodayString();
            console.log('Building comparison for date:', dateStr);
            const scores = await loadLeaderboard(dateStr);
            
            if (scores.length === 0) {
                contentEl.innerHTML = '<p style="text-align:center;color:#6b7280;">No data available</p>';
                return;
            }
            
            // Load full history for each player on-demand
            const playersData = [];
            let maxPlates = 0;
            
            for (const score of scores) {
                const playerData = await loadPlayerHistory(score.userId, dateStr);
                if (playerData && playerData.history && playerData.history.length > 0) {
                    maxPlates = Math.max(maxPlates, playerData.history.length);
                    playersData.push({
                        name: score.userName,
                        time: score.totalTime,
                        history: playerData.history
                    });
                }
            }
            
            if (playersData.length === 0) {
                contentEl.innerHTML = '<p style="text-align:center;color:#6b7280;">No detailed history available</p>';
                return;
            }
            
            // Collect all plate names in order
            const plateNames = [];
            for (let i = 0; i < maxPlates; i++) {
                let plateName = '‚Äî';
                for (const player of playersData) {
                    if (i < player.history.length && player.history[i].plate) {
                        plateName = player.history[i].plate;
                        break;
                    }
                }
                plateNames.push(plateName);
            }
            
            // Build table
            let html = '<div style="max-height:620px;overflow:auto;"><table style="border-collapse:collapse;font-size:0.9rem;">';
            
            // Calculate statistics for each plate first
            const plateStats = [];
            for (let i = 0; i < maxPlates; i++) {
                let totalTime = 0;
                let count = 0;
                let skipCount = 0;
                
                playersData.forEach(player => {
                    if (i < player.history.length) {
                        count++;
                        const entry = player.history[i];
                        const time = entry.skipped 
                            ? (entry.thinkingSeconds || 0) + entry.penaltySeconds 
                            : entry.thinkingSeconds;
                        totalTime += time;
                        if (entry.skipped) skipCount++;
                    }
                });
                
                const avgTime = count > 0 ? (totalTime / count).toFixed(1) : '‚Äî';
                const skipRate = count > 0 ? Math.round((skipCount / count) * 100) : 0;
                plateStats.push({ avgTime, skipRate });
            }
            
            // Header row with plate names and stats
            html += '<thead style="position:sticky;top:0;z-index:15;background:#f3f4f6;box-shadow:0 2px 4px rgba(0,0,0,0.1);"><tr style="background:#f3f4f6;">';
            html += '<th style="padding:8px;text-align:left;position:sticky;left:0;background:#f3f4f6;z-index:20;min-width:120px;">Player</th>';
            for (let i = 0; i < maxPlates; i++) {
                const stats = plateStats[i];
                const skipColor = stats.skipRate > 50 ? '#dc2626' : stats.skipRate > 25 ? '#f59e0b' : '#16a34a';
                html += `<th style="padding:8px;text-align:center;min-width:100px;">`;
                html += `<div class="plate-name-clickable" onclick="showViableWordsForPlate('${plateNames[i]}')" style="font-weight:bold;font-size:1rem;cursor:pointer;display:inline-block;" title="Click to see all viable words">${plateNames[i]}</div>`;
                html += `<div style="font-size:0.75rem;color:#6b7280;margin-top:2px;">Avg: ${stats.avgTime}s</div>`;
                html += `<div style="font-size:0.75rem;color:${skipColor};margin-top:1px;">Skip: ${stats.skipRate}%</div>`;
                html += `</th>`;
            }
            html += '</tr></thead><tbody>';
            
            // Player rows
            playersData.forEach((player, idx) => {
                const bg = idx % 2 === 0 ? '#fff' : '#f9fafb';
                
                html += `<tr style="background:${bg};">`;
                html += `<td style="padding:12px;font-weight:bold;position:sticky;left:0;background:${bg};z-index:5;white-space:nowrap;">${player.name}<br><span style="font-size:0.85rem;color:#6b7280;">(${player.time.toFixed(1)}s)</span></td>`;
                
                // Combined word + time cells with gradient
                for (let i = 0; i < maxPlates; i++) {
                    if (i < player.history.length) {
                        const entry = player.history[i];
                        const word = entry.skipped ? '‚ùå' : entry.word;
                        
                        // Calculate total time (thinking + penalty for skips)
                        const totalTime = entry.skipped 
                            ? (entry.thinkingSeconds || 0) + entry.penaltySeconds 
                            : entry.thinkingSeconds;
                        
                        const displayTime = entry.skipped 
                            ? `${totalTime.toFixed(1)}s` 
                            : `${totalTime.toFixed(1)}s`;
                        
                        // Skip cells get black background, others get gradient color
                        const bgColor = entry.skipped ? '#000000' : getTimeColor(totalTime);
                        const textColor = entry.skipped ? '#ffffff' : (totalTime > 15 ? '#fff' : '#000');
                        
                        // Tooltip info
                        const tooltip = entry.skipped 
                            ? `Skipped\nThinking: ${(entry.thinkingSeconds || 0).toFixed(1)}s\nPenalty: +${entry.penaltySeconds}s\nTotal: ${totalTime.toFixed(1)}s`
                            : `Word: ${entry.word}\nTime: ${totalTime.toFixed(1)}s`;
                        
                        html += `<td style="padding:8px;text-align:center;background:${bgColor};color:${textColor};border:2px solid #fff;" title="${tooltip}">`;
                        html += `<div style="font-weight:600;font-size:0.9rem;">${word}</div>`;
                        html += `<div style="font-size:0.85rem;margin-top:2px;">${displayTime}</div>`;
                        html += `</td>`;
                    } else {
                        html += `<td style="padding:8px;background:#f3f4f6;border:2px solid #fff;"></td>`;
                    }
                }
                html += '</tr>';
            });
            
            // Stats are now in the header, so remove these rows
            
            html += '</tbody></table>';
            contentEl.innerHTML = html;
            
        } catch (error) {
            console.error('Error building comparison:', error);
            contentEl.innerHTML = '<p style="text-align:center;color:#dc2626;">Error loading comparison</p>';
        }
    }

    async function displayLeaderboard(dateStr) {
        // displayLeaderboard called
        currentViewingDate = dateStr; // Track the date we're viewing
        updateNavigationButtons(); // Update button states
        
        // Declare these at function level so they're accessible everywhere
        let userHasPlayed = false;
        let isPastDate = false;
        
        // Auto-collapse comparison table when date changes
        const comparisonContainer = document.getElementById('comparisonTableContainer');
        const compareBtn = document.getElementById('compareRunsBtn');
        if (comparisonContainer && comparisonContainer.style.display === 'block') {
            comparisonContainer.style.display = 'none';
            if (compareBtn) compareBtn.textContent = 'Compare All Runs';
        }
        
        document.getElementById('leaderboardTitle').textContent = `üèÜ Daily Leaderboard - ${dateStr}`;
        document.getElementById('leaderboardContent').innerHTML = 'Loading...';
        try {
            const scores = await loadLeaderboard(dateStr);
            if (!scores.length) {
                document.getElementById('leaderboardContent').innerHTML = '<p style="text-align:center;color:#6b7280;padding:20px;">No scores for this date</p>';
                return;
            }
            // Calculate these ONCE before the loop
            userHasPlayed = currentUser && scores.some(score => score.userId === currentUser.uid);
            isPastDate = dateStr !== getTodayString();
            
            let h = '<table style="width:100%;border-collapse:collapse;"><thead><tr style="background:#f3f4f6;">';
            h += '<th style="padding:8px;">Rank</th><th style="padding:8px;">Player</th><th style="padding:8px;text-align:right;">Time</th><th style="padding:8px;text-align:center;">Details</th></tr></thead><tbody>';
            scores.forEach((s,i)=>{
                const bg = i===0 ? '#fef3c7' : (i%2?'#fff':'#f9fafb'); // Gold for 1st, alternating grey for rest
                h+=`<tr style="background:${bg};"><td style="padding:8px;font-weight:bold;">#${i+1}</td><td style="padding:8px;">${s.userName}</td><td style="padding:8px;text-align:right;font-weight:600;">${(userHasPlayed || isPastDate) ? s.totalTime.toFixed(1) + 's' : '<span class="blurred-score">' + s.totalTime.toFixed(1) + 's</span>'}</td>`;
                // Use the userHasPlayed value calculated before the loop
                if (userHasPlayed || isPastDate) {
                    h+=`<td style="padding:8px;text-align:center;"><button onclick="viewPlayerRun('${s.userId}','${dateStr}','${s.userName.replace(/'/g,"\'")}',${s.totalTime},${s.solved||0},${s.skipped||0})" style="padding:4px 12px;cursor:pointer;background:#9370db;color:white;border:1px solid #7d5bbe;border-radius:4px;">View</button></td>`;
                } else {
                    h+=`<td style="padding:8px;text-align:center;"><span style="color:#9ca3af;font-size:0.85rem;">üîí Complete daily to unlock</span></td>`;
                }
                h+=`</tr>`;
            });
            h += '</tbody></table>';
            document.getElementById('leaderboardContent').innerHTML = h;
            
        } catch(e) {
            console.error('Leaderboard error:', e);
            document.getElementById('leaderboardContent').innerHTML = '<p style="text-align:center;color:#dc2626;padding:20px;">Error loading</p>';
        }
        
        // Update Compare button state (grey out if locked) - AFTER try/catch
        try {
            const compareBtn = document.getElementById('compareRunsBtn');
            console.log('=== COMPARE BUTTON STATE ===');
            console.log('currentUser:', currentUser ? currentUser.uid : 'null');
            console.log('userHasPlayed:', userHasPlayed);
            console.log('isPastDate:', isPastDate);
            
            if (userHasPlayed || isPastDate) {
                // Unlocked
                compareBtn.disabled = false;
                compareBtn.style.background = '#9370db';
                compareBtn.style.cursor = 'pointer';
                compareBtn.style.opacity = '1';
                compareBtn.textContent = 'Compare All Runs';
                console.log('‚Üí Button UNLOCKED');
            } else {
                // Locked
                compareBtn.disabled = true;
                compareBtn.style.background = '#9ca3af';
                compareBtn.style.cursor = 'not-allowed';
                compareBtn.style.opacity = '0.6';
                compareBtn.textContent = 'üîí Complete Daily to Compare';
                console.log('‚Üí Button LOCKED');
            }
        } catch(btnError) {
            console.error('Button state error:', btnError);
        }
    }
    // === END FIREBASE ===

    // --------- CONFIG ---------
    const TOTAL_PLATES = 10;

    const VERY_EASY_PROB = 0.40; // 0‚Äì10
    const EASY_PROB      = 0.20; // 11‚Äì34
    const MEDIUM_PROB    = 0.15; // 35‚Äì49
    const DIFFICULT_PROB = 0.15; // 50‚Äì79
    const HARD_PROB      = 0.05; // 80‚Äì88
    const VERY_HARD_PROB = 0.03; // 89‚Äì96
    const IMPOSSIBLE_PROB= 0.01; // 97‚Äì100

    const BAND_NAMES = [
        "very_easy",
        "easy",
        "medium",
        "difficult",
        "hard",
        "very_hard",
        "impossible"
    ];

    // --------- GLOBAL STATE ---------
    let WORDS = [];
    let DICTIONARY = new Set();
    let dictionaryReady = false;

    let PLATE_DIFFICULTY = null;
    let difficultyReady = false;

    let ALL_PLATES = [];
    let platesReady = false;

    let VERY_EASY_PLATES = [];
    let EASY_PLATES      = [];
    let MEDIUM_PLATES    = [];
    let DIFFICULT_PLATES = [];
    let HARD_PLATES      = [];
    let VERY_HARD_PLATES = [];
    let IMPOSSIBLE_PLATES= [];

    let usedPlates = new Set();
    let currentPlate = null;

    let gameStarted = false;
    let gameOver = false;
    let solvedCount = 0;
    let startTime = null;
    let penaltySeconds = 0;
    let timerIntervalId = null;

    let skipCount = 0;
    let plateLocked = false;

    let gameModalMode = "start";
    let hasStartedOnce = false;

    let plateStartTime = null;
    let gameHistory = [];

    let currentWordsModalMatches = [];
    let currentWordsModalPlate = null;
    let currentWordsModalSortMode = "alpha";

    // DOM refs
    const plateEl = document.getElementById("plate");
    const difficultyLabelEl = document.getElementById("difficultyLabel");
    const viableCountLabelEl = document.getElementById("viableCountLabel");
    const wordInputEl = document.getElementById("wordInput");
    const resultEl = document.getElementById("result");
    const debugEl = document.getElementById("debug");
    const timerDisplayEl = document.getElementById("timerDisplay");
    const progressDisplayEl = document.getElementById("progressDisplay");
    const historyBodyEl = document.getElementById("historyBody");
    const historyEmptyEl = document.getElementById("historyEmpty");
    const startButtonEl = document.getElementById("startButton");
    const checkButtonEl = document.getElementById("checkButton");
    const skipButtonEl = document.getElementById("skipButton");
    const chartButtonEl = document.getElementById("chartButton");

    const gameModalBackdropEl = document.getElementById("gameModalBackdrop");
    const gameModalTitleEl = document.getElementById("gameModalTitle");
    const gameModalBodyEl = document.getElementById("gameModalBody");
    const gameModalPrimaryBtnEl = document.getElementById("gameModalPrimaryBtn");
    const gameModalSecondaryBtnEl = document.getElementById("gameModalSecondaryBtn");
    const gameModalCloseBtnEl = document.getElementById("gameModalCloseBtn");

    const wordsModalBackdropEl = document.getElementById("wordsModalBackdrop");
    const wordsModalTitleEl = document.getElementById("wordsModalTitle");
    const wordsModalStatusEl = document.getElementById("wordsModalStatus");
    const wordsModalListEl = document.getElementById("wordsModalList");
    const wordsModalCloseBtnEl = document.getElementById("wordsModalCloseBtn");
    const wordsModalCloseBtnBottomEl = document.getElementById("wordsModalCloseBtnBottom");
    const wordsSortAlphaBtnEl = document.getElementById("wordsSortAlphaBtn");
    const wordsSortLengthBtnEl = document.getElementById("wordsSortLengthBtn");

    const chartModalBackdropEl = document.getElementById("chartModalBackdrop");
    const chartModalCloseBtnEl = document.getElementById("chartModalCloseBtn");
    const chartModalCloseBtnBottomEl = document.getElementById("chartModalCloseBtnBottom");
    const resultsChartCanvas = document.getElementById("resultsChart");
    let resultsChart = null;

    // --------- LOADING ---------
    async function loadDictionary() {
        try {
            const res = await fetch("words.txt");
            const text = await res.text();

            WORDS = [];
            DICTIONARY = new Set();

            for (const line of text.split(/\r?\n/)) {
                const w = line.trim().toLowerCase();
                if (!w) continue;
                if (!/^[a-z]+$/.test(w)) continue;
                if (w.length < 3) continue;

                WORDS.push(w);
                DICTIONARY.add(w.toUpperCase());
            }

            dictionaryReady = true;
            debugEl.textContent = `Loaded ${WORDS.length.toLocaleString()} words.`;

            tryBuildPlateList();
        } catch (err) {
            console.error(err);
            resultEl.textContent = "Failed to load words.txt.";
            resultEl.style.color = "red";
        }
    }

    async function loadDifficulty() {
        try {
            const res = await fetch("plate_difficulty.json?v=2");
            PLATE_DIFFICULTY = await res.json();
            difficultyReady = true;

            tryBuildPlateList();
        } catch (err) {
            console.warn("Difficulty JSON not loaded:", err);
            PLATE_DIFFICULTY = null;
            difficultyReady = false;
        } finally {
            maybeEnableStart();
        }
    }

    function tryBuildPlateList() {
        if (!dictionaryReady || !PLATE_DIFFICULTY || platesReady) return;

        const all = [];

        const ve = [];
        const e  = [];
        const m  = [];
        const d  = [];
        const h  = [];
        const vh = [];
        const im = [];

        for (const plate of Object.keys(PLATE_DIFFICULTY)) {
            const entry = PLATE_DIFFICULTY[plate];

            if (DICTIONARY.has(plate)) continue;

            let diff = (entry && typeof entry.difficulty === "number")
                ? entry.difficulty
                : 50;

            all.push(plate);

            if (diff <= 10) {
                ve.push(plate);
            } else if (diff <= 34) {
                e.push(plate);
            } else if (diff <= 49) {
                m.push(plate);
            } else if (diff <= 79) {
                d.push(plate);
            } else if (diff <= 88) {
                h.push(plate);
            } else if (diff <= 96) {
                vh.push(plate);
            } else {
                im.push(plate);
            }
        }

        ALL_PLATES        = all;
        VERY_EASY_PLATES  = ve;
        EASY_PLATES       = e;
        MEDIUM_PLATES     = m;
        DIFFICULT_PLATES  = d;
        HARD_PLATES       = h;
        VERY_HARD_PLATES  = vh;
        IMPOSSIBLE_PLATES = im;

        platesReady = true;

        debugEl.textContent += ` | ${ALL_PLATES.length.toLocaleString()} plates`;

        maybeEnableStart();
    }

    function maybeEnableStart() {
        const ready = dictionaryReady && difficultyReady && platesReady;

        startButtonEl.disabled = !ready;

        if (gameModalMode === "start") {
            gameModalPrimaryBtnEl.disabled = !ready;
            gameModalPrimaryBtnEl.textContent = ready ? "Start Game" : "Loading...";
        }
    }

    // --------- PLATE MATCHING ---------
    function getPlateMatchIndices(plate, word) {
        plate = plate.toUpperCase();
        const upperWord = word.toUpperCase();

        let expectedPlateIndex = 0;
        const matchedIndices = [];

        for (let i = 0; i < upperWord.length; i++) {
            const ch = upperWord[i];
            const posInPlate = plate.indexOf(ch);

            if (posInPlate === -1) continue;

            if (posInPlate === expectedPlateIndex) {
                matchedIndices.push(i);
                expectedPlateIndex++;
                if (expectedPlateIndex === plate.length) {
                    return matchedIndices;
                }
            } else if (posInPlate > expectedPlateIndex) {
                return null;
            } else {
                continue;
            }
        }
        return null;
    }

    function wordMatchesPlate(plate, word) {
        return getPlateMatchIndices(plate, word) !== null;
    }

    function computeJsViableCount(plate) {
        if (!dictionaryReady || !plate) return 0;
        let count = 0;
        for (const w of WORDS) {
            if (wordMatchesPlate(plate, w)) {
                count++;
            }
        }
        return count;
    }

    // --------- PLATE SELECTION ---------
    function getBandPool(bandName) {
        switch (bandName) {
            case "very_easy":   return VERY_EASY_PLATES;
            case "easy":        return EASY_PLATES;
            case "medium":      return MEDIUM_PLATES;
            case "difficult":   return DIFFICULT_PLATES;
            case "hard":        return HARD_PLATES;
            case "very_hard":   return VERY_HARD_PLATES;
            case "impossible":  return IMPOSSIBLE_PLATES;
            default:            return [];
        }
    }

    function pickRandomPlateFromBand(bandName) {
        const poolRef = getBandPool(bandName);
        const remaining = poolRef.filter(p => !usedPlates.has(p));
        if (remaining.length === 0) return null;

        const idx = Math.floor(Math.random() * remaining.length);
        return remaining[idx];
    }

    function choosePrimaryBand() {
        const r = Math.random();
        let threshold = 0;

        threshold += VERY_EASY_PROB;
        if (r < threshold) return "very_easy";

        threshold += EASY_PROB;
        if (r < threshold) return "easy";

        threshold += MEDIUM_PROB;
        if (r < threshold) return "medium";

        threshold += DIFFICULT_PROB;
        if (r < threshold) return "difficult";

        threshold += HARD_PROB;
        if (r < threshold) return "hard";

        threshold += VERY_HARD_PROB;
        if (r < threshold) return "very_hard";

        return "impossible";
    }

    function pickRandomPlate() {
        console.log('=== pickRandomPlate called ===');
        console.log('gameMode:', gameMode, 'solvedCount:', solvedCount, 'usedPlates.size:', usedPlates ? usedPlates.size : 'null');
        if (!platesReady || !ALL_PLATES.length) {
            resultEl.textContent = "No plates available.";
            resultEl.style.color = "red";
            return;
        }
        if ((gameMode==='daily' || gameMode==='h2h_challenge') && dailyPlateSequence && dailyPlateSequence.length) {
            const idx = usedPlates.size;
            console.log('Using sequence mode! Index:', idx, 'Sequence length:', dailyPlateSequence.length);
            
            // Check if we've run out of plates
            if (idx>=dailyPlateSequence.length) { 
                // Ran out of plates! This is a problem.
                // Show error and end the game
                resultEl.textContent = "Ran out of plates! This shouldn't happen. Please report this bug.";
                resultEl.style.color = "red";
                endGame(); 
                return; 
            }
            
            // Check if we've SOLVED enough (this is the real end condition)
            console.log('Daily/H2H mode - solvedCount:', solvedCount, 'TOTAL_PLATES:', TOTAL_PLATES);
            if (solvedCount >= TOTAL_PLATES) {
                console.log('Ending game - solved 10!');
                endGame();
                return;
            }
            
            // Get next plate from the daily sequence
            const chosen = dailyPlateSequence[idx];
            usedPlates.add(chosen);
            currentPlate = chosen;
            plateEl.textContent = chosen;
            resultEl.textContent = "";
            plateLocked = false;
            checkButtonEl.disabled = false;
            skipButtonEl.disabled = false;
            wordInputEl.disabled = false;
            wordInputEl.readOnly = false;
            plateStartTime = performance.now();
            updateDifficultyDisplay(chosen);
            wordInputEl.value = "";
            wordInputEl.focus();
            return;
        }
        if (usedPlates.size===ALL_PLATES.length) {
            resultEl.textContent = "Seen all plates!";
            resultEl.style.color = "red";
            endGame();
            return;
        }
        const primaryBand = choosePrimaryBand();
        const startIndex = BAND_NAMES.indexOf(primaryBand);
        const bandOrder = [];
        for (let i=0;i<BAND_NAMES.length;i++) bandOrder.push(BAND_NAMES[(startIndex+i)%BAND_NAMES.length]);
        let chosen = null;
        for (const band of bandOrder) { chosen = pickRandomPlateFromBand(band); if (chosen) break; }
        if (!chosen) {
            const remaining = ALL_PLATES.filter(p=>!usedPlates.has(p));
            if (!remaining.length) { resultEl.textContent = "No unused plates."; resultEl.style.color = "red"; endGame(); return; }
            chosen = remaining[Math.floor(Math.random()*remaining.length)];
        }
        usedPlates.add(chosen);
        const jsCount = computeJsViableCount(chosen);
        if (jsCount<=0) {
            if (usedPlates.size===ALL_PLATES.length) { resultEl.textContent = "No viable words."; resultEl.style.color = "red"; endGame(); return; }
            pickRandomPlate();
            return;
        }
        currentPlate = chosen;
        plateEl.textContent = chosen;
        resultEl.textContent = "";
        plateLocked = false;
        checkButtonEl.disabled = false;
        skipButtonEl.disabled = false;
        wordInputEl.disabled = false;
        wordInputEl.readOnly = false;
        plateStartTime = performance.now();
        updateDifficultyDisplay(chosen);
        wordInputEl.value = "";
        wordInputEl.focus();
    }

    // --------- DIFFICULTY ---------
    function classifyDifficulty(score) {
        if (score >= 80) return "diff-hard";
        if (score >= 40) return "diff-med";
        return "diff-easy";
    }

    function updateDifficultyDisplay(plate) {
        if (!PLATE_DIFFICULTY || !PLATE_DIFFICULTY[plate]) {
            difficultyLabelEl.textContent = "Difficulty: ‚Äî";
            difficultyLabelEl.className = "difficulty diff-med";
        } else {
            const entry = PLATE_DIFFICULTY[plate];
            const diff = entry.difficulty;
            if (!diff || diff <= 0) {
                difficultyLabelEl.textContent = "Difficulty: ‚Äî";
                difficultyLabelEl.className = "difficulty diff-med";
            } else {
                difficultyLabelEl.textContent = `Difficulty: ${diff} / 100`;
                difficultyLabelEl.className = "difficulty " + classifyDifficulty(diff);
            }
        }

        if (!dictionaryReady || !plate) {
            viableCountLabelEl.textContent = "";
        } else {
            const jsCount = computeJsViableCount(plate);
            viableCountLabelEl.textContent = `${jsCount.toLocaleString()} viable words`;
        }
    }

    function getPlateDifficultyScore(plate) {
        if (!PLATE_DIFFICULTY || !PLATE_DIFFICULTY[plate]) return null;
        const d = PLATE_DIFFICULTY[plate].difficulty;
        if (!d || d <= 0) return null;
        return d;
    }

    // --------- TIMER / GAME STATE ---------
    function updateProgressDisplay() {
        progressDisplayEl.textContent = `Solved: ${solvedCount} / ${TOTAL_PLATES}`;
    }

    function updateSkipButtonLabel() {
        const nextPenalty = (skipCount + 1) * 5;
        skipButtonEl.textContent = `Skip +${nextPenalty}s`;
    }

    function showStartGameButton() {
        startButtonEl.textContent = "Start Game";
        const ready = dictionaryReady && difficultyReady && platesReady;
        startButtonEl.disabled = !ready;
        startButtonEl.style.opacity = ready ? '1' : '0.5';
        startButtonEl.style.cursor = ready ? 'pointer' : 'not-allowed';
    }

    function showRestartGameButton() {
        startButtonEl.textContent = "Restart game";
        startButtonEl.disabled = false;
        startButtonEl.style.opacity = '1';
        startButtonEl.style.cursor = 'pointer';
    }

    function hideMainStartButton() {
        // Don't hide, just disable
        startButtonEl.disabled = true;
        startButtonEl.style.opacity = '0.5';
        startButtonEl.style.cursor = 'not-allowed';
    }

    function showChartButton() {
        if (gameHistory.length > 0) {
            chartButtonEl.style.display = "inline-block";
        }
    }

    function hideChartButton() {
        chartButtonEl.style.display = "none";
    }

    function resetGameState() {
        gameStarted = false;
        gameOver = false;
        solvedCount = 0;
        startTime = null;
        penaltySeconds = 0;
        skipCount = 0;
        plateLocked = false;
        usedPlates = new Set();
        plateStartTime = null;
        gameHistory = [];
        updateSkipButtonLabel();
        hideChartButton();

        if (timerIntervalId) clearInterval(timerIntervalId);
        timerIntervalId = null;

        plateEl.textContent = "---";
        difficultyLabelEl.textContent = "Difficulty: ‚Äî";
        difficultyLabelEl.className = "difficulty diff-med";
        viableCountLabelEl.textContent = "";
        timerDisplayEl.textContent = "Time: 0.0 s";
        updateProgressDisplay();
        resultEl.textContent = "";
        resultEl.style.color = "";
        wordInputEl.value = "";

        checkButtonEl.disabled = false;
        skipButtonEl.disabled = false;
        wordInputEl.disabled = false;
        wordInputEl.readOnly = false;

        while (historyBodyEl.firstChild) {
            historyBodyEl.removeChild(historyBodyEl.firstChild);
        }
        historyEmptyEl.style.display = "block";
    }

    async function beginNewRun() {
        // If this is a new H2H challenge (pending opponent), create it now
        if (gameMode === 'h2h_challenge' && pendingOpponent && !currentChallengeId) {
            await createChallengeWithOpponent();
        }
        
        // Remove pulse animation from start button
        startButtonEl.classList.remove('pulse-button');
        
        resetGameState();
        gameStarted = true;
        gameOver = false;
        
        // Show difficulty bar when game starts
        document.getElementById('difficultyLabel').style.display = 'block';
        
        // Scroll to plate on mobile
        if (window.innerWidth <= 768) {
            const carWrapper = document.querySelector('.car-wrapper');
            if (carWrapper) {
                carWrapper.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }
        
        startTime = performance.now();
        timerIntervalId = setInterval(updateTimer, 100);
        updateProgressDisplay();
        
        // Only disable buttons during daily challenge or H2H (not practice)
        if (gameMode === 'daily' || gameMode === 'h2h_challenge') {
            document.getElementById('dailyChallengeBtn').disabled = true;
            document.getElementById('practiceBtn').disabled = true;
        }
        
        // Disable restart button during daily challenge or H2H
        if (gameMode === 'daily' || gameMode === 'h2h_challenge') {
            startButtonEl.disabled = true;
            startButtonEl.style.opacity = '0.5';
            startButtonEl.style.cursor = 'not-allowed';
        }
        
        if (gameMode==='daily' && currentUser) {
            // Save started flag to Firebase
            database.ref(`started/${getTodayString()}/${currentUser.uid}`).set({
                userName: currentUser.displayName || currentUser.email,
                timestamp: Date.now(),
                started: true
            });
            
            window.onbeforeunload = e => {
                if (gameStarted && !gameOver && gameMode==='daily') {
                    e.preventDefault();
                    return 'Leave? Daily attempt will be used!';
                }
            };
        }
        
        // H2H Challenge - mark as in_progress when actually starting
        if (gameMode === 'h2h_challenge' && currentChallengeId && currentUser) {
            challengeStartTime = Date.now();
            database.ref(`challenges/${currentChallengeId}/results/${currentUser.uid}`).set({
                status: 'in_progress',
                startedAt: challengeStartTime
            });
            
            window.onbeforeunload = e => {
                if (gameStarted && !gameOver && gameMode==='h2h_challenge') {
                    e.preventDefault();
                    return 'Leave? Challenge will be marked as Abandoned!';
                }
            };
        }
        
        pickRandomPlate();
    }

    async function startGameFromModal() {
        const ready = dictionaryReady && difficultyReady && platesReady;
        if (!ready) {
            resultEl.textContent = "Still loading‚Ä¶";
            resultEl.style.color = "red";
            return;
        }

        if (ALL_PLATES.length === 0) {
            resultEl.textContent = "No viable plates to start the game.";
            resultEl.style.color = "red";
            return;
        }

        closeGameModal();
        hideChartButton();

        hasStartedOnce = true;
        // Only show restart for practice mode, not daily or H2H
        if (gameMode !== 'daily' && gameMode !== 'h2h_challenge') {
            showRestartGameButton();
        }

        await beginNewRun();
    }

    async function startOrRestartFromMain() {
        const ready = dictionaryReady && difficultyReady && platesReady;
        if (!ready) {
            resultEl.textContent = "Still loading‚Ä¶";
            resultEl.style.color = "red";
            return;
        }

        if (ALL_PLATES.length === 0) {
            resultEl.textContent = "No viable plates to start the game.";
            resultEl.style.color = "red";
            return;
        }

        hasStartedOnce = true;
        // Only show restart for practice mode, not daily or H2H
        if (gameMode !== 'daily' && gameMode !== 'h2h_challenge') {
            showRestartGameButton();
        }
        hideChartButton();

        await beginNewRun();
    }

    function updateTimer() {
        if (!gameStarted || !startTime) return;
        const baseElapsedSec = (performance.now() - startTime) / 1000;
        const totalSec = baseElapsedSec + penaltySeconds;
        timerDisplayEl.textContent = "Time: " + totalSec.toFixed(1) + " s";
        
        // Check for H2H challenge timeout
        if (gameMode === 'h2h_challenge' && currentChallengeId && challengeStartTime) {
            const elapsed = (Date.now() - challengeStartTime) / 1000;
            if (elapsed >= CHALLENGE_TIMEOUT) {
                markChallengeDNF();
            }
        }
    }

    function endGame() {
        if (gameOver) return;
        gameOver = true;
        gameStarted = false;
        plateLocked = true;

        if (!startTime) return;

        const baseElapsedSec = (performance.now() - startTime) / 1000;
        const totalSec = baseElapsedSec + penaltySeconds;

        if (timerIntervalId) {
            clearInterval(timerIntervalId);
            timerIntervalId = null;
        }

        resultEl.textContent = `üèÅ Finished! Time: ${totalSec.toFixed(1)} s`;
        resultEl.style.color = "green";
        wordInputEl.blur();

        checkButtonEl.disabled = true;
        skipButtonEl.disabled = true;
        wordInputEl.disabled = true;
        wordInputEl.readOnly = true;

        openEndModal(totalSec);
        // Don't show restart for daily challenge or H2H
        if (gameMode !== 'daily' && gameMode !== 'h2h_challenge') {
            showRestartGameButton();
        }
        showChartButton();
        // Re-enable buttons
        document.getElementById('dailyChallengeBtn').disabled = false;
        document.getElementById('practiceBtn').disabled = false;
        window.onbeforeunload = null;
        
        // Save score based on game mode
        if (currentUser) {
            if (gameMode === 'daily') {
                saveScore(totalSec, solvedCount, skipCount);
            } else if (gameMode === 'h2h_challenge' && currentChallengeId) {
                saveChallengeResult(totalSec, solvedCount, skipCount);
            }
        }
    }

    // --------- FLOATING LABELS & HISTORY ---------
    function createFloatingLabel(text, fromRect, toRect, extraClass) {
        const el = document.createElement("div");
        el.textContent = text;
        el.className = "float-label " + (extraClass || "");

        const startX = fromRect.left + fromRect.width / 2;
        const startY = fromRect.top + fromRect.height / 2;
        const endX = toRect.left + toRect.width / 2;
        const endY = toRect.top + toRect.height / 2;

        el.style.left = startX + "px";
        el.style.top = startY + "px";

        document.body.appendChild(el);

        requestAnimationFrame(() => {
            el.style.left = endX + "px";
            el.style.top = endY + "px";
            el.style.opacity = "0";
        });

        return el;
    }

    function addPlateCellClickHandler(plateTd, plate) {
        plateTd.classList.add("clickable-plate");
        plateTd.title = "Click to see all viable words";
        plateTd.addEventListener("click", () => {
            openWordsModal(plate);
        });
    }

    function addToHistoryWithAnimation(
        plate,
        word,
        matchIndices,
        fromRectWord,
        diffScore,
        timeLabel,
        onComplete
    ) {
        if (!plate || !word) {
            if (onComplete) onComplete();
            return;
        }

        historyEmptyEl.style.display = "none";

        const row = document.createElement("tr");
        row.style.opacity = "0";

        const plateTd = document.createElement("td");
        const wordTd = document.createElement("td");
        const timeTd = document.createElement("td");
        const diffTd = document.createElement("td");

        plateTd.textContent = plate;

        if (Array.isArray(matchIndices) && matchIndices.length > 0) {
            const set = new Set(matchIndices);
            let html = "";
            for (let i = 0; i < word.length; i++) {
                const ch = word[i];
                if (set.has(i)) {
                    html += `<span class="plate-letter-highlight">${ch}</span>`;
                } else {
                    html += ch;
                }
            }
            wordTd.innerHTML = html;
        } else {
            wordTd.textContent = word;
        }

        timeTd.textContent = timeLabel || "‚Äî";

        if (diffScore === null || diffScore <= 0) {
            diffTd.textContent = "‚Äî";
        } else {
            diffTd.textContent = diffScore;
            diffTd.className = classifyDifficulty(diffScore);
        }

        row.appendChild(plateTd);
        row.appendChild(wordTd);
        row.appendChild(timeTd);
        row.appendChild(diffTd);

        if (historyBodyEl.firstChild) {
            historyBodyEl.insertBefore(row, historyBodyEl.firstChild);
        } else {
            historyBodyEl.appendChild(row);
        }

        while (historyBodyEl.rows.length > 30) {
            historyBodyEl.removeChild(historyBodyEl.lastChild);
        }

        addPlateCellClickHandler(plateTd, plate);

        const plateFrom = plateEl.getBoundingClientRect();
        const wordFrom = fromRectWord || wordInputEl.getBoundingClientRect();
        const plateTo = plateTd.getBoundingClientRect();
        const wordTo = wordTd.getBoundingClientRect();
        const diffTo = diffTd.getBoundingClientRect();

        const plateClone = createFloatingLabel(plate, plateFrom, plateTo, "float-label-plate");
        const wordClone = createFloatingLabel(word, wordFrom, wordTo, "float-label-word");
        const diffText = (diffScore === null || diffScore <= 0) ? "‚Äî" : String(diffScore);
        const diffClone = createFloatingLabel(diffText, plateFrom, diffTo, "float-label-diff");

        if (typeof onComplete === "function") {
            onComplete();
        }

        const animDuration = 400;
        setTimeout(() => {
            row.style.opacity = "1";

            [plateClone, wordClone, diffClone].forEach(clone => {
                if (clone && clone.parentNode) clone.parentNode.removeChild(clone);
            });
        }, animDuration);
    }

    // --------- WORDS MODAL (SORTING) ---------
    function setWordsSortMode(mode) {
        currentWordsModalSortMode = mode;

        if (mode === "alpha") {
            wordsSortAlphaBtnEl.classList.add("active");
            wordsSortLengthBtnEl.classList.remove("active");
        } else {
            wordsSortAlphaBtnEl.classList.remove("active");
            wordsSortLengthBtnEl.classList.add("active");
        }

        // Check if we're using the new displayViableWords (from comparison table)
        if (window.currentViableWords) {
            displayViableWords(mode);
        } else {
            // Use the old renderWordsList (from gameplay)
            renderWordsList(mode);
        }
    }

    function renderWordsList(sortMode) {
        // Clear comparison table data to prevent conflicts
        window.currentViableWords = null;
        window.currentPlateName = null;
        
        wordsModalListEl.innerHTML = "";

        const plate = currentWordsModalPlate;
        if (!plate || !currentWordsModalMatches || currentWordsModalMatches.length === 0) {
            wordsModalListEl.textContent = "(no viable words found)";
            return;
        }

        const arr = [...currentWordsModalMatches];

        if (sortMode === "alpha") {
            arr.sort((a, b) => a.localeCompare(b));
        } else {
            arr.sort((a, b) => {
                const lenDiff = a.length - b.length;
                return lenDiff !== 0 ? lenDiff : a.localeCompare(b);
            });
        }

        const frag = document.createDocumentFragment();
        for (const w of arr) {
            const line = document.createElement("div");
            line.className = "words-list-item";

            const indices = getPlateMatchIndices(plate, w) || [];
            const indexSet = new Set(indices);

            let html = "";
            for (let i = 0; i < w.length; i++) {
                const ch = w[i];
                if (indexSet.has(i)) {
                    html += `<span class="plate-letter-highlight">${ch}</span>`;
                } else {
                    html += ch;
                }
            }

            line.innerHTML = html;
            frag.appendChild(line);
        }

        wordsModalListEl.appendChild(frag);
    }

    function openWordsModal(plate) {
        if (!dictionaryReady) return;

        wordsModalTitleEl.textContent = `Plate: ${plate}`;
        wordsModalStatusEl.textContent = "Finding viable words‚Ä¶";

        currentWordsModalPlate = plate;
        currentWordsModalMatches = [];
        setWordsSortMode("alpha");

        wordsModalBackdropEl.classList.add("show");

        const matches = [];
        for (const w of WORDS) {
            if (wordMatchesPlate(plate, w)) {
                matches.push(w);
            }
        }

        matches.sort();
        currentWordsModalMatches = matches;

        const countFromScan = matches.length;
        wordsModalStatusEl.textContent =
            `${countFromScan.toLocaleString()} viable words`;

        renderWordsList(currentWordsModalSortMode);
    }

    function closeWordsModal() {
        wordsModalBackdropEl.classList.remove("show");
    }

    // --------- GAME MODAL ---------
    function openStartModal() {
        gameModalMode = "start";
        gameModalTitleEl.textContent = "Daily Challenge";
        gameModalBodyEl.innerHTML = `
            <p style="margin-bottom:1rem;">${gameMode==='daily'?'<strong>‚ö†Ô∏è One attempt per day</strong> ‚Äì do not exit or refresh mid-game.':'<strong>üéÆ Practice Mode:</strong> Unlimited random plays!'}</p>
            <p><strong>How it works:</strong></p>
            <ul>
                <li>You will see plates one after another until you correctly solve <strong>${TOTAL_PLATES}</strong>.</li>
                <li>Enter a word that contains the three plate letters <em>in order</em> (not necessarily consecutively).</li>
                <li>The first instance of each letter must come in order. If your plate is <strong>ABC</strong>, then the first A must appear before the first B or C.</li>
                <li>Example: plate <strong>PMS</strong> ‚Äì <strong>"promise"</strong> works, but <strong>"spams"</strong> does not ("spams" contains PMS, but the first S appears before the first M).</li>
                <li>You can press <strong>Skip</strong>, but it adds an increasing time penalty: +5s, then +10s, +15s, ...</li>
                <li>Click any solved plate in the table to see <strong>all</strong> viable words for that plate.</li>
            </ul>
        `;

        const ready = dictionaryReady && difficultyReady && platesReady;
        gameModalPrimaryBtnEl.disabled = !ready;
        gameModalPrimaryBtnEl.textContent = ready ? "Start Game" : "Loading...";

        gameModalSecondaryBtnEl.style.display = "none";

        gameModalBackdropEl.classList.add("show");
    }

    function openEndModal(finalTimeSec) {
        gameModalMode = "end";
        gameModalTitleEl.textContent = "Run complete!";
        gameModalBodyEl.innerHTML = `
            <p>You solved <strong>${solvedCount}</strong> plates in
            <strong>${finalTimeSec.toFixed(1)} seconds</strong> (including skip penalties).</p>
            <p>You can view a breakdown chart of each plate's time, or close this and inspect the table.</p>
            ${gameMode === 'daily' ? '<p style="margin-top:1rem; color:#92400e; background:#fef3c7; padding:8px; border-radius:4px;"><strong>Daily Challenge Complete!</strong> Come back tomorrow for a new challenge.</p>' : ''}
            ${gameMode === 'h2h_challenge' ? '<p style="margin-top:1rem; color:#92400e; background:#fef3c7; padding:8px; border-radius:4px;"><strong>‚öîÔ∏è H2H Challenge Complete!</strong> Check the H2H Results tab to see if you won!</p>' : ''}
        `;

        // Only show "Play again" for practice mode
        if (gameMode === 'daily' || gameMode === 'h2h_challenge') {
            gameModalPrimaryBtnEl.style.display = "none";
        } else {
            gameModalPrimaryBtnEl.disabled = false;
            gameModalPrimaryBtnEl.textContent = "Play again";
            gameModalPrimaryBtnEl.style.display = "inline-block";
        }

        gameModalSecondaryBtnEl.style.display = "inline-block";
        gameModalSecondaryBtnEl.textContent = "View chart";

        gameModalBackdropEl.classList.add("show");
    }

    function closeGameModal() {
        gameModalBackdropEl.classList.remove("show");
    }

    // --------- MISMATCH EXPLANATION ---------
    function explainPlateMismatch(plate, word) {
        const plateUpper = plate.toUpperCase();
        const wordUpper = word.toUpperCase();

        const missing = [];
        for (const ch of plateUpper) {
            if (!wordUpper.includes(ch)) {
                if (!missing.includes(ch)) missing.push(ch);
            }
        }

        if (missing.length > 0) {
            const missingList = missing.join(", ");
            const letterWord = missing.length === 1 ? "letter" : "letters";
            return `‚ùå "${word}" doesn‚Äôt work for <strong>${plateUpper}</strong>.<br>` +
                   `It‚Äôs missing the ${letterWord}: <strong>${missingList}</strong>.`;
        }

        const firstOccurrences = [];
        for (const ch of plateUpper) {
            const idx = wordUpper.indexOf(ch);
            if (idx !== -1) {
                firstOccurrences.push({ ch, idx });
            }
        }

        firstOccurrences.sort((a, b) => a.idx - b.idx);
        const wordOrder = firstOccurrences.map(x => x.ch).join(" \u2192 ");
        const plateOrder = plateUpper.split("").join(" \u2192 ");
        const lettersList = plateUpper.split("").join(", ");

        return `‚ùå "${word}" doesn‚Äôt work for <strong>${plateUpper}</strong>.<br>` +
               `In your word, the first <strong>${lettersList}</strong> appear in this order: <strong>${wordOrder}</strong>.<br>` +
               `The plate <strong>${plateUpper}</strong> requires them in this order: <strong>${plateOrder}</strong>.`;
    }

    // --------- CHART ---------
    function buildChart() {
        if (!gameHistory.length) return;

        const labels = [];
        const thinkingData = [];
        const penaltyData = [];
        const cumulativeData = [];
        const platesForChart = [];

        let runningTotal = 0;

        for (const entry of gameHistory) {
            const plate = entry.plate;
            platesForChart.push(plate);

            let labelText;
            if (entry.skipped) {
                labelText = `${plate} ‚Äî skipped`;
            } else {
                labelText = `${plate} ‚Äî "${entry.word}"`;
            }
            labels.push(labelText);

            const think = entry.thinkingSeconds != null ? entry.thinkingSeconds : 0;
            const pen   = entry.penaltySeconds != null ? entry.penaltySeconds : 0;

            thinkingData.push(think);
            penaltyData.push(pen);

            runningTotal += think + pen;
            cumulativeData.push(runningTotal);
        }

        const ctx = resultsChartCanvas.getContext("2d");

        resultsChart = new Chart(ctx, {
            type: "bar",
            data: {
                labels,
                datasets: [
                    {
                        type: "bar",
                        label: "Thinking time (s)",
                        data: thinkingData,
                        backgroundColor: "rgba(59, 130, 246, 0.8)",
                        stack: "time"
                    },
                    {
                        type: "bar",
                        label: "Skip penalty (s)",
                        data: penaltyData,
                        backgroundColor: "rgba(220, 38, 38, 0.8)",
                        stack: "time"
                    },
                    {
                        type: "line",
                        label: "Cumulative time (s)",
                        data: cumulativeData,
                        borderColor: "rgba(15, 23, 42, 0.9)",
                        backgroundColor: "rgba(15, 23, 42, 0.5)",
                        tension: 0.25,
                        pointRadius: 3,
                        pointHoverRadius: 4,
                        fill: false,
                        yAxisID: "y"
                    }
                ],
                _plates: platesForChart
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: "bottom"
                    },
                    tooltip: {
                        callbacks: {
                            title: function(items) {
                                if (!items || !items.length) return "";
                                const idx = items[0].dataIndex;
                                const plate = resultsChart.config.data._plates[idx];
                                const entry = gameHistory[idx];
                                if (entry.skipped) {
                                    return `${plate} ‚Äî skipped`;
                                }
                                return `${plate} ‚Äî "${entry.word}"`;
                            },
                            label: function(context) {
                                const label = context.dataset.label || "";
                                const value = context.parsed.y;
                                return `${label}: ${value.toFixed(1)}s`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        stacked: true,
                        grid: {
                            display: false,
                            drawBorder: false
                        },
                        ticks: {
                            autoSkip: false,
                            maxRotation: 45,
                            minRotation: 0
                        }
                    },
                    y: {
                        stacked: true,
                        title: {
                            display: true,
                            text: "Seconds"
                        },
                        grid: {
                            display: false,
                            drawBorder: false
                        }
                    }
                },
                onClick: (evt, elements) => {
                    if (!elements.length) return;
                    const index = elements[0].index;
                    const plate = resultsChart.config.data._plates[index];
                    openWordsModal(plate);
                }
            }
        });
    }

    function openChartModal() {
        if (!gameHistory.length) return;

        if (resultsChart) {
            resultsChart.destroy();
            resultsChart = null;
        }

        buildChart();
        chartModalBackdropEl.classList.add("show");
    }

    function closeChartModal() {
        chartModalBackdropEl.classList.remove("show");
    }

    // --------- ACTIONS ---------
    function checkWord() {
        const rawWord = wordInputEl.value.trim();
        if (!rawWord) return;

        if (!gameStarted) {
            resultEl.textContent = "Press Start to begin the game.";
            resultEl.style.color = "red";
            return;
        }
        if (gameOver) {
            resultEl.textContent = "Game over. Press Restart game to play again.";
            resultEl.style.color = "red";
            return;
        }
        if (plateLocked) {
            return;
        }

        if (!DICTIONARY.has(rawWord.toUpperCase())) {
            resultEl.textContent = `‚ùå "${rawWord}" is not in the dictionary.`;
            resultEl.style.color = "red";
            return;
        }

        const matchIndices = getPlateMatchIndices(currentPlate, rawWord);
        if (!matchIndices) {
            const html = explainPlateMismatch(currentPlate, rawWord);
            resultEl.innerHTML = html;
            resultEl.style.color = "red";
            return;
        }

        plateLocked = true;
        checkButtonEl.disabled = true;
        skipButtonEl.disabled = true;
        wordInputEl.readOnly = true;

        solvedCount++;
        updateProgressDisplay();

        resultEl.textContent = `‚úÖ "${rawWord}" matches ${currentPlate}.`;
        resultEl.style.color = "green";

        const plate = currentPlate;
        const word = rawWord.toLowerCase();
        const diffScore = getPlateDifficultyScore(plate);

        let timeLabel = "‚Äî";
        let thinkingSeconds = 0;
        if (plateStartTime != null) {
            thinkingSeconds = (performance.now() - plateStartTime) / 1000;
            timeLabel = `${thinkingSeconds.toFixed(1)}s`;
        }

        gameHistory.push({
            plate,
            word,
            skipped: false,
            thinkingSeconds,
            penaltySeconds: 0
        });

        addToHistoryWithAnimation(
            plate,
            word,
            matchIndices,
            null,
            diffScore,
            timeLabel,
            () => {
                if (solvedCount >= TOTAL_PLATES) {
                    endGame();
                } else {
                    pickRandomPlate();
                }
            }
        );
    }

    function handleSkip() {
        console.log('=== SKIP CLICKED ===');
        console.log('gameStarted:', gameStarted, 'gameOver:', gameOver, 'solvedCount:', solvedCount);
        if (!gameStarted) {
            resultEl.textContent = "Press Start to begin the game.";
            resultEl.style.color = "red";
            return;
        }
        if (gameOver) {
            resultEl.textContent = "Game over. Press Restart game to play again.";
            resultEl.style.color = "red";
            return;
        }
        if (!currentPlate) return;
        if (plateLocked) {
            return;
        }

        plateLocked = true;
        checkButtonEl.disabled = true;
        skipButtonEl.disabled = true;
        wordInputEl.readOnly = true;

        skipCount += 1;
        const added = skipCount * 5;
        penaltySeconds += added;

        resultEl.textContent = `‚è© Skipped ${currentPlate}. +${added}s penalty.`;
        resultEl.style.color = "orange";

        const plate = currentPlate;
        const penaltyLabel = `+${added}s (skipped)`;
        const diffScore = getPlateDifficultyScore(plate);
        const skipRect = skipButtonEl.getBoundingClientRect();

        let timeLabel = "‚Äî";
        let thinkingSeconds = 0;
        if (plateStartTime != null) {
            thinkingSeconds = (performance.now() - plateStartTime) / 1000;
            timeLabel = `${thinkingSeconds.toFixed(1)}s (+${added}s)`;
        }

        gameHistory.push({
            plate,
            word: "skipped",
            skipped: true,
            thinkingSeconds,
            penaltySeconds: added
        });

        addToHistoryWithAnimation(
            plate,
            penaltyLabel,
            null,
            skipRect,
            diffScore,
            timeLabel,
            () => {
                console.log('After skip - solvedCount:', solvedCount, 'skipCount:', skipCount);
                updateSkipButtonLabel();
                pickRandomPlate();
            }
        );
    }

    // --------- INIT ---------
    startButtonEl.disabled = true;
    hideMainStartButton();
    hideChartButton();
    updateSkipButtonLabel();

    startButtonEl.addEventListener("click", startOrRestartFromMain);
    checkButtonEl.addEventListener("click", checkWord);
    skipButtonEl.addEventListener("click", handleSkip);
    chartButtonEl.addEventListener("click", openChartModal);

    wordInputEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
            checkWord();
        }
    });

    wordsModalCloseBtnEl.addEventListener("click", closeWordsModal);
    wordsModalCloseBtnBottomEl.addEventListener("click", closeWordsModal);
    wordsModalBackdropEl.addEventListener("click", (e) => {
        if (e.target === wordsModalBackdropEl) {
            closeWordsModal();
        }
    });

    wordsSortAlphaBtnEl.addEventListener("click", () => {
        setWordsSortMode("alpha");
    });

    wordsSortLengthBtnEl.addEventListener("click", () => {
        setWordsSortMode("length");
    });

    gameModalPrimaryBtnEl.addEventListener("click", () => {
        if (gameModalMode === "start") {
            startGameFromModal();
        } else if (gameModalMode === "end") {
            startGameFromModal();
        }
    });

    gameModalSecondaryBtnEl.addEventListener("click", () => {
        closeGameModal();
        openChartModal();
    });

    gameModalCloseBtnEl.addEventListener("click", () => {
        closeGameModal();
        if (!gameStarted && !gameOver && gameModalMode === "start") {
            showStartGameButton();
        }
    });

    gameModalBackdropEl.addEventListener("click", (e) => {
        if (e.target === gameModalBackdropEl) {
            closeGameModal();
            if (!gameStarted && !gameOver && gameModalMode === "start") {
                showStartGameButton();
            }
        }
    });

    chartModalCloseBtnEl.addEventListener("click", closeChartModal);
    chartModalCloseBtnBottomEl.addEventListener("click", closeChartModal);
    chartModalBackdropEl.addEventListener("click", (e) => {
        if (e.target === chartModalBackdropEl) {
            closeChartModal();
        }
    });







    // Highlight plate letters in a word
    function highlightPlateInWord(plate, word) {
        const upperWord = word.toUpperCase();
        const upperPlate = plate.toUpperCase();
        let result = '';
        let plateIndex = 0;
        
        for (let i = 0; i < word.length; i++) {
            if (plateIndex < upperPlate.length && upperWord[i] === upperPlate[plateIndex]) {
                result += `<span style="color:#16a34a;font-weight:700;">${word[i]}</span>`;
                plateIndex++;
            } else {
                result += `<span style="color:#000000;">${word[i]}</span>`;
            }
        }
        
        return result;
    }
    // View player run details
    async function viewPlayerRun(userId, dateString, userName, totalTime, solved, skipped) {
        const backdrop = document.getElementById('runDetailsModalBackdrop');
        const titleEl = document.getElementById('runDetailsModalTitle');
        const contentEl = document.getElementById('runDetailsContent');
        
        titleEl.textContent = `${userName}'s Run`;
        contentEl.innerHTML = 'Loading...';
        backdrop.classList.add('show');
        
        try {
            const snapshot = await database.ref(`scores/${dateString}/${userId}`).once('value');
            const data = snapshot.val();
            
            if (!data || !data.history || data.history.length === 0) {
                contentEl.innerHTML = `
                    <p style="text-align:center;color:#6b7280;padding:20px;">
                        <strong>Summary Stats:</strong><br>
                        Total Time: ${totalTime.toFixed(1)}s<br>
                        Solved: ${solved}<br>
                        Skipped: ${skipped}<br><br>
                        <em>Detailed breakdown not available (run completed before this feature was added)</em>
                    </p>`;
                return;
            }
            
            let html = `<p style="margin-bottom:16px;"><strong>Total Time:</strong> ${totalTime.toFixed(1)}s | <strong>Solved:</strong> ${data.solved} | <strong>Skipped:</strong> ${data.skipped}</p>`;
            html += '<table style="width:100%;border-collapse:collapse;"><thead><tr style="background:#f3f4f6;">';
            html += '<th style="padding:8px;text-align:left;">Plate</th>';
            html += '<th style="padding:8px;text-align:left;">Word / Penalty</th>';
            html += '<th style="padding:8px;text-align:right;">Time</th></tr></thead><tbody>';
            
            data.history.forEach((entry, idx) => {
                const bg = idx % 2 === 0 ? '#f9fafb' : '#fff';
                html += `<tr style="background:${bg};">`;
                html += `<td style="padding:8px;font-weight:600;">${entry.plate}</td>`;
                
                if (entry.skipped) {
                    html += `<td style="padding:8px;color:#f59e0b;">+${entry.penaltySeconds}s (skipped)</td>`;
                    html += `<td style="padding:8px;text-align:right;">${entry.thinkingSeconds.toFixed(1)}s (+${entry.penaltySeconds}s)</td>`;
                } else {
                    // Highlight the plate letters in the word
                    const highlightedWord = highlightPlateInWord(entry.plate, entry.word);
                    html += `<td style="padding:8px;color:#16a34a;">${highlightedWord}</td>`;
                    html += `<td style="padding:8px;text-align:right;">${entry.thinkingSeconds.toFixed(1)}s</td>`;
                }
                
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            contentEl.innerHTML = html;
            
        } catch (error) {
            console.error('Error loading run details:', error);
            contentEl.innerHTML = '<p style="text-align:center;color:#dc2626;">Failed to load run details</p>';
        }
    }
    
    window.viewPlayerRun = viewPlayerRun; // Make it globally accessible for onclick

    // Global function to close run details modal
    function closeRunDetailsModal() {
        const backdrop = document.getElementById('runDetailsModalBackdrop');
        if (backdrop) {
            backdrop.classList.remove('show');
        }
    }
    window.closeRunDetailsModal = closeRunDetailsModal;

    // Show viable words for a plate in the comparison table
    function showViableWordsForPlate(plate) {
        if (!plate || plate === '‚Äî') return;
        
        console.log('Showing viable words for:', plate);
        
        // Calculate viable words from DICTIONARY
        const viableWords = [];
        const upperPlate = plate.toUpperCase();
        
        if (typeof DICTIONARY !== 'undefined' && DICTIONARY.size > 0) {
            for (const word of DICTIONARY) {
                const upperWord = word.toUpperCase();
                let plateIdx = 0;
                
                // Check if plate letters appear in order in the word
                for (let i = 0; i < upperWord.length && plateIdx < upperPlate.length; i++) {
                    if (upperWord[i] === upperPlate[plateIdx]) {
                        plateIdx++;
                    }
                }
                
                // If all plate letters were found in order, it's viable
                if (plateIdx === upperPlate.length) {
                    viableWords.push(word);
                }
            }
        }
        
        console.log('Found viable words:', viableWords.length);
        
        if (viableWords.length === 0) {
            alert(`No viable words found for plate ${plate}. Dictionary may not be loaded yet.`);
            return;
        }
        
        // Use the run details modal
        const modalBackdrop = document.getElementById('runDetailsModalBackdrop');
        const modalTitle = document.getElementById('runDetailsModalTitle');
        const modalContent = document.getElementById('runDetailsContent');
        
        // Use the dedicated words modal (same as in-game)
        const wordsModalBackdrop = document.getElementById('wordsModalBackdrop');
        const wordsModalTitle = document.getElementById('wordsModalTitle');
        const wordsModalList = document.getElementById('wordsModalList');
        
        wordsModalTitle.textContent = `Plate: ${plate}`;
        
        // Store for sorting
        window.currentViableWords = viableWords;
        window.currentPlateName = plate;
        
        // Initial display (A-Z)
        displayViableWords('alpha');
        
        // Show modal
        wordsModalBackdrop.classList.add('show');
    }
    
    // Display viable words with highlighting (used by showViableWordsForPlate and sort buttons)
    function displayViableWords(sortType) {
        const viableWords = window.currentViableWords || [];
        const plate = window.currentPlateName || '';
        const wordsModalList = document.getElementById('wordsModalList');
        const wordsCountEl = document.getElementById('wordsModalStatus');
        
        // Sort words
        let sorted = [...viableWords];
        if (sortType === 'length') {
            sorted.sort((a, b) => a.length - b.length || a.localeCompare(b));
        } else {
            sorted.sort((a, b) => a.localeCompare(b));
        }
        
        // Highlight plate letters in each word
        const upperPlate = plate.toUpperCase();
        let html = '';
        
        sorted.forEach(word => {
            const upperWord = word.toUpperCase();
            let highlighted = '';
            let plateIdx = 0;
            
            for (let i = 0; i < word.length; i++) {
                if (plateIdx < upperPlate.length && upperWord[i] === upperPlate[plateIdx]) {
                    highlighted += `<strong style="color:#16a34a;">${word[i].toLowerCase()}</strong>`;
                    plateIdx++;
                } else {
                    highlighted += word[i].toLowerCase();
                }
            }
            
            html += `<div class="word-item">${highlighted}</div>`;
        });
        
        wordsModalList.innerHTML = html;
        wordsCountEl.textContent = `${viableWords.length} viable words`;
        
        // Update sort button states
        document.getElementById('wordsSortAlphaBtn').classList.toggle('active', sortType === 'alpha');
        document.getElementById('wordsSortLengthBtn').classList.toggle('active', sortType === 'length');
    }
    window.displayViableWords = displayViableWords;
    window.showViableWordsForPlate = showViableWordsForPlate;


    // Global function for Load button
    function loadSelectedDate() {
        const v = document.getElementById('leaderboardDatePicker').value;
        if (v) {
            console.log('Loading date:', v);
            displayLeaderboard(v);
        } else {
            console.log('No date selected');
        }
    }
    window.loadSelectedDate = loadSelectedDate;


    // Global function for Today button (backup)

    function changeDateBy(days) {
        const picker = document.getElementById('leaderboardDatePicker');
        const currentDate = new Date(picker.value + 'T00:00:00');
        currentDate.setDate(currentDate.getDate() + days);
        
        // Format as YYYY-MM-DD
        const newDateStr = currentDate.toISOString().split('T')[0];
        
        picker.value = newDateStr;
        displayLeaderboard(newDateStr);
        updateNavigationButtons();
    }
    
    function updateNavigationButtons() {
        const picker = document.getElementById('leaderboardDatePicker');
        const nextBtn = document.getElementById('nextDayBtn');
        const today = getTodayString();
        
        // Disable Next button if viewing today
        if (picker.value === today) {
            nextBtn.disabled = true;
            nextBtn.style.opacity = '0.5';
            nextBtn.style.cursor = 'not-allowed';
        } else {
            nextBtn.disabled = false;
            nextBtn.style.opacity = '1';
            nextBtn.style.cursor = 'pointer';
        }
    }
    
    function loadTodayScores() {
        console.log('=== TODAY BUTTON CLICKED ===');
        const t = getTodayString();
        const picker = document.getElementById('leaderboardDatePicker');
        if (picker) picker.value = t;
        displayLeaderboard(t);
    }
    window.loadTodayScores = loadTodayScores;



    // === FIREBASE EVENT HANDLERS ===
    // Wait for page to fully load before attaching event listeners
    window.addEventListener('DOMContentLoaded', function() {
    // Initialize to practice mode on page load
    gameMode = 'practice';
    const mi = document.getElementById('modeIndicator');
    mi.textContent = 'Practice Mode - Unlimited attempts';
    mi.style.background = '#f3e8ff';
    mi.style.color = '#6b21a8';
    
    // Set practice button as selected
    document.getElementById('practiceBtn').style.background = '#e9d5ff';
    document.getElementById('practiceBtn').style.border = '2px solid #9370db';
    document.getElementById('dailyChallengeBtn').style.background = '#e5e7eb';
    document.getElementById('dailyChallengeBtn').style.border = '2px solid #9ca3af';
    
    // Show start button - enabled and clickable immediately
    const startBtn = document.getElementById('startButton');
    startBtn.textContent = 'Start Game';
    startBtn.disabled = false;
    startBtn.style.opacity = '1';
    startBtn.style.cursor = 'pointer';
    
    document.getElementById('dailyChallengeBtn').addEventListener('click', async () => {
        console.log('Daily Challenge clicked!');
        
        // Check if game data is loaded
        if (!platesReady || !dictionaryReady || !ALL_PLATES || ALL_PLATES.length === 0) {
            alert('Game data is still loading... Please wait a moment and try again.');
            return;
        }
        
        // Sign in if needed
        if (!currentUser && !await signInWithGoogle()) return;
        
        // Check if already played today
        if (await checkIfPlayedToday()) { 
            alert('You already played today\'s challenge! Come back tomorrow, or try Practice Mode.'); 
            return; 
        }
        
        // Set mode
        gameMode = 'daily';
        dailyPlateSequence = generateDailyPlates(getTodayString());
        
        // Update button styles - Daily stays yellow, Practice grey
        document.getElementById('dailyChallengeBtn').style.background = '#fbbf24';
        document.getElementById('dailyChallengeBtn').style.border = '2px solid #f59e0b';
        document.getElementById('practiceBtn').style.background = '#e5e7eb';
        document.getElementById('practiceBtn').style.border = '2px solid #9ca3af';
        
        // Update banner
        const mi = document.getElementById('modeIndicator');
        mi.textContent = 'Daily Challenge - 1 attempt per day';
        mi.style.background = '#fef3c7';
        mi.style.color = '#92400e';
        
        // Show Start Game button
        const startBtn = document.getElementById('startButton');
        startBtn.textContent = 'Start Game';
        startBtn.style.display = 'inline-block';
    });

    // Rules button and modal
    const rulesBtnElement = document.getElementById('rulesBtn');
    console.log('Rules button element:', rulesBtnElement);
    if (rulesBtnElement) {
        rulesBtnElement.addEventListener('click', () => {
            console.log('Rules clicked!');
            const modal = document.getElementById('rulesModalBackdrop');
            console.log('Modal element:', modal);
            if (modal) {
                modal.classList.add('show');
                console.log('Modal should be visible now');
            } else {
                console.error('Modal not found!');
            }
        });
    } else {
        console.error('Rules button not found!');
    }
    
    // Close rules modal - X button
    document.getElementById('rulesModalCloseBtn').addEventListener('click', () => {
        document.getElementById('rulesModalBackdrop').classList.remove('show');
    });
    
    // Close rules modal - Got it button
    document.getElementById('rulesModalCloseBtnBottom').addEventListener('click', () => {
        document.getElementById('rulesModalBackdrop').classList.remove('show');
    });
    
    // Close rules modal - click outside
    document.getElementById('rulesModalBackdrop').addEventListener('click', (e) => {
        if (e.target.id === 'rulesModalBackdrop') {
            document.getElementById('rulesModalBackdrop').classList.remove('show');
        }
    });
    
    document.getElementById('practiceBtn').addEventListener('click', () => {
        console.log('Practice clicked!');
        
        // Set mode
        gameMode = 'practice';
        dailyPlateSequence = null;
        
        // Update button styles - Practice purple, Daily grey
        document.getElementById('practiceBtn').style.background = '#e9d5ff';
        document.getElementById('practiceBtn').style.border = '2px solid #9370db';
        document.getElementById('dailyChallengeBtn').style.background = '#e5e7eb';
        document.getElementById('dailyChallengeBtn').style.border = '2px solid #9ca3af';
        
        // Update banner
        const mi = document.getElementById('modeIndicator');
        mi.textContent = 'Practice Mode - Unlimited attempts';
        mi.style.background = '#f3e8ff';
        mi.style.color = '#6b21a8';
        
        // Show Start Game button
        const startBtn = document.getElementById('startButton');
        startBtn.textContent = 'Start Game';
        startBtn.style.display = 'inline-block';
    });
    document.getElementById('leaderboardBtn').addEventListener('click', () => {
        console.log('Leaderboard clicked!');
        const t = getTodayString();
        document.getElementById('leaderboardDatePicker').value = t;
        document.getElementById('leaderboardDatePicker').max = t;
        displayLeaderboard(t);
        document.getElementById('leaderboardContent').scrollIntoView({behavior:'smooth',block:'nearest'});
    });
    document.getElementById('loadLeaderboardBtn').addEventListener('click', () => {
        const v = document.getElementById('leaderboardDatePicker').value;
        if (v) displayLeaderboard(v);
    });
    document.getElementById('todayLeaderboardBtn').addEventListener('click', () => {
        const t = getTodayString();
        document.getElementById('leaderboardDatePicker').value = t;
        displayLeaderboard(t);
    });
    
    document.getElementById('signOutBtn').addEventListener('click', () => auth.signOut());
    });
    // === END FIREBASE HANDLERS ===

    // ========== HEAD-TO-HEAD FEATURE ==========
    let currentChallengeId = null;
    let challengeStartTime = null;
    let pendingOpponent = null;
    const CHALLENGE_TIMEOUT = 2000; // 2000 seconds
    
    // Prepare challenge (don't create yet - wait for Start button)
    function prepareChallenge(opponent) {
        pendingOpponent = opponent;
        gameMode = 'h2h_challenge';
        
        // Update button styles - fully grayed out
        const practiceBtn = document.getElementById('practiceBtn');
        const dailyBtn = document.getElementById('dailyChallengeBtn');
        
        practiceBtn.style.background = '#e5e7eb';
        practiceBtn.style.border = '2px solid #9ca3af';
        practiceBtn.style.color = '#6b7280';
        practiceBtn.style.cursor = 'not-allowed';
        practiceBtn.disabled = true;
        
        dailyBtn.style.background = '#e5e7eb';
        dailyBtn.style.border = '2px solid #9ca3af';
        dailyBtn.style.color = '#6b7280';
        dailyBtn.style.cursor = 'not-allowed';
        dailyBtn.disabled = true;
        
        // Update banner with back button embedded
        const mi = document.getElementById('modeIndicator');
        mi.innerHTML = `
            <div style="display:flex;align-items:center;justify-content:space-between;">
                <span>‚öîÔ∏è Ready to challenge ${opponent.name}</span>
                <button 
                    onclick="cancelPendingChallenge()" 
                    style="padding:6px 12px;background:#6b7280;color:white;border:none;border-radius:4px;cursor:pointer;font-size:0.9rem;"
                >
                    ‚Üê Back
                </button>
            </div>
        `;
        mi.style.background = '#fef3c7';
        mi.style.color = '#92400e';
        mi.style.border = '2px solid #fbbf24';
        
        // Show Start Challenge button with pulse animation
        const startBtn = document.getElementById('startButton');
        startBtn.textContent = 'Start Challenge';
        startBtn.style.display = 'inline-block';
        startBtn.classList.add('pulse-button');
        
        // Scroll to top
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }
    
    // Cancel pending challenge
    window.cancelPendingChallenge = function() {
        pendingOpponent = null;
        gameMode = 'practice';
        
        const practiceBtn = document.getElementById('practiceBtn');
        const dailyBtn = document.getElementById('dailyChallengeBtn');
        
        practiceBtn.disabled = false;
        practiceBtn.style.background = '#e9d5ff';
        practiceBtn.style.border = '2px solid #9370db';
        practiceBtn.style.color = '#000';
        practiceBtn.style.cursor = 'pointer';
        
        dailyBtn.disabled = false;
        dailyBtn.style.background = '#fbbf24';
        dailyBtn.style.border = '2px solid #f59e0b';
        dailyBtn.style.color = '#000';
        dailyBtn.style.cursor = 'pointer';
        
        const mi = document.getElementById('modeIndicator');
        mi.textContent = 'Select a game mode above to begin';
        mi.style.background = '#f3f4f6';
        mi.style.color = '#000000';
        mi.style.border = '2px dashed #d1d5db';
        
        const startBtn = document.getElementById('startButton');
        startBtn.style.display = 'none';
        startBtn.classList.remove('pulse-button');
    };
    
    // Create challenge with pending opponent (called when Start Challenge is clicked)
    async function createChallengeWithOpponent() {
        if (!pendingOpponent) return;
        
        const opponent = pendingOpponent;
        
        try {
            const challengeId = database.ref('challenges').push().key;
            const plateSequence = generateChallengeSequence();
            
            if (plateSequence.length < 100) {
                alert('Error generating plates');
                return;
            }
            
            await database.ref(`challenges/${challengeId}`).set({
                createdBy: currentUser.uid,
                creatorName: currentUser.displayName || currentUser.email,
                challengedUser: opponent.uid,
                opponentName: opponent.name,
                plateSequence: plateSequence,
                createdAt: Date.now(),
                expiresAt: Date.now() + (7 * 24 * 60 * 60 * 1000),
                status: 'pending',
                results: {}
            });
            
            // Copy link to clipboard silently
            const challengeUrl = `${window.location.origin}${window.location.pathname}?challenge=${challengeId}`;
            try {
                await navigator.clipboard.writeText(challengeUrl);
            } catch (err) {
                console.log('Could not copy to clipboard');
            }
            
            // Set challenge variables (don't call playChallenge - we're already starting)
            currentChallengeId = challengeId;
            dailyPlateSequence = plateSequence;
            
            // Update banner
            const mi = document.getElementById('modeIndicator');
            mi.textContent = `‚öîÔ∏è H2H Challenge vs ${opponent.name} - One attempt only!`;
            
        } catch (error) {
            console.error('Error creating challenge:', error);
            alert('Error creating challenge: ' + error.message);
        }
    }
    
    // Generate random plate sequence for challenge (100 plates)
    function generateChallengeSequence() {
        if (!platesReady || !ALL_PLATES.length) return [];
        
        const sequence = [];
        const usedPlates = new Set();
        
        while (sequence.length < 100 && usedPlates.size < ALL_PLATES.length) {
            const r = Math.random();
            let band;
            if (r < VERY_EASY_PROB) band = "very_easy";
            else if (r < VERY_EASY_PROB + EASY_PROB) band = "easy";
            else if (r < VERY_EASY_PROB + EASY_PROB + MEDIUM_PROB) band = "medium";
            else if (r < VERY_EASY_PROB + EASY_PROB + MEDIUM_PROB + DIFFICULT_PROB) band = "difficult";
            else if (r < VERY_EASY_PROB + EASY_PROB + MEDIUM_PROB + DIFFICULT_PROB + HARD_PROB) band = "hard";
            else if (r < VERY_EASY_PROB + EASY_PROB + MEDIUM_PROB + DIFFICULT_PROB + HARD_PROB + VERY_HARD_PROB) band = "very_hard";
            else band = "impossible";
            
            const bandPlates = ALL_PLATES.filter(plate => {
                if (usedPlates.has(plate)) return false;
                const diff = PLATE_DIFFICULTY && PLATE_DIFFICULTY[plate] ? PLATE_DIFFICULTY[plate].difficulty : null;
                if (!diff) return false;
                
                if (band === "very_easy" && diff >= 0 && diff <= 10) return true;
                if (band === "easy" && diff >= 11 && diff <= 34) return true;
                if (band === "medium" && diff >= 35 && diff <= 49) return true;
                if (band === "difficult" && diff >= 50 && diff <= 79) return true;
                if (band === "hard" && diff >= 80 && diff <= 88) return true;
                if (band === "very_hard" && diff >= 89 && diff <= 96) return true;
                if (band === "impossible" && diff >= 97 && diff <= 100) return true;
                return false;
            });
            
            if (bandPlates.length > 0) {
                const plate = bandPlates[Math.floor(Math.random() * bandPlates.length)];
                sequence.push(plate);
                usedPlates.add(plate);
            }
        }
        
        return sequence;
    }
    
    // Load H2H challenges
    async function loadH2HChallenges() {
        if (!currentUser) {
            document.getElementById('incomingChallenges').innerHTML = '<p style="color:#9ca3af;text-align:center;">Sign in to see challenges</p>';
            document.getElementById('outgoingChallenges').innerHTML = '<p style="color:#9ca3af;text-align:center;">Sign in to see challenges</p>';
            document.getElementById('h2hResults').innerHTML = '<p style="color:#9ca3af;text-align:center;">Sign in to see results</p>';
            return;
        }
        
        try {
            const challengesSnapshot = await database.ref('challenges').once('value');
            const allChallenges = challengesSnapshot.val() || {};
            
            // Clean up expired challenges and check for completion
            const now = Date.now();
            const activeChallenges = {};
            
            for (const [id, challenge] of Object.entries(allChallenges)) {
                if (challenge.expiresAt && challenge.expiresAt < now && challenge.status !== 'completed') {
                    await database.ref(`challenges/${id}`).remove();
                } else {
                    // Check if challenge should be marked as completed
                    if (challenge.status !== 'completed' && challenge.results) {
                        const creatorResult = challenge.results[challenge.createdBy];
                        const challengedResult = challenge.results[challenge.challengedUser];
                        
                        if (creatorResult && challengedResult && 
                            (creatorResult.status === 'completed' || creatorResult.status === 'DNF') &&
                            (challengedResult.status === 'completed' || challengedResult.status === 'DNF')) {
                            
                            // If both abandoned, delete the challenge
                            if (creatorResult.status === 'DNF' && challengedResult.status === 'DNF') {
                                await database.ref(`challenges/${id}`).remove();
                                console.log('Both players abandoned - challenge deleted:', id);
                                continue; // Skip adding to activeChallenges
                            } else {
                                // Otherwise mark as completed
                                await database.ref(`challenges/${id}`).update({
                                    status: 'completed',
                                    completedAt: Date.now()
                                });
                                challenge.status = 'completed';
                                challenge.completedAt = Date.now();
                            }
                        }
                    }
                    activeChallenges[id] = challenge;
                }
            }
            
            displayIncomingChallenges(activeChallenges);
            displayOutgoingChallenges(activeChallenges);
            displayH2HResults(activeChallenges);
            
        } catch (error) {
            console.error('Error loading H2H challenges:', error);
        }
    }
    
    function displayIncomingChallenges(allChallenges) {
        const container = document.getElementById('incomingChallenges');
        
        const incoming = Object.entries(allChallenges)
            .filter(([id, c]) => {
                if (c.challengedUser !== currentUser.uid) return false;
                if (c.status === 'completed') return false;
                
                // Only show if creator has already played
                const creatorResult = c.results && c.results[c.createdBy];
                return creatorResult && (creatorResult.time || creatorResult.status === 'DNF');
            });
        
        // Count new completed challenges (unviewed and within 7 days) - only for current user
        const viewedChallenges = JSON.parse(localStorage.getItem('viewedChallenges') || '[]');
        const completed = Object.entries(allChallenges).filter(([id, c]) => {
            // Only count if completed AND user is involved
            return c.status === 'completed' && (c.createdBy === currentUser.uid || c.challengedUser === currentUser.uid);
        });
        const newCompletedCount = completed.filter(([id, challenge]) => {
            const isViewed = viewedChallenges.includes(id);
            const daysSinceCompleted = (Date.now() - challenge.completedAt) / (1000 * 60 * 60 * 24);
            return !isViewed && daysSinceCompleted < 7;
        }).length;
        
        // Update notification badge (incoming + new completed)
        const badge = document.getElementById('h2hNotificationBadge');
        const totalNotifications = incoming.length + newCompletedCount;
        if (totalNotifications > 0) {
            badge.textContent = totalNotifications;
            badge.style.display = 'block';
        } else {
            badge.style.display = 'none';
        }
        
        if (incoming.length === 0) {
            container.innerHTML = '<p style="color:#9ca3af;text-align:center;">No incoming challenges</p>';
            return;
        }
        
        // Sort by creation date (newest first)
        incoming.sort((a, b) => (b[1].createdAt || 0) - (a[1].createdAt || 0));
        
        let html = '';
        incoming.forEach(([id, challenge]) => {
            const myResult = challenge.results && challenge.results[currentUser.uid];
            
            // Format date
            const createdDate = challenge.createdAt ? new Date(challenge.createdAt).toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric',
                year: 'numeric',
                hour: 'numeric',
                minute: '2-digit'
            }) : 'Unknown';
            
            let statusText = '';
            if (myResult && myResult.status === 'DNF') {
                statusText = 'You: <span style="color:#ef4444;">Abandoned</span>';
            } else if (myResult && myResult.time) {
                statusText = `You: ${myResult.time.toFixed(1)}s`;
            } else {
                statusText = '';
            }
            
            const canPlay = !myResult || (!myResult.time && myResult.status !== 'DNF' && myResult.status !== 'in_progress');
            // Can only decline if you haven't started at all (no result exists)
            const canDecline = !myResult;
            
            html += `
                <div style="display:flex;align-items:center;padding:12px;border-bottom:1px solid #f3f4f6;gap:15px;">
                    <div style="min-width:140px;">
                        <div style="font-size:0.85rem;color:#6b7280;">${createdDate}</div>
                    </div>
                    <span style="flex:1;"><strong>${challenge.creatorName}</strong> challenged you${statusText ? ' ‚Äî ' + statusText : ''}</span>
                    ${canPlay ? `<button onclick="playChallenge('${id}')" style="padding:6px 16px;background:#9370db;color:white;border:none;border-radius:4px;cursor:pointer;">Play Now</button>` : ''}
                    ${canDecline ? `<button onclick="declineChallenge('${id}')" style="padding:6px 16px;background:#ef4444;color:white;border:none;border-radius:4px;cursor:pointer;">Decline</button>` : ''}
                </div>
            `;
        });
        
        container.innerHTML = html;
    }
    
    function displayOutgoingChallenges(allChallenges) {
        const container = document.getElementById('outgoingChallenges');
        
        const outgoing = Object.entries(allChallenges)
            .filter(([id, c]) => c.createdBy === currentUser.uid && c.status !== 'completed');
        
        if (outgoing.length === 0) {
            container.innerHTML = '<p style="color:#9ca3af;text-align:center;">No outgoing challenges</p>';
            return;
        }
        
        // Sort by creation date (newest first)
        outgoing.sort((a, b) => (b[1].createdAt || 0) - (a[1].createdAt || 0));
        
        let html = '';
        outgoing.forEach(([id, challenge]) => {
            const myResult = challenge.results && challenge.results[currentUser.uid];
            const theirResult = challenge.results && challenge.results[challenge.challengedUser];
            
            // Format date
            const createdDate = challenge.createdAt ? new Date(challenge.createdAt).toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric',
                year: 'numeric',
                hour: 'numeric',
                minute: '2-digit'
            }) : 'Unknown';
            
            // Check if open challenge
            const isOpen = challenge.isOpen && challenge.challengedUser === null;
            const opponentDisplay = isOpen ? '<strong>Open Challenge</strong> <span style="color:#10b981;font-size:0.85rem;">(unclaimed)</span>' : `<strong>${challenge.opponentName}</strong>`;
            
            let statusText = '';
            if (myResult && myResult.status === 'DNF') {
                statusText = 'You: <span style="color:#ef4444;">Abandoned</span>';
            } else if (myResult && myResult.time) {
                statusText = `You: ${myResult.time.toFixed(1)}s`;
            } else {
                statusText = '';
            }
            
            const challengeUrl = `${window.location.origin}${window.location.pathname}?challenge=${id}`;
            const canPlay = !myResult || (!myResult.time && myResult.status !== 'DNF' && myResult.status !== 'in_progress');
            const canCancel = canPlay; // Can cancel if you haven't played yet
            
            html += `
                <div style="display:flex;align-items:center;padding:12px;border-bottom:1px solid #f3f4f6;gap:15px;">
                    <button onclick="copyToClipboard('${challengeUrl}')" style="padding:6px 16px;background:#6b7280;color:white;border:none;border-radius:4px;cursor:pointer;flex-shrink:0;">Copy Link</button>
                    <div style="min-width:140px;">
                        <div style="font-size:0.85rem;color:#6b7280;">${createdDate}</div>
                    </div>
                    <span style="flex:1;">You vs. ${opponentDisplay}${statusText ? ' ‚Äî ' + statusText : ''}</span>
                    ${canPlay ? `<button onclick="playChallenge('${id}')" style="padding:6px 16px;background:#9370db;color:white;border:none;border-radius:4px;cursor:pointer;">Play Now</button>` : ''}
                    ${canCancel ? `<button onclick="cancelChallenge('${id}')" style="padding:6px 16px;background:#ef4444;color:white;border:none;border-radius:4px;cursor:pointer;">Cancel</button>` : ''}
                </div>
            `;
        });
        
        container.innerHTML = html;
    }
    
    function displayH2HResults(allChallenges) {
        const container = document.getElementById('h2hResults');
        
        const completed = Object.entries(allChallenges)
            .filter(([id, c]) => {
                if (c.status !== 'completed') return false;
                
                // Only show challenges where current user is involved
                const isInvolved = c.createdBy === currentUser.uid || c.challengedUser === currentUser.uid;
                if (!isInvolved) return false;
                
                // Filter out challenges where both players abandoned (already deleted by loadH2HChallenges)
                const creatorResult = c.results && c.results[c.createdBy];
                const challengedResult = c.results && c.results[c.challengedUser];
                
                if (creatorResult && challengedResult && 
                    creatorResult.status === 'DNF' && 
                    challengedResult.status === 'DNF') {
                    return false; // Don't display (should already be deleted)
                }
                
                return true;
            });
        
        if (completed.length === 0) {
            container.innerHTML = '<p style="color:#9ca3af;text-align:center;">No completed challenges</p>';
            return;
        }
        
        completed.sort((a, b) => (b[1].completedAt || 0) - (a[1].completedAt || 0));
        
        let html = `
            <table style="width:100%;border-collapse:collapse;">
                <thead>
                    <tr style="background:#f9fafb;border-bottom:2px solid #e5e7eb;">
                        <th style="padding:12px 8px;text-align:left;font-weight:600;">Completed</th>
                        <th style="padding:12px 8px;text-align:left;font-weight:600;">Opponent</th>
                        <th style="padding:12px 8px;text-align:center;font-weight:600;">Your Time</th>
                        <th style="padding:12px 8px;text-align:center;font-weight:600;">Their Time</th>
                        <th style="padding:12px 8px;text-align:center;font-weight:600;">Result</th>
                        <th style="padding:12px 8px;text-align:center;font-weight:600;">Action</th>
                    </tr>
                </thead>
                <tbody>
        `;
        
        completed.forEach(([id, challenge]) => {
            const isCreator = challenge.createdBy === currentUser.uid;
            const opponentId = isCreator ? challenge.challengedUser : challenge.createdBy;
            const opponentName = isCreator ? challenge.opponentName : challenge.creatorName;
            
            // Check if challenge is "new" (unviewed and completed within 7 days)
            const viewedChallenges = JSON.parse(localStorage.getItem('viewedChallenges') || '[]');
            const isViewed = viewedChallenges.includes(id);
            const daysSinceCompleted = (Date.now() - challenge.completedAt) / (1000 * 60 * 60 * 24);
            const isNew = !isViewed && daysSinceCompleted < 7;
            
            // Format completion date
            const completedDate = challenge.completedAt ? new Date(challenge.completedAt).toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric',
                year: 'numeric',
                hour: 'numeric',
                minute: '2-digit'
            }) : 'Unknown';
            
            const myResult = challenge.results && challenge.results[currentUser.uid];
            const theirResult = challenge.results && challenge.results[opponentId];
            
            let myTimeText = '‚Äî';
            let theirTimeText = '‚Äî';
            let resultText = '';
            let resultColor = '';
            let rowBgColor = ''; // For win/loss row coloring
            
            if (myResult) {
                myTimeText = myResult.status === 'DNF' ? '<span style="color:#000000;">Abandoned</span>' : (myResult.time ? myResult.time.toFixed(1) + 's' : '‚Äî');
            }
            
            if (theirResult) {
                theirTimeText = theirResult.status === 'DNF' ? '<span style="color:#000000;">Abandoned</span>' : (theirResult.time ? theirResult.time.toFixed(1) + 's' : '‚Äî');
            }
            
            if (myResult && theirResult) {
                const myDNF = myResult.status === 'DNF';
                const theirDNF = theirResult.status === 'DNF';
                
                if (myDNF && theirDNF) {
                    resultText = 'Both Abandoned';
                    resultColor = '#6b7280';
                    rowBgColor = '';
                } else if (myDNF) {
                    resultText = '‚ùå Loss';
                    resultColor = '#ef4444';
                    rowBgColor = 'background:#fee2e2;'; // Light red
                } else if (theirDNF) {
                    resultText = 'üèÜ Win';
                    resultColor = '#10b981';
                    rowBgColor = 'background:#d1fae5;'; // Light green
                } else if (myResult.time && theirResult.time) {
                    const diff = myResult.time - theirResult.time;
                    if (diff < -0.05) {
                        resultText = `üèÜ Win (+${Math.abs(diff).toFixed(1)}s)`;
                        resultColor = '#10b981';
                        rowBgColor = 'background:#d1fae5;'; // Light green
                    } else if (diff > 0.05) {
                        resultText = `‚ùå Loss (-${diff.toFixed(1)}s)`;
                        resultColor = '#ef4444';
                        rowBgColor = 'background:#fee2e2;'; // Light red
                    } else {
                        resultText = 'ü§ù Tie';
                        resultColor = '#6b7280';
                        rowBgColor = '';
                    }
                }
            }
            
            // Determine row background - prioritize new indicator over win/loss colors
            const rowBg = isNew ? 'background:#fef3c7 !important;' : (rowBgColor ? rowBgColor.replace(';', ' !important;') : ''); // Gold for new, otherwise win/loss color
            const buttonStyle = isNew ? 
                'padding:6px 16px;background:#f59e0b;color:white;border:none;border-radius:4px;cursor:pointer;font-size:0.9rem;font-weight:600;animation:pulse 2s infinite;' :
                'padding:6px 16px;background:#9370db;color:white;border:none;border-radius:4px;cursor:pointer;font-size:0.9rem;';
            const newBadge = isNew ? '<span style="background:#f59e0b;color:white;font-size:0.7rem;padding:2px 6px;border-radius:3px;margin-left:8px;font-weight:600;">NEW</span>' : '';
            
            html += `
                <tr style="${rowBg}border-bottom:1px solid #e5e7eb;">
                    <td style="padding:12px 8px;font-size:0.85rem;color:#6b7280;${rowBg}">${completedDate}</td>
                    <td style="padding:12px 8px;font-weight:500;${rowBg}">${opponentName}${newBadge}</td>
                    <td style="padding:12px 8px;text-align:center;${rowBg}">${myTimeText}</td>
                    <td style="padding:12px 8px;text-align:center;${rowBg}">${theirTimeText}</td>
                    <td style="padding:12px 8px;text-align:center;color:${resultColor};font-weight:600;${rowBg}">${resultText}</td>
                    <td style="padding:12px 8px;text-align:center;${rowBg}">
                        <button onclick="viewH2HComparison('${id}')" style="${buttonStyle}">View</button>
                    </td>
                </tr>
            `;
        });
        
        html += '</tbody></table>';
        container.innerHTML = html;
    }
    
    window.copyToClipboard = function(text) {
        navigator.clipboard.writeText(text).then(() => {
            alert('Challenge link copied to clipboard!');
        }).catch(err => {
            console.error('Failed to copy:', err);
            alert('Failed to copy link');
        });
    };
    
    window.declineChallenge = async function(challengeId) {
        console.log('declineChallenge called for:', challengeId);
        console.log('currentChallengeId:', currentChallengeId);
        console.log('gameStarted:', gameStarted);
        console.log('gameOver:', gameOver);
        
        // Check if challenge is active (you're currently playing it)
        if (currentChallengeId === challengeId && gameStarted && !gameOver) {
            alert('Cannot decline a challenge while playing it!');
            return;
        }
        
        // Check if you've already started this challenge
        try {
            const snapshot = await database.ref(`challenges/${challengeId}/results/${currentUser.uid}`).once('value');
            const myResult = snapshot.val();
            console.log('My result from Firebase:', myResult);
            if (myResult) {
                alert('Cannot decline a challenge you have already started!');
                return;
            }
        } catch (error) {
            console.error('Error checking challenge status:', error);
        }
        
        if (!confirm('Are you sure you want to decline this challenge?')) return;
        
        try {
            await database.ref(`challenges/${challengeId}`).remove();
            loadH2HChallenges();
        } catch (error) {
            console.error('Error declining challenge:', error);
            alert('Failed to decline challenge');
        }
    };
    
    window.cancelChallenge = async function(challengeId) {
        // Check if challenge is active (you're currently playing it)
        if (currentChallengeId === challengeId && gameStarted && !gameOver) {
            alert('Cannot cancel a challenge while playing it!');
            return;
        }
        
        // Check if you've already started this challenge
        try {
            const snapshot = await database.ref(`challenges/${challengeId}/results/${currentUser.uid}`).once('value');
            const myResult = snapshot.val();
            if (myResult) {
                alert('Cannot cancel a challenge you have already started!');
                return;
            }
        } catch (error) {
            console.error('Error checking challenge status:', error);
        }
        
        if (!confirm('Are you sure you want to cancel this challenge?')) return;
        
        try {
            await database.ref(`challenges/${challengeId}`).remove();
            loadH2HChallenges();
        } catch (error) {
            console.error('Error canceling challenge:', error);
            alert('Failed to cancel challenge');
        }
    };
    
    window.playChallenge = async function(challengeId) {
        if (!currentUser) {
            alert('Please sign in to play challenges');
            return;
        }
        
        currentChallengeId = challengeId;
        
        const challengeSnapshot = await database.ref(`challenges/${challengeId}`).once('value');
        const challenge = challengeSnapshot.val();
        
        if (!challenge) {
            alert('Challenge not found');
            return;
        }
        
        // Check if this is an open challenge (handle both null and undefined)
        const isOpenChallenge = challenge.isOpen === true && (challenge.challengedUser === null || challenge.challengedUser === undefined);
        
        // Validate that current user can play this challenge
        const isCreator = challenge.createdBy === currentUser.uid;
        const isChallenged = challenge.challengedUser === currentUser.uid;
        
        console.log('Challenge check:', {
            isOpen: challenge.isOpen,
            challengedUser: challenge.challengedUser,
            isOpenChallenge,
            isCreator,
            isChallenged,
            currentUserUid: currentUser.uid
        });
        
        if (!isCreator && !isChallenged && !isOpenChallenge) {
            alert('This challenge is not for you. You can only play challenges that you created or that were sent to you.');
            return;
        }
        
        // If open challenge, claim it for this user
        if (isOpenChallenge && !isCreator) {
            try {
                await database.ref(`challenges/${challengeId}`).update({
                    challengedUser: currentUser.uid,
                    opponentName: currentUser.displayName || currentUser.email,
                    isOpen: false,
                    claimedAt: Date.now()
                });
                console.log('Open challenge claimed by:', currentUser.displayName || currentUser.email);
            } catch (error) {
                console.error('Error claiming challenge:', error);
                alert('Error claiming challenge');
                return;
            }
        }
        
        const userResult = challenge.results && challenge.results[currentUser.uid];
        if (userResult && (userResult.status === 'DNF' || userResult.time)) {
            alert('You have already completed this challenge');
            return;
        }
        
        if (userResult && userResult.status === 'in_progress') {
            alert('You already started this challenge and it was marked as Abandoned');
            return;
        }
        
        // Set up challenge mode (but don't start yet - wait for Start button)
        gameMode = 'h2h_challenge';
        dailyPlateSequence = challenge.plateSequence;
        console.log('H2H Challenge loaded! Sequence length:', dailyPlateSequence?.length);
        console.log('First 5 plates:', dailyPlateSequence?.slice(0, 5));
        
        // Update mode indicator for H2H
        const opponentName = isCreator ? (challenge.opponentName || 'Open Challenge') : challenge.creatorName;
        
        // Update button styles - both grey
        document.getElementById('practiceBtn').style.background = '#e5e7eb';
        document.getElementById('practiceBtn').style.border = '2px solid #9ca3af';
        document.getElementById('dailyChallengeBtn').style.background = '#e5e7eb';
        document.getElementById('dailyChallengeBtn').style.border = '2px solid #9ca3af';
        
        // Disable mode buttons during H2H challenge
        document.getElementById('practiceBtn').disabled = true;
        document.getElementById('dailyChallengeBtn').disabled = true;
        
        // Update banner
        const mi = document.getElementById('modeIndicator');
        mi.textContent = `‚öîÔ∏è H2H Challenge vs ${opponentName} - One attempt only!`;
        mi.style.background = '#fef3c7';
        mi.style.color = '#92400e';
        mi.style.border = '2px solid #fbbf24';
        
        // Scroll to top to show the game area
        window.scrollTo({ top: 0, behavior: 'smooth' });
        
        // Show Start Game button
        const startBtn = document.getElementById('startButton');
        startBtn.textContent = 'Start Challenge';
        startBtn.style.display = 'inline-block';
    };
    
    async function markChallengeDNF() {
        if (!currentChallengeId) return;
        
        try {
            await database.ref(`challenges/${currentChallengeId}/results/${currentUser.uid}`).update({
                status: 'DNF',
                completedAt: Date.now()
            });
            
            // Check if both players are done and mark challenge as completed
            const challengeSnapshot = await database.ref(`challenges/${currentChallengeId}`).once('value');
            const challenge = challengeSnapshot.val();
            
            if (challenge && challenge.results) {
                const creatorResult = challenge.results[challenge.createdBy];
                const challengedResult = challenge.results[challenge.challengedUser];
                
                // Check if both players have completed or abandoned
                if (creatorResult && challengedResult && 
                    (creatorResult.status === 'completed' || creatorResult.status === 'DNF') &&
                    (challengedResult.status === 'completed' || challengedResult.status === 'DNF')) {
                    
                    // If both abandoned, delete the challenge
                    if (creatorResult.status === 'DNF' && challengedResult.status === 'DNF') {
                        await database.ref(`challenges/${currentChallengeId}`).remove();
                        console.log('Both players abandoned - challenge deleted');
                    } else {
                        // Otherwise just mark as completed
                        await database.ref(`challenges/${currentChallengeId}`).update({
                            status: 'completed',
                            completedAt: Date.now()
                        });
                    }
                }
            }
            
            alert('Challenge timed out - marked as Abandoned');
            currentChallengeId = null;
            challengeStartTime = null;
            gameMode = 'practice';
            resetGame();
            
            // Reload H2H challenges
            setTimeout(() => {
                loadH2HChallenges();
            }, 500);
        } catch (error) {
            console.error('Error marking DNF:', error);
        }
    }
    
    async function saveChallengeResult(time, solved, skipped) {
        if (!currentUser || !currentChallengeId || gameMode !== 'h2h_challenge') return;
        
        const historyData = gameHistory.map(entry => ({
            plate: entry.plate,
            word: entry.word,
            skipped: entry.skipped || false,
            thinkingSeconds: Math.floor(entry.thinkingSeconds * 10) / 10,
            penaltySeconds: entry.penaltySeconds || 0
        }));
        
        await database.ref(`challenges/${currentChallengeId}/results/${currentUser.uid}`).set({
            time: Math.floor(time * 10) / 10,
            solved: solved,
            skipped: skipped,
            completedAt: Date.now(),
            history: historyData,
            status: 'completed'
        });
        
        const challengeSnapshot = await database.ref(`challenges/${currentChallengeId}`).once('value');
        const challenge = challengeSnapshot.val();
        
        if (challenge && challenge.results) {
            const creatorResult = challenge.results[challenge.createdBy];
            const challengedResult = challenge.results[challenge.challengedUser];
            
            if (creatorResult && challengedResult && 
                (creatorResult.status === 'completed' || creatorResult.status === 'DNF') &&
                (challengedResult.status === 'completed' || challengedResult.status === 'DNF')) {
                await database.ref(`challenges/${currentChallengeId}`).update({
                    status: 'completed',
                    completedAt: Date.now()
                });
            }
        }
        
        currentChallengeId = null;
        challengeStartTime = null;
        gameMode = 'practice';
        
        // Reload H2H challenges to update the display
        setTimeout(() => {
            loadH2HChallenges();
        }, 500);
    }
    
    async function checkAbandonedChallenges(userId) {
        try {
            const challengesSnapshot = await database.ref('challenges').once('value');
            const allChallenges = challengesSnapshot.val() || {};
            
            for (const [challengeId, challenge] of Object.entries(allChallenges)) {
                const userResult = challenge.results && challenge.results[userId];
                
                if (userResult && userResult.status === 'in_progress' && !userResult.time) {
                    await database.ref(`challenges/${challengeId}/results/${userId}`).update({
                        status: 'DNF',
                        completedAt: Date.now()
                    });
                    
                    // Re-fetch challenge to get updated results
                    const updatedSnapshot = await database.ref(`challenges/${challengeId}`).once('value');
                    const updatedChallenge = updatedSnapshot.val();
                    
                    if (updatedChallenge && updatedChallenge.results) {
                        const creatorResult = updatedChallenge.results[updatedChallenge.createdBy];
                        const challengedResult = updatedChallenge.results[updatedChallenge.challengedUser];
                        
                        if (creatorResult && challengedResult && 
                            (creatorResult.status === 'completed' || creatorResult.status === 'DNF') &&
                            (challengedResult.status === 'completed' || challengedResult.status === 'DNF')) {
                            await database.ref(`challenges/${challengeId}`).update({
                                status: 'completed',
                                completedAt: Date.now()
                            });
                        }
                    }
                }
            }
        } catch (error) {
            console.error('Error checking abandoned challenges:', error);
        }
    }
    // ========== END HEAD-TO-HEAD FEATURE ==========

    loadDictionary();
    loadDifficulty();
</script>

<script>
// Auto-load today's leaderboard when page is fully loaded
window.addEventListener('load', function() {
    // Tab switching - must be after DOM is loaded
    document.getElementById('dailyLeaderboardTab').addEventListener('click', function() {
        console.log('Daily tab clicked');
        document.getElementById('dailyLeaderboardContent').style.display = 'block';
        document.getElementById('h2hContent').style.display = 'none';
        this.style.borderBottom = '3px solid #9370db';
        this.style.color = '#9370db';
        this.style.fontWeight = '600';
        document.getElementById('h2hTab').style.borderBottom = 'none';
        document.getElementById('h2hTab').style.color = '#9ca3af';
        document.getElementById('h2hTab').style.fontWeight = '400';
    });
    
    document.getElementById('h2hTab').addEventListener('click', function() {
        console.log('H2H tab clicked');
        document.getElementById('dailyLeaderboardContent').style.display = 'none';
        document.getElementById('h2hContent').style.display = 'block';
        this.style.borderBottom = '3px solid #9370db';
        this.style.color = '#9370db';
        this.style.fontWeight = '600';
        document.getElementById('dailyLeaderboardTab').style.borderBottom = 'none';
        document.getElementById('dailyLeaderboardTab').style.color = '#9ca3af';
        document.getElementById('dailyLeaderboardTab').style.fontWeight = '400';
        
        // Load H2H challenges when tab is clicked
        loadH2HChallenges();
    });
    
    // Create Challenge button
    document.getElementById('createChallengeBtn').addEventListener('click', async function() {
        if (!currentUser) {
            alert('Please sign in to create challenges');
            return;
        }
        
        try {
            const usersSnapshot = await database.ref('users').once('value');
            const users = usersSnapshot.val();
            
            if (!users) {
                alert('No other users found');
                return;
            }
            
            const userList = Object.entries(users)
                .filter(([uid, data]) => uid !== currentUser.uid)
                .map(([uid, data]) => ({ uid, name: data.displayName || data.email || 'Unknown' }))
                .sort((a, b) => a.name.localeCompare(b.name));
            
            if (userList.length === 0) {
                alert('No other users found');
                return;
            }
            
            // Show opponent selection modal
            showOpponentModal(userList);
            
        } catch (error) {
            console.error('Error loading users:', error);
            alert('Error loading users: ' + error.message);
        }
    });
    
    // Create Open Challenge button
    document.getElementById('createOpenChallengeBtn').addEventListener('click', async function() {
        if (!currentUser) {
            alert('Please sign in to create challenges');
            return;
        }
        
        // Ask for optional label
        const label = prompt('Who are you challenging? This is just for your reference.');
        
        // If user clicks Cancel on prompt, stop
        if (label === null) {
            return;
        }
        
        try {
            const challengeId = database.ref('challenges').push().key;
            const plateSequence = generateChallengeSequence();
            
            if (plateSequence.length < 100) {
                alert('Error generating plates');
                return;
            }
            
            const opponentName = label && label.trim() ? label.trim() : 'Open Challenge';
            
            await database.ref(`challenges/${challengeId}`).set({
                createdBy: currentUser.uid,
                creatorName: currentUser.displayName || currentUser.email,
                challengedUser: null, // Open challenge - no specific user
                opponentName: opponentName,
                isOpen: true,
                plateSequence: plateSequence,
                createdAt: Date.now(),
                expiresAt: Date.now() + (7 * 24 * 60 * 60 * 1000),
                status: 'pending',
                results: {}
            });
            
            // Copy link to clipboard
            const challengeUrl = `${window.location.origin}${window.location.pathname}?challenge=${challengeId}`;
            try {
                await navigator.clipboard.writeText(challengeUrl);
                alert(`Open challenge created${label && label.trim() ? ` for "${label.trim()}"` : ''}! Link copied to clipboard.`);
            } catch (err) {
                alert(`Open challenge created! Share this link:\n${challengeUrl}`);
            }
            
            loadH2HChallenges();
            
        } catch (error) {
            console.error('Error creating open challenge:', error);
            alert('Error creating open challenge: ' + error.message);
        }
    });
    
    // Show opponent selection modal
    function showOpponentModal(userList) {
        const modal = document.getElementById('opponentModalBackdrop');
        const listContainer = document.getElementById('opponentList');
        const searchInput = document.getElementById('opponentSearchInput');
        
        // Render user list
        function renderUserList(filter = '') {
            const filtered = filter 
                ? userList.filter(u => u.name.toLowerCase().startsWith(filter.toLowerCase()))
                : userList;
            
            if (filtered.length === 0) {
                listContainer.innerHTML = '<p style="text-align:center;color:#9ca3af;padding:20px;">No users found</p>';
                return;
            }
            
            listContainer.innerHTML = filtered.map(user => `
                <div 
                    class="opponent-item" 
                    data-uid="${user.uid}"
                    style="padding:12px 16px;cursor:pointer;border-bottom:1px solid #f3f4f6;transition:background 0.2s;"
                    onmouseover="this.style.background='#f9fafb'"
                    onmouseout="this.style.background='white'"
                >
                    <div style="font-weight:500;color:#1f2937;">${user.name}</div>
                </div>
            `).join('');
            
            // Add click handlers
            document.querySelectorAll('.opponent-item').forEach(item => {
                item.addEventListener('click', function() {
                    const uid = this.dataset.uid;
                    const user = userList.find(u => u.uid === uid);
                    modal.classList.remove('show');
                    searchInput.value = '';
                    prepareChallenge(user);
                });
            });
        }
        
        // Search functionality
        searchInput.value = '';
        searchInput.oninput = (e) => renderUserList(e.target.value);
        
        renderUserList();
        modal.classList.add('show');
        searchInput.focus();
    }
    
    // Modal close handlers
    document.getElementById('opponentModalCloseBtn').addEventListener('click', () => {
        document.getElementById('opponentModalBackdrop').classList.remove('show');
        document.getElementById('opponentSearchInput').value = '';
    });
    
    document.getElementById('opponentModalBackdrop').addEventListener('click', (e) => {
        if (e.target.id === 'opponentModalBackdrop') {
            document.getElementById('opponentModalBackdrop').classList.remove('show');
            document.getElementById('opponentSearchInput').value = '';
        }
    });
    
    // H2H Comparison Modal
    document.getElementById('h2hComparisonCloseBtn').addEventListener('click', () => {
        document.getElementById('h2hComparisonModalBackdrop').classList.remove('show');
    });
    
    document.getElementById('h2hComparisonModalBackdrop').addEventListener('click', (e) => {
        if (e.target.id === 'h2hComparisonModalBackdrop') {
            document.getElementById('h2hComparisonModalBackdrop').classList.remove('show');
        }
    });
    
    // View H2H Comparison
    window.viewH2HComparison = async function(challengeId) {
        try {
            console.log('viewH2HComparison called with challengeId:', challengeId);
            console.log('currentUser:', currentUser);
            
            // Mark this challenge as viewed in localStorage
            const viewedChallenges = JSON.parse(localStorage.getItem('viewedChallenges') || '[]');
            if (!viewedChallenges.includes(challengeId)) {
                viewedChallenges.push(challengeId);
                localStorage.setItem('viewedChallenges', JSON.stringify(viewedChallenges));
                // Refresh badge count
                loadH2HChallenges();
            }
            
            if (!currentUser) {
                alert('Please sign in to view challenges');
                return;
            }
            
            const snapshot = await database.ref(`challenges/${challengeId}`).once('value');
            const challenge = snapshot.val();
            
            console.log('Challenge data:', challenge);
            
            if (!challenge) {
                alert('Challenge not found');
                return;
            }
            
            const isCreator = challenge.createdBy === currentUser.uid;
            const myName = currentUser.displayName || currentUser.email;
            const opponentName = isCreator ? challenge.opponentName : challenge.creatorName;
            const opponentId = isCreator ? challenge.challengedUser : challenge.createdBy;
            
            const myResult = challenge.results && challenge.results[currentUser.uid];
            const theirResult = challenge.results && challenge.results[opponentId];
            
            console.log('My result:', myResult);
            console.log('Their result:', theirResult);
            
            // Update title
            document.getElementById('h2hComparisonTitle').textContent = `${myName} vs ${opponentName}`;
            
            // Build unified comparison table
            const content = document.getElementById('h2hComparisonContent');
            
            if (!myResult || !theirResult) {
                content.innerHTML = '<p style="text-align:center;color:#6b7280;">Incomplete challenge data</p>';
                document.getElementById('h2hComparisonModalBackdrop').classList.add('show');
                return;
            }
            
            // Get histories (should be same length for H2H)
            const myHistory = myResult.history || [];
            const theirHistory = theirResult.history || [];
            const maxLength = Math.max(myHistory.length, theirHistory.length);
            
            console.log('My history length:', myHistory.length);
            console.log('Their history length:', theirHistory.length);
            console.log('My stored time:', myResult.time);
            console.log('Their stored time:', theirResult.time);
            
            let tableRows = '';
            let myTotalTime = 0;
            let theirTotalTime = 0;
            let cumulativeDiff = 0;
            
            for (let i = 0; i < maxLength; i++) {
                const myEntry = myHistory[i];
                const theirEntry = theirHistory[i];
                
                const plate = myEntry?.plate || theirEntry?.plate || '‚Äî';
                
                // Helper function for time-based gradient color
                function getTimeCellColor(seconds) {
                    if (seconds <= 0) return '#f3f4f6'; // Gray for no entry
                    if (seconds <= 1.5) return '#22c55e'; // Green (under 1.5s)
                    if (seconds >= 30) return '#ef4444'; // Dark red (30s+)
                    
                    if (seconds <= 6) {
                        // Green to white (1.5s ‚Üí 6s)
                        const ratio = (seconds - 1.5) / 4.5;
                        const r = Math.round(34 + (255 - 34) * ratio);
                        const g = Math.round(197 + (255 - 197) * ratio);
                        const b = Math.round(94 + (255 - 94) * ratio);
                        return `rgb(${r},${g},${b})`;
                    } else {
                        // White to red (6s ‚Üí 30s)
                        const ratio = (seconds - 6) / 24;
                        const r = 255;
                        const g = Math.round(255 - (255 - 68) * ratio);
                        const b = Math.round(255 - (255 - 68) * ratio);
                        return `rgb(${r},${g},${b})`;
                    }
                }
                
                // My cell content
                let myCell = '';
                let myTime = 0;
                let myCellBg = '#f3f4f6';
                if (myEntry) {
                    // Always add thinking time + penalty time
                    const thinkingTime = myEntry.thinkingSeconds || 0;
                    const penaltyTime = myEntry.penaltySeconds || 0;
                    myTime = thinkingTime + penaltyTime;
                    
                    if (myEntry.skipped) {
                        // Skipped plates: show red X with time inline (smaller)
                        myCell = `<div style="font-size:0.85rem;font-weight:600;color:#ef4444;">‚úó &nbsp;${myTime.toFixed(1)}s</div>`;
                        myCellBg = '#000000';
                    } else {
                        // Valid words: show word with time inline (more spacing)
                        myCellBg = getTimeCellColor(thinkingTime);
                        myCell = `<div style="font-size:0.9rem;font-weight:600;color:#000;">${myEntry.word || '‚Äî'} &nbsp;<span style="font-size:0.75rem;font-weight:400;">${myTime.toFixed(1)}s</span></div>`;
                    }
                    myTotalTime += myTime;
                } else {
                    myCell = '<div style="font-size:1rem;color:#9ca3af;">‚Äî</div>';
                }
                
                // Their cell content
                let theirCell = '';
                let theirTime = 0;
                let theirCellBg = '#f3f4f6';
                if (theirEntry) {
                    // Always add thinking time + penalty time
                    const thinkingTime = theirEntry.thinkingSeconds || 0;
                    const penaltyTime = theirEntry.penaltySeconds || 0;
                    theirTime = thinkingTime + penaltyTime;
                    
                    if (theirEntry.skipped) {
                        // Skipped plates: show red X with time inline (smaller)
                        theirCell = `<div style="font-size:0.85rem;font-weight:600;color:#ef4444;">‚úó &nbsp;${theirTime.toFixed(1)}s</div>`;
                        theirCellBg = '#000000';
                    } else {
                        // Valid words: show word with time inline (more spacing)
                        theirCellBg = getTimeCellColor(thinkingTime);
                        theirCell = `<div style="font-size:0.9rem;font-weight:600;color:#000;">${theirEntry.word || '‚Äî'} &nbsp;<span style="font-size:0.75rem;font-weight:400;">${theirTime.toFixed(1)}s</span></div>`;
                    }
                    theirTotalTime += theirTime;
                } else {
                    theirCell = '<div style="font-size:1rem;color:#9ca3af;">‚Äî</div>';
                }
                
                // Differential cell - calculate for all cases
                // Their time - my time (positive = you're faster/ahead)
                const diff = theirTime - myTime;
                let diffCell = '';
                let cumulativeDiffCell = '';
                
                // Update cumulative differential
                cumulativeDiff += diff;
                
                // Format differential cell
                if (myEntry || theirEntry) {
                    if (Math.abs(diff) < 0.05) {
                        diffCell = '<div style="font-size:0.95rem;font-weight:600;color:#6b7280;">0.0s</div>';
                    } else if (diff > 0) {
                        // You're faster (positive) = green text
                        diffCell = `<div style="font-size:0.95rem;font-weight:700;color:#16a34a;">+${diff.toFixed(1)}s</div>`;
                    } else {
                        // You're slower (negative) = red text
                        diffCell = `<div style="font-size:0.95rem;font-weight:700;color:#dc2626;">${diff.toFixed(1)}s</div>`;
                    }
                    
                    // Format cumulative differential cell
                    if (Math.abs(cumulativeDiff) < 0.05) {
                        cumulativeDiffCell = '<div style="font-size:0.95rem;font-weight:600;color:#6b7280;">0.0s</div>';
                    } else if (cumulativeDiff > 0) {
                        cumulativeDiffCell = `<div style="font-size:0.95rem;font-weight:700;color:#16a34a;">+${cumulativeDiff.toFixed(1)}s</div>`;
                    } else {
                        cumulativeDiffCell = `<div style="font-size:0.95rem;font-weight:700;color:#dc2626;">${cumulativeDiff.toFixed(1)}s</div>`;
                    }
                } else {
                    diffCell = '<div style="font-size:1rem;color:#9ca3af;">‚Äî</div>';
                    cumulativeDiffCell = '<div style="font-size:1rem;color:#9ca3af;">‚Äî</div>';
                }
                
                tableRows += `
                    <tr>
                        <td style="padding:8px 6px;font-weight:700;font-size:0.9rem;background:#f9fafb;border-right:2px solid #e5e7eb;text-align:center;">${plate}</td>
                        <td style="padding:8px 6px;background:${myCellBg};border-right:2px solid #e5e7eb;text-align:center;">${myCell}</td>
                        <td style="padding:8px 6px;background:${theirCellBg};border-right:2px solid #e5e7eb;text-align:center;">${theirCell}</td>
                        <td style="padding:8px 6px;background:#ffffff;border-right:2px solid #e5e7eb;text-align:center;">${diffCell}</td>
                        <td style="padding:8px 6px;background:#ffffff;text-align:center;">${cumulativeDiffCell}</td>
                    </tr>
                `;
            }
            
            console.log('Calculated myTotalTime:', myTotalTime);
            console.log('Calculated theirTotalTime:', theirTotalTime);
            console.log('Stored myResult.time:', myResult.time);
            console.log('Stored theirResult.time:', theirResult.time);
            
            // Use stored time (more accurate) instead of calculated sum
            // The calculated sum has rounding errors from individual plate times
            const myFinalTime = myResult.time || myTotalTime;
            const theirFinalTime = theirResult.time || theirTotalTime;
            
            // Determine win/loss/tie (their time - my time)
            const finalDiff = theirFinalTime - myFinalTime;
            let resultText = '';
            let headerBg = '#e5e7eb';
            let finalDiffText = '';
            let finalDiffColor = '#6b7280';
            
            if (myResult.status === 'DNF' && theirResult.status === 'DNF') {
                resultText = 'Both Abandoned';
                headerBg = '#e5e7eb';
            } else if (myResult.status === 'DNF') {
                resultText = 'Loss';
                headerBg = '#fca5a5';
                finalDiffText = 'Abandoned';
            } else if (theirResult.status === 'DNF') {
                resultText = 'Win';
                headerBg = '#86efac';
                finalDiffText = 'Opponent Abandoned';
            } else if (Math.abs(finalDiff) < 0.05) {
                resultText = 'Tie';
                finalDiffText = '0.0s';
            } else if (finalDiff > 0) {
                // Positive = you won
                resultText = 'Win';
                headerBg = '#86efac';
                finalDiffText = `+${finalDiff.toFixed(1)}s`;
                finalDiffColor = '#16a34a';
            } else {
                // Negative = you lost
                resultText = 'Loss';
                headerBg = '#fca5a5';
                finalDiffText = `${finalDiff.toFixed(1)}s`;
                finalDiffColor = '#dc2626';
            }
            
            // Format completed date
            const completedDate = challenge.completedAt ? new Date(challenge.completedAt).toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric',
                year: 'numeric'
            }) : 'Unknown';
            
            const myStatus = myResult.status === 'DNF' ? 'Abandoned' : `${myFinalTime.toFixed(1)}s`;
            const theirStatus = theirResult.status === 'DNF' ? 'Abandoned' : `${theirFinalTime.toFixed(1)}s`;
            
            // Update modal title with stats
            document.getElementById('h2hComparisonTitle').innerHTML = `
                <div style="font-size:1.1rem;font-weight:700;">${resultText} vs ${opponentName}</div>
                <div style="font-size:0.85rem;font-weight:400;margin-top:4px;">${completedDate} ‚Ä¢ ${myStatus} vs ${theirStatus} ‚Ä¢ Margin: ${finalDiffText}</div>
            `;
            document.querySelector('#h2hComparisonModalBackdrop .modal-header').style.background = headerBg;
            
            // Prepare cumulative time data and differential for chart
            const myCumulative = [];
            const theirCumulative = [];
            const differential = []; // Their time - your time (positive = you're ahead)
            let mySum = 0;
            let theirSum = 0;
            
            for (let i = 0; i < maxLength; i++) {
                const myEntry = myHistory[i];
                const theirEntry = theirHistory[i];
                
                if (myEntry) {
                    const thinkingTime = myEntry.thinkingSeconds || 0;
                    const penaltyTime = myEntry.penaltySeconds || 0;
                    mySum += thinkingTime + penaltyTime;
                }
                myCumulative.push(mySum);
                
                if (theirEntry) {
                    const thinkingTime = theirEntry.thinkingSeconds || 0;
                    const penaltyTime = theirEntry.penaltySeconds || 0;
                    theirSum += thinkingTime + penaltyTime;
                }
                theirCumulative.push(theirSum);
                
                // Calculate differential (their time - your time)
                // Positive = you're ahead, negative = you're behind
                differential.push(theirSum - mySum);
            }
            
            content.innerHTML = `
                <div style="margin-bottom:12px;text-align:center;border-bottom:2px solid #e5e7eb;">
                    <button id="tableViewTab" class="view-tab" style="padding:12px 24px;background:transparent;color:#9370db;border:none;border-bottom:3px solid #9370db;cursor:pointer;font-weight:600;font-size:0.95rem;">
                        Table
                    </button>
                    <button id="chartViewTab" class="view-tab" style="padding:12px 24px;background:transparent;color:#6b7280;border:none;border-bottom:3px solid transparent;cursor:pointer;font-weight:400;font-size:0.95rem;">
                        Chart
                    </button>
                </div>
                
                <div id="tableView">
                    <table style="width:100%;border-collapse:collapse;background:white;border:2px solid #e5e7eb;">
                        <thead>
                            <tr style="background:#e5e7eb;">
                                <th style="padding:10px 8px;text-align:center;font-weight:700;font-size:0.9rem;border-right:2px solid #e5e7eb;width:10%;">Plate</th>
                                <th style="padding:10px 8px;text-align:center;font-weight:700;font-size:0.9rem;border-right:2px solid #e5e7eb;width:30%;">${myName}</th>
                                <th style="padding:10px 8px;text-align:center;font-weight:700;font-size:0.9rem;border-right:2px solid #e5e7eb;width:30%;">${opponentName}</th>
                                <th style="padding:10px 8px;text-align:center;font-weight:700;font-size:0.9rem;border-right:2px solid #e5e7eb;width:15%;">Diff</th>
                                <th style="padding:10px 8px;text-align:center;font-weight:700;font-size:0.9rem;width:15%;">Cumulative</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${tableRows}
                            <tr style="border-top:3px solid #9370db;">
                                <td style="padding:12px 8px;font-weight:700;font-size:0.9rem;background:#f3f4f6;border-right:2px solid #e5e7eb;text-align:center;">TOTAL</td>
                                <td style="padding:10px 8px;background:#e5e7eb;border-right:2px solid #e5e7eb;text-align:center;font-weight:600;font-size:0.95rem;">${myStatus}</td>
                                <td style="padding:10px 8px;background:#e5e7eb;border-right:2px solid #e5e7eb;text-align:center;font-weight:600;font-size:0.95rem;">${theirStatus}</td>
                                <td style="padding:10px 8px;background:#ffffff;border-right:2px solid #e5e7eb;text-align:center;">
                                    <div style="font-size:1rem;font-weight:700;color:${finalDiffColor};">${finalDiffText}</div>
                                </td>
                                <td style="padding:10px 8px;background:#ffffff;text-align:center;">
                                    <div style="font-size:1rem;font-weight:700;color:${finalDiffColor};">${finalDiffText}</div>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                
                <div id="chartView" style="display:none;position:relative;">
                    <canvas id="comparisonChart" width="1600" height="800" style="max-width:100%;height:auto;"></canvas>
                    <div id="chartTooltip" style="position:absolute;background:rgba(0,0,0,0.9);color:white;padding:12px 16px;border-radius:6px;font-size:14px;font-weight:500;pointer-events:none;display:none;z-index:1000;line-height:1.6;"></div>
                </div>
            `;

            // Tab switching functionality
            document.getElementById('tableViewTab').addEventListener('click', function() {
                document.getElementById('tableView').style.display = 'block';
                document.getElementById('chartView').style.display = 'none';
                this.style.borderBottom = '3px solid #9370db';
                this.style.color = '#9370db';
                this.style.fontWeight = '600';
                document.getElementById('chartViewTab').style.borderBottom = '3px solid transparent';
                document.getElementById('chartViewTab').style.color = '#6b7280';
                document.getElementById('chartViewTab').style.fontWeight = '400';
            });
            
            document.getElementById('chartViewTab').addEventListener('click', function() {
                document.getElementById('tableView').style.display = 'none';
                document.getElementById('chartView').style.display = 'block';
                this.style.borderBottom = '3px solid #9370db';
                this.style.color = '#9370db';
                this.style.fontWeight = '600';
                document.getElementById('tableViewTab').style.borderBottom = '3px solid transparent';
                document.getElementById('tableViewTab').style.color = '#6b7280';
                document.getElementById('tableViewTab').style.fontWeight = '400';
                drawChart();
            });
            
            // Determine winner colors
            const iWon = finalDiff < 0;
            const myColor = iWon ? '#10b981' : '#ef4444'; // Green if won, red if lost
            const theirColor = iWon ? '#ef4444' : '#10b981'; // Opposite
            
            // Draw chart function
            function drawChart() {
                const canvas = document.getElementById('comparisonChart');
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                
                // Padding
                const padding = { top: 60, right: 40, bottom: 50, left: 80 };
                const chartWidth = width - padding.left - padding.right;
                const chartHeight = height - padding.top - padding.bottom;
                
                // Find max/min differential for Y axis
                const maxDiff = Math.max(...differential.map(Math.abs));
                const yMax = Math.ceil(maxDiff / 10) * 10; // Round up to nearest 10
                const yMin = -yMax; // Symmetric around zero
                
                // Draw background
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, width, height);
                
                // Draw zero line (thicker, darker)
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 3;
                const zeroY = padding.top + chartHeight / 2;
                ctx.beginPath();
                ctx.moveTo(padding.left, zeroY);
                ctx.lineTo(width - padding.right, zeroY);
                ctx.stroke();
                
                // Draw grid lines
                ctx.strokeStyle = '#e5e7eb';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 6; i++) {
                    if (i === 3) continue; // Skip zero line (already drawn)
                    const y = padding.top + (chartHeight * i / 6);
                    ctx.beginPath();
                    ctx.moveTo(padding.left, y);
                    ctx.lineTo(width - padding.right, y);
                    ctx.stroke();
                }
                
                // Draw Y axis labels
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 20px sans-serif';
                ctx.textAlign = 'right';
                for (let i = 0; i <= 6; i++) {
                    const value = yMax - ((yMax - yMin) * i / 6);
                    const y = padding.top + (chartHeight * i / 6);
                    const label = value > 0 ? '+' + value.toFixed(0) + 's' : value.toFixed(0) + 's';
                    ctx.fillText(label, padding.left - 15, y + 7);
                }
                
                // Draw X axis labels
                ctx.font = 'bold 20px sans-serif';
                ctx.textAlign = 'center';
                const actualLength = Math.max(myHistory.length, theirHistory.length);
                const xStep = actualLength <= 15 ? 1 : 5;
                for (let i = 0; i < actualLength; i += xStep) {
                    const x = padding.left + (chartWidth * i / (actualLength - 1));
                    ctx.fillText((i + 1).toString(), x, height - padding.bottom + 30);
                }
                
                // Draw axis labels
                ctx.font = 'bold 24px sans-serif';
                ctx.fillText('Plate Number', width / 2, height - 10);
                ctx.save();
                ctx.translate(20, height / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('Time Differential (s)', 0, 0);
                ctx.restore();
                
                // Add "Ahead/Behind" labels
                ctx.font = 'bold 18px sans-serif';
                ctx.fillStyle = '#10b981';
                ctx.textAlign = 'left';
                ctx.fillText('Ahead', padding.left + 10, padding.top + 25);
                ctx.fillStyle = '#ef4444';
                ctx.fillText('Behind', padding.left + 10, height - padding.bottom - 10);
                
                // Draw differential line
                ctx.strokeStyle = '#9370db';
                ctx.lineWidth = 4;
                ctx.beginPath();
                
                for (let i = 0; i < actualLength; i++) {
                    const x = padding.left + (chartWidth * i / (actualLength - 1));
                    const diffValue = differential[i] || 0;
                    // Map differential to Y coordinate (positive = ahead = top)
                    const y = padding.top + chartHeight / 2 - (chartHeight / 2 * diffValue / yMax);
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                
                // Draw shaded area between line and zero
                ctx.globalAlpha = 0.2;
                for (let i = 0; i < actualLength - 1; i++) {
                    const x1 = padding.left + (chartWidth * i / (actualLength - 1));
                    const x2 = padding.left + (chartWidth * (i + 1) / (actualLength - 1));
                    const diff1 = differential[i] || 0;
                    const diff2 = differential[i + 1] || 0;
                    const y1 = padding.top + chartHeight / 2 - (chartHeight / 2 * diff1 / yMax);
                    const y2 = padding.top + chartHeight / 2 - (chartHeight / 2 * diff2 / yMax);
                    
                    // Green if ahead (positive), red if behind (negative)
                    ctx.fillStyle = diff1 > 0 ? '#10b981' : '#ef4444';
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.lineTo(x2, zeroY);
                    ctx.lineTo(x1, zeroY);
                    ctx.closePath();
                    ctx.fill();
                }
                ctx.globalAlpha = 1.0;
                
                // Draw data points
                ctx.fillStyle = '#9370db';
                for (let i = 0; i < actualLength; i++) {
                    const x = padding.left + (chartWidth * i / (actualLength - 1));
                    const diffValue = differential[i] || 0;
                    const y = padding.top + chartHeight / 2 - (chartHeight / 2 * diffValue / yMax);
                    ctx.beginPath();
                    ctx.arc(x, y, 8, 0, 2 * Math.PI);
                    ctx.fill();
                }
                
                // Draw legend
                ctx.font = 'bold 22px sans-serif';
                ctx.textAlign = 'left';
                ctx.fillStyle = '#9370db';
                ctx.fillRect(padding.left, 15, 40, 5);
                ctx.fillText('Your Lead/Deficit', padding.left + 50, 25);
                
                // Add tooltip on hover
                const tooltip = document.getElementById('chartTooltip');
                canvas.onmousemove = function(e) {
                    const rect = canvas.getBoundingClientRect();
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    const mouseX = (e.clientX - rect.left) * scaleX;
                    const mouseY = (e.clientY - rect.top) * scaleY;
                    
                    // Check for point hover
                    let found = false;
                    for (let i = 0; i < actualLength; i++) {
                        const x = padding.left + (chartWidth * i / (actualLength - 1));
                        const diffValue = differential[i] || 0;
                        const y = padding.top + chartHeight / 2 - (chartHeight / 2 * diffValue / yMax);
                        const dist = Math.sqrt((mouseX - x) ** 2 + (mouseY - y) ** 2);
                        
                        if (dist < 25) {
                            const plate = myHistory[i]?.plate || theirHistory[i]?.plate || '?';
                            const myWord = myHistory[i] ? (myHistory[i].word || 'Skipped') : '‚Äî';
                            const theirWord = theirHistory[i] ? (theirHistory[i].word || 'Skipped') : '‚Äî';
                            const myTime = myCumulative[i].toFixed(1);
                            const theirTime = theirCumulative[i].toFixed(1);
                            const diffText = diffValue > 0 ? '+' + diffValue.toFixed(1) + 's ahead' : diffValue.toFixed(1) + 's behind';
                            
                            tooltip.innerHTML = 'Plate ' + (i + 1) + ': ' + plate + '<br>' + 
                                               myName + ': ' + myWord + ' (' + myTime + 's)<br>' +
                                               opponentName + ': ' + theirWord + ' (' + theirTime + 's)<br>' +
                                               '<strong>' + diffText + '</strong>';
                            tooltip.style.display = 'block';
                            tooltip.style.left = (e.clientX - rect.left + 15) + 'px';
                            tooltip.style.top = (e.clientY - rect.top - 60) + 'px';
                            canvas.style.cursor = 'pointer';
                            found = true;
                            break;
                        }
                    }
                    
                    if (!found) {
                        canvas.style.cursor = 'default';
                        tooltip.style.display = 'none';
                    }
                };
                
                canvas.onmouseleave = function() {
                    tooltip.style.display = 'none';
                };
            }
            
            // Show modal
            document.getElementById('h2hComparisonModalBackdrop').classList.add('show');
            
        } catch (error) {
            console.error('Error loading challenge comparison:', error);
            alert('Error loading challenge data');
        }
    };
    
    // Check for challenge URL parameter
    
    // Check for abandoned challenges when user logs in
    if (currentUser) {
        checkAbandonedChallenges(currentUser.uid);
    }
    
    setTimeout(function() {
        try {
            const today = getTodayString();
            const datePicker = document.getElementById('leaderboardDatePicker');
            if (datePicker) {
                datePicker.value = today;
                datePicker.max = today;
                displayLeaderboard(today);
                // Auto-loaded
            }
        } catch (error) {
            console.error('Error auto-loading leaderboard:', error);
        }
    }, 500); // Wait 2 seconds for Firebase to connect
});
</script>




<!-- Player Run Details Modal -->
<div id="runDetailsModalBackdrop" class="modal-backdrop" onclick="if(event.target.id==='runDetailsModalBackdrop')closeRunDetailsModal()">
    <div class="modal">
        <div class="modal-header">
            <div class="modal-title" id="runDetailsModalTitle">Player's Run</div>
            <button class="modal-close-btn" onclick="closeRunDetailsModal()">&times;</button>
        </div>
        <div class="modal-body">
            <div id="runDetailsContent"></div>
        </div>
        <div class="modal-footer">
            <button onclick="closeRunDetailsModal()">Close</button>
        </div>
    </div>
</div>

<div id="leaderboardSection" style="margin-top:40px;padding:20px;background:#f9fafb;border-radius:8px;">
    <!-- Tab Headers -->
    <div style="display:flex;gap:10px;border-bottom:2px solid #e5e7eb;margin-bottom:20px;">
        <h2 id="dailyLeaderboardTab" style="margin:0;padding:10px 20px;cursor:pointer;border-bottom:3px solid #9370db;color:#9370db;font-weight:600;">üèÜ Daily Leaderboard</h2>
        <h2 id="h2hTab" style="margin:0;padding:10px 20px;cursor:pointer;color:#9ca3af;font-weight:400;border-bottom:none;position:relative;">
            ‚öîÔ∏è Head-to-Head
            <span id="h2hNotificationBadge" style="display:none;position:absolute;top:8px;right:8px;background:#ef4444;color:white;border-radius:50%;width:20px;height:20px;font-size:12px;line-height:20px;text-align:center;font-weight:600;"></span>
        </h2>
    </div>
    
    <!-- Daily Leaderboard Content (keep ALL original elements) -->
    <div id="dailyLeaderboardContent">
        <h2 style="margin-top:0;display:none;" id="leaderboardTitle">üèÜ Daily Leaderboard</h2>
        <div style="margin-bottom:20px;display:flex;gap:10px;align-items:center;flex-wrap:wrap;">
            <label for="leaderboardDatePicker" style="font-weight:600;">Date:</label>
            <input type="date" id="leaderboardDatePicker" style="padding:8px;border:1px solid #d1d5db;border-radius:4px;" onchange="displayLeaderboard(this.value)">
            <button id="prevDayBtn" onclick="changeDateBy(-1)" style="padding:8px 16px;cursor:pointer;margin-left:8px;">‚Üê Prev</button>
            <button id="nextDayBtn" onclick="changeDateBy(1)" style="padding:8px 16px;cursor:pointer;">Next ‚Üí</button>
            <button id="todayLeaderboardBtn" onclick="loadTodayScores()" style="padding:8px 16px;cursor:pointer;margin-left:8px;">Today</button>
        </div>
        <div id="leaderboardDate" style="text-align:center;margin-bottom:16px;font-size:1.1rem;color:#6b7280;font-weight:600;"></div>
        <div id="leaderboardContent" style="background:white;padding:20px;border-radius:8px;min-height:200px;max-height:520px;overflow-y:auto;">
            <p style="text-align:center;color:#6b7280;">Click a button above to view scores</p>
        </div>
        
        <!-- Compare Runs Button -->
        <div id="compareRunsContainer" style="margin-top:20px;text-align:center;display:block;">
            <button id="compareRunsBtn" onclick="toggleCompareTable()" style="padding:12px 24px;font-size:1rem;background:#9370db;color:white;border:none;border-radius:6px;cursor:pointer;font-weight:600;">
                Compare All Runs
            </button>
        </div>
        
        <!-- Comparison Table -->
        <div id="comparisonTableContainer" style="margin-top:20px;background:white;padding:20px;border-radius:8px;display:none;width:950px;">
            <h3 style="margin-top:0;">Run Comparison</h3>
            <div id="comparisonTable"></div>
        </div>
    </div>
    
    <!-- H2H Content (hidden by default) -->
    <div id="h2hContent" style="display:none;">
        <!-- Create Challenge Buttons -->
        <div style="margin-bottom:20px;display:flex;gap:12px;flex-wrap:wrap;">
            <button id="createChallengeBtn" style="padding:12px 24px;font-size:1rem;background:#9370db;color:white;border:none;border-radius:6px;cursor:pointer;font-weight:600;">
                ‚öîÔ∏è Challenge a Player
            </button>
            <button id="createOpenChallengeBtn" style="padding:12px 24px;font-size:1rem;background:#10b981;color:white;border:none;border-radius:6px;cursor:pointer;font-weight:600;">
                üåê Create Open Challenge
            </button>
        </div>
        
        <!-- Incoming Challenges -->
        <div style="margin-bottom:30px;">
            <h3 style="margin:0 0 12px 0;color:#1f2937;font-size:1.1rem;">üì• Incoming Challenges</h3>
            <div id="incomingChallenges" style="background:white;border-radius:8px;padding:16px;min-height:100px;">
                <p style="color:#9ca3af;text-align:center;">No incoming challenges</p>
            </div>
        </div>
        
        <!-- Outgoing Challenges -->
        <div style="margin-bottom:30px;">
            <h3 style="margin:0 0 12px 0;color:#1f2937;font-size:1.1rem;">üì§ Outgoing Challenges</h3>
            <div id="outgoingChallenges" style="background:white;border-radius:8px;padding:16px;min-height:100px;">
                <p style="color:#9ca3af;text-align:center;">No outgoing challenges</p>
            </div>
        </div>
        
        <!-- Completed Challenges / Results -->
        <div style="margin-bottom:30px;">
            <h3 style="margin:0 0 12px 0;color:#1f2937;font-size:1.1rem;">üèÜ Challenge Results</h3>
            <div id="h2hResults" style="background:white;border-radius:8px;padding:16px;min-height:100px;overflow-x:auto;">
                <p style="color:#9ca3af;text-align:center;">No completed challenges</p>
            </div>
        </div>
    </div>
</div>


<!-- MODAL: Select Opponent for H2H Challenge -->
<div id="opponentModalBackdrop" class="modal-backdrop">
    <div class="modal" style="max-width:500px;">
        <div class="modal-header" style="background:#9370db;">
            <div class="modal-title">Select Opponent</div>
            <button class="modal-close-btn" id="opponentModalCloseBtn" aria-label="Close">&times;</button>
        </div>
        <div class="modal-body">
            <input 
                type="text" 
                id="opponentSearchInput" 
                placeholder="Search by name..." 
                style="width:100%;padding:10px;margin-bottom:16px;border:2px solid #e5e7eb;border-radius:6px;font-size:15px;box-sizing:border-box;"
            />
            <div id="opponentList" style="max-height:300px;overflow-y:auto;">
                <!-- User list will be populated here -->
            </div>
        </div>
    </div>
</div>

<!-- MODAL: H2H Challenge Comparison -->
<div id="h2hComparisonModalBackdrop" class="modal-backdrop">
    <div class="modal" style="max-width:900px;">
        <div class="modal-header" style="background:#9370db;">
            <div class="modal-title" id="h2hComparisonTitle">H2H Challenge</div>
            <button class="modal-close-btn" id="h2hComparisonCloseBtn" aria-label="Close">&times;</button>
        </div>
        <div class="modal-body" style="padding:20px;">
            <div id="h2hComparisonContent">
                <!-- Comparison table will be populated here -->
            </div>
        </div>
    </div>
</div>

<!-- MODAL: Rules -->
<div id="rulesModalBackdrop" class="modal-backdrop">
    <div class="modal" style="max-width:600px;">
        <div class="modal-header" style="background:#9370db;">
            <div class="modal-title">How to Play</div>
            <button class="modal-close-btn" id="rulesModalCloseBtn" aria-label="Close">&times;</button>
        </div>
        <div class="modal-body">
            <!-- Objective -->
            <div style="margin-bottom:20px;">
                <div style="font-size:18px;font-weight:600;margin-bottom:16px;color:#1f2937;">Objective</div>
                <ul style="font-size:15px;line-height:1.8;color:#4b5563;margin:0;padding-left:20px;">
                    <li>Solve <strong>10 plates</strong> as fast as you can</li>
                    <li>To solve a plate, enter a word that contains the license plate letters <strong>in order</strong> (but not necessarily consecutively)</li>
                    <li>You can press <strong>Skip</strong>, but it adds a time penalty: +5s, then +10s, +15s, etc.</li>
                </ul>
            </div>
            
            <div style="height:1px;background:#e5e7eb;margin:16px 0;"></div>
            
            <!-- Examples -->
            <div style="margin-bottom:20px;">
                <div style="font-size:18px;font-weight:600;margin-bottom:16px;color:#1f2937;">Examples</div>
                
                <!-- Plate visual outside the examples -->
                <div style="text-align:center;margin-bottom:20px;">
                    <div style="background:white;border:3px solid #374151;border-radius:6px;padding:12px 20px;display:inline-block;font-size:32px;font-weight:900;letter-spacing:4px;font-family:'Courier New',monospace;">RSE</div>
                </div>
                
                <div style="background:#f0fdf4;border:2px solid #86efac;border-radius:8px;padding:12px;margin-bottom:10px;">
                    <div style="font-size:26px;font-weight:600;margin-bottom:6px;letter-spacing:1px;">
                        <span style="color:#16a34a;font-weight:800;">r</span><span style="color:#1f2937;">i</span><span style="color:#16a34a;font-weight:800;">s</span><span style="color:#16a34a;font-weight:800;">e</span>
                    </div>
                    <div style="font-size:13px;color:#6b7280;font-style:italic;">R, then S, then E ‚úì</div>
                </div>
                
                <div style="background:#f0fdf4;border:2px solid #86efac;border-radius:8px;padding:12px;margin-bottom:10px;">
                    <div style="font-size:26px;font-weight:600;margin-bottom:6px;letter-spacing:1px;">
                        <span style="color:#1f2937;">coa</span><span style="color:#16a34a;font-weight:800;">r</span><span style="color:#16a34a;font-weight:800;">s</span><span style="color:#16a34a;font-weight:800;">e</span>
                    </div>
                    <div style="font-size:13px;color:#6b7280;font-style:italic;">R, then S, then E (letters don't need to be consecutive) ‚úì</div>
                </div>
                
                <div style="background:#f0fdf4;border:2px solid #86efac;border-radius:8px;padding:12px;margin-bottom:10px;">
                    <div style="font-size:26px;font-weight:600;margin-bottom:6px;letter-spacing:1px;">
                        <span style="color:#1f2937;">b</span><span style="color:#16a34a;font-weight:800;">r</span><span style="color:#1f2937;">i</span><span style="color:#16a34a;font-weight:800;">s</span><span style="color:#1f2937;">k</span><span style="color:#16a34a;font-weight:800;">e</span><span style="color:#1f2937;">t</span>
                    </div>
                    <div style="font-size:13px;color:#6b7280;font-style:italic;">R appears first, then S, then E (can have letters in between) ‚úì</div>
                </div>
            </div>
            
            <div style="height:1px;background:#e5e7eb;margin:16px 0;"></div>
                
                <div style="background:#fef2f2;border:2px solid #fca5a5;border-radius:8px;padding:12px;margin-bottom:10px;">
                    <div style="font-size:26px;font-weight:600;margin-bottom:6px;letter-spacing:1px;">
                        <span style="color:#dc2626;font-weight:800;">s</span><span style="color:#1f2937;">u</span><span style="color:#16a34a;font-weight:800;">r</span><span style="color:#1f2937;">mi</span><span style="color:#16a34a;font-weight:800;">s</span><span style="color:#16a34a;font-weight:800;">e</span>
                    </div>
                    <div style="font-size:13px;color:#6b7280;font-style:italic;">
                        First S comes BEFORE the R - wrong order! ‚úó
                    </div>
                </div>
            </div>

            
            <button id="rulesModalCloseBtnBottom" style="width:100%;padding:14px;background:#9370db;color:white;border:none;border-radius:8px;font-size:16px;font-weight:600;cursor:pointer;margin-top:24px;">Got it!</button>
        </div>
    </div>
</div>


    <footer style="text-align:center;padding:20px;margin-top:40px;border-top:1px solid #e5e7eb;color:#6b7280;font-size:0.9rem;">
        ¬© 2026 Ezra Pemstein. All rights reserved.
    </footer>
</body>
</html>
